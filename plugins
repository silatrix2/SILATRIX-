const { cmd } = require('../command');
const os = require("os");
const { runtime } = require('../lib/functions');
const config = require('../config');

cmd({
    pattern: "alive",
    alias: ["status", "online", "a"],
    desc: "Check bot is alive or not",
    category: "main",
    react: "âš¡",
    filename: __filename
},
async (conn, mek, m, { from, sender, reply }) => {
    try {
        const status = `
â•­â”€â”€â”€ã€” *${config.BOT_NAME}* ã€•â”€â”€â”€â—‰
â”‚âœ¨ *Bot is Active & Online!*
â”‚
â”‚â™¦ï¸ *Owner:* ${config.OWNER_NAME}
â”‚â™¦ï¸ *Version:* 5.0.0 max
â”‚â™¦ï¸ *Prefix:* [${config.PREFIX}]
â”‚â™¦ï¸ *Mode:* [${config.MODE}]
â”‚â™¦ï¸ *RAM:* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${(os.totalmem() / 1024 / 1024).toFixed(2)}MB
â”‚â™¦ï¸ *Host:* ${os.hostname()}
â”‚â™¦ï¸ *Uptime:* ${runtime(process.uptime())}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—‰
> ${config.DESCRIPTION}`;

        await conn.sendMessage(from, {
            image: { url: config.MENU_IMAGE_URL },
            caption: status,
            contextInfo: {
                mentionedJid: [m.sender],
                forwardingScore: 1000,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363420222821450@newsletter',
                    newsletterName: 'sir T20',
                    serverMessageId: 143
                }
            }
        }, { quoted: mek });

    } catch (e) {
        console.error("Alive Error:", e);
        reply(`An error occurred: ${e.message}`);
    }
});


const { cmd } = require('../command');
const config = require("../config");

// Anti-Bad Words System
cmd({
  'on': "body"
}, async (conn, m, store, {
  from,
  body,
  isGroup,
  isAdmins,
  isBotAdmins,
  reply,
  sender
}) => {
  try {
    const badWords = ["wtf", "mia", "xxx", "fuck", 'sex', "huththa", "pakaya", 'ponnaya', "hutto"];

    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    const messageText = body.toLowerCase();
    const containsBadWord = badWords.some(word => messageText.includes(word));

    if (containsBadWord && config.ANTI_BAD_WORD === "true") {
      await conn.sendMessage(from, { 'delete': m.key }, { 'quoted': m });
      await conn.sendMessage(from, { 'text': "ğŸš« â˜£ï¸ BAD WORDS NOT ALLOWED âš ï¸ ğŸš«" }, { 'quoted': m });
    }
  } catch (error) {
    console.error(error);
    reply("An error occurred while processing the message.");
  }
});

const { cmd } = require('../command');
const { getAnti, setAnti } = require('../data/antidel');

cmd({
    pattern: "antidelete",
    alias: ['antidel', 'del'],
    desc: "Toggle anti-delete feature",
    category: "misc",
    filename: __filename
},
async (conn, mek, m, { from, reply, text, isCreator }) => {
    if (!isCreator) return reply('This command is only for the bot owner');
    
    try {
        const currentStatus = await getAnti();
        
        if (!text || text.toLowerCase() === 'status') {
            return reply(`*AntiDelete Status:* ${currentStatus ? 'âœ… ON' : 'âŒ OFF'}\n\nUsage:\nâ€¢ .antidelete on - Enable\nâ€¢ .antidelete off - Disable`);
        }
        
        const action = text.toLowerCase().trim();
        
        if (action === 'on') {
            await setAnti(true);
            return reply('âœ… Anti-delete has been enabled');
        } 
        else if (action === 'off') {
            await setAnti(false);
            return reply('âŒ Anti-delete has been disabled');
        } 
        else {
            return reply('Invalid command. Usage:\nâ€¢ .antidelete on\nâ€¢ .antidelete off\nâ€¢ .antidelete status');
        }
    } catch (e) {
        console.error("Error in antidelete command:", e);
        return reply("An error occurred while processing your request.");
    }
});

const { cmd } = require('../command');
const config = require("../config");

// Anti-Link System
const linkPatterns = [
  /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi,
  /^https?:\/\/(www\.)?whatsapp\.com\/channel\/([a-zA-Z0-9_-]+)$/,
  /wa\.me\/\S+/gi,
  /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,
  /https?:\/\/(?:www\.)?youtube\.com\/\S+/gi,
  /https?:\/\/youtu\.be\/\S+/gi,
  /https?:\/\/(?:www\.)?facebook\.com\/\S+/gi,
  /https?:\/\/fb\.me\/\S+/gi,
  /https?:\/\/(?:www\.)?instagram\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitter\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?tiktok\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?snapchat\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?pinterest\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,
  /https?:\/\/ngl\/\S+/gi,
  /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,
  /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?medium\.com\/\S+/gi
];

cmd({
  'on': "body"
}, async (conn, m, store, {
  from,
  body,
  sender,
  isGroup,
  isAdmins,
  isBotAdmins,
  reply
}) => {
  try {
    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    const containsLink = linkPatterns.some(pattern => pattern.test(body));

    if (containsLink && config.ANTI_LINK_KICK === 'true') {
      await conn.sendMessage(from, { 'delete': m.key }, { 'quoted': m });
      await conn.sendMessage(from, {
        'text': `ğŸ’˜ Links are not allowed in this group.\n@${sender.split('@')[0]} has been removed. ğŸš«`,
        'mentions': [sender]
      }, { 'quoted': m });

      await conn.groupParticipantsUpdate(from, [sender], "remove");
    }
  } catch (error) {
    console.error(error);
    reply("An error occurred while processing the message.");
  }
});

const { cmd } = require('../command');
const config = require("../config");

cmd({
  'on': "body"
}, async (conn, m, store, {
  from,
  body,
  sender,
  isGroup,
  isAdmins,
  isBotAdmins,
  reply
}) => {
  try {
    // Initialize warnings if not exists
    if (!global.warnings) {
      global.warnings = {};
    }

    // Only act in groups where bot is admin and sender isn't admin
    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    // List of link patterns to detect
    const linkPatterns = [
      /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi, // WhatsApp links
      /https?:\/\/(?:api\.whatsapp\.com|wa\.me)\/\S+/gi,  // WhatsApp API links
      /wa\.me\/\S+/gi,                                    // WhatsApp.me links
      /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,         // Telegram links
      /https?:\/\/(?:www\.)?\.com\/\S+/gi,                // Generic .com links
      /https?:\/\/(?:www\.)?twitter\.com\/\S+/gi,         // Twitter links
      /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,        // LinkedIn links
      /https?:\/\/(?:whatsapp\.com|channel\.me)\/\S+/gi,  // Other WhatsApp/channel links
      /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,          // Reddit links
      /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,         // Discord links
      /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,           // Twitch links
      /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,           // Vimeo links
      /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,     // Dailymotion links
      /https?:\/\/(?:www\.)?medium\.com\/\S+/gi           // Medium links
    ];

    // Check if message contains any forbidden links
    const containsLink = linkPatterns.some(pattern => pattern.test(body));

    // Only proceed if anti-link is enabled and link is detected
    if (containsLink && config.ANTI_LINK === 'true') {
      console.log(`Link detected from ${sender}: ${body}`);

      // Try to delete the message
      try {
        await conn.sendMessage(from, {
          delete: m.key
        });
        console.log(`Message deleted: ${m.key.id}`);
      } catch (error) {
        console.error("Failed to delete message:", error);
      }

      // Update warning count for user
      global.warnings[sender] = (global.warnings[sender] || 0) + 1;
      const warningCount = global.warnings[sender];

      // Handle warnings
      if (warningCount < 4) {
        // Send warning message
        await conn.sendMessage(from, {
          text: `â€*ğŸ¦  LINKS ARE NOT ALLOWED âš ï¸*\n` +
                `*â•­â”€â”€â”€â”€â¬¡ WARNING â¬¡â”€â”€â”€â”€*\n` +
                `*â”œâ–¢ USER :* @${sender.split('@')[0]}!\n` +
                `*â”œâ–¢ COUNT : ${warningCount}*\n` +
                `*â”œâ–¢ REASON : LINK SENDING*\n` +
                `*â”œâ–¢ WARN LIMIT : 2*\n` +
                `*â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*`,
          mentions: [sender]
        });
      } else {
        // Remove user if they exceed warning limit
        await conn.sendMessage(from, {
          text: `@${sender.split('@')[0]} *HAS BEEN REMOVED - WARN LIMIT EXCEEDED!*`,
          mentions: [sender]
        });
        await conn.groupParticipantsUpdate(from, [sender], "remove");
        delete global.warnings[sender];
      }
    }
  } catch (error) {
    console.error("Anti-link error:", error);
    reply("âŒ An error occurred while processing the message.");
  }
});

const { cmd } = require("../command");

cmd({
  pattern: "vv2",
  alias: ["wah", "ohh", "oho", "ğŸŒ¬ï¸", "nice", "ok"],
  desc: "Owner Only - retrieve quoted message back to user",
  category: "owner",
  filename: __filename
}, async (client, message, match, { from, isCreator }) => {
  try {
    if (!isCreator) {
      return; // Simply return without any response if not owner
    }

    if (!match.quoted) {
      return await client.sendMessage(from, {
        text: "*ğŸ Please reply to a view once message!*"
      }, { quoted: message });
    }

    const buffer = await match.quoted.download();
    const mtype = match.quoted.mtype;
    const options = { quoted: message };

    let messageContent = {};
    switch (mtype) {
      case "imageMessage":
        messageContent = {
          image: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "image/jpeg"
        };
        break;
      case "videoMessage":
        messageContent = {
          video: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "video/mp4"
        };
        break;
      case "audioMessage":
        messageContent = {
          audio: buffer,
          mimetype: "audio/mp4",
          ptt: match.quoted.ptt || false
        };
        break;
      default:
        return await client.sendMessage(from, {
          text: "âŒ Only image, video, and audio messages are supported"
        }, { quoted: message });
    }

    // Forward to user's DM
    await client.sendMessage(message.sender, messageContent, options);
  } catch (error) {
    console.error("vv Error:", error);
    await client.sendMessage(from, {
      text: "âŒ Error fetching vv message:\n" + error.message
    }, { quoted: message });
  }
});

const { cmd } = require("../command");

cmd({
  pattern: "vv",
  alias: ["viewonce", 'retrive'],
  react: 'ğŸ³',
  desc: "Owner Only - retrieve quoted message back to user",
  category: "owner",
  filename: __filename
}, async (client, message, match, { from, isCreator }) => {
  try {
    if (!isCreator) {
      return await client.sendMessage(from, {
        text: "*ğŸ’» This is an owner command.*"
      }, { quoted: message });
    }

    if (!match.quoted) {
      return await client.sendMessage(from, {
        text: "*ğŸ Please reply to a view once message!*"
      }, { quoted: message });
    }

    const buffer = await match.quoted.download();
    const mtype = match.quoted.mtype;
    const options = { quoted: message };

    let messageContent = {};
    switch (mtype) {
      case "imageMessage":
        messageContent = {
          image: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "image/jpeg"
        };
        break;
      case "videoMessage":
        messageContent = {
          video: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "video/mp4"
        };
        break;
      case "audioMessage":
        messageContent = {
          audio: buffer,
          mimetype: "audio/mp4",
          ptt: match.quoted.ptt || false
        };
        break;
      default:
        return await client.sendMessage(from, {
          text: "âŒ Only image, video, and audio messages are supported"
        }, { quoted: message });
    }

    await client.sendMessage(from, messageContent, options);
  } catch (error) {
    console.error("vv Error:", error);
    await client.sendMessage(from, {
      text: "âŒ Error fetching vv message:\n" + error.message
    }, { quoted: message });
  }
});

const fs = require('fs');
const path = require('path');
const config = require('../config')
const {cmd , commands} = require('../command')


//auto recording
cmd({
  on: "body"
},    
async (conn, mek, m, { from, body, isOwner }) => {       
 if (config.AUTO_RECORDING === 'true') {
                await conn.sendPresenceUpdate('recording', from);
            }
         } 
   );

const axios = require('axios');
const config = require('../config');
const fs = require('fs');
const path = require('path');
const {cmd , commands} = require('../command')


// Replace this with your actual GitHub RAW JSON URL
const GITHUB_RAW_URL = 'https://raw.githubusercontent.com/criss-vevo/CRISS-DATA/main/autoreply.json';

cmd({
  on: "body"
},
async (conn, mek, m, { body }) => {
  try {
    const res = await axios.get(GITHUB_RAW_URL);
    const data = res.data;

    for (const text in data) {
      if (body.toLowerCase() === text.toLowerCase()) {
        if (config.AUTO_REPLY === 'true') {
          await m.reply(data[text]);
        }
        break;
      }
    }
  } catch (err) {
    console.error('Auto-reply fetch error:', err.message);
  }
});

const axios = require('axios');
const config = require('../config');
const { cmd } = require('../command');

cmd({
  on: 'body'
}, async (conn, mek, m, { from, body }) => {
  try {
    const jsonUrl = 'https://raw.githubusercontent.com/criss-vevo/CRISS-DATA/main/autosticker.json';
    const res = await axios.get(jsonUrl);
    const data = res.data;

    for (const keyword in data) {
      if (body.toLowerCase() === keyword.toLowerCase()) {
        if (config.AUTO_STICKER === 'true') {
          await conn.sendMessage(
            from,
            {
              sticker: { url: data[keyword] },
              package: 'sir bravin'
            },
            { quoted: mek }
          );
        }
      }
    }
  } catch (e) {
    console.error('AutoSticker error:', e);
  }
});

const fs = require('fs');
const path = require('path');
const config = require('../config')
const {cmd , commands} = require('../command')


// Composing (Auto Typing)
cmd({
    on: "body"
},    
async (conn, mek, m, { from, body, isOwner }) => {
    if (config.AUTO_TYPING === 'true') {
        await conn.sendPresenceUpdate('composing', from); // send typing 
    }
});

const axios = require('axios');
const config = require("../config");
const { cmd } = require("../command");

cmd({ on: "body" }, async (conn, m, msg, { from, body }) => {
  try {
    const jsonUrl = "https://raw.githubusercontent.com/criss-vevo/CRISS-DATA/main/autovoice.json";
    const res = await axios.get(jsonUrl);
    const voiceMap = res.data;

    for (const keyword in voiceMap) {
      if (body.toLowerCase() === keyword.toLowerCase()) {
        if (config.AUTO_VOICE === "true") {
          const audioUrl = voiceMap[keyword];

          // Ensure it's a .mp3 or .m4a file
          if (!audioUrl.endsWith(".mp3") && !audioUrl.endsWith(".m4a")) {
            return conn.sendMessage(from, { text: "Invalid audio format. Only .mp3 and .m4a supported." }, { quoted: m });
          }

          await conn.sendPresenceUpdate("recording", from);
          await conn.sendMessage(from, {
            audio: { url: audioUrl },
            mimetype: "audio/mpeg", // This works fine for .mp3 and .m4a
            ptt: true
          }, { quoted: m });
        }
      }
    }
  } catch (e) {
    console.error("AutoVoice error:", e);
    return conn.sendMessage(from, { text: "Error fetching voice: " + e.message }, { quoted: m });
  }
});

const { cmd } = require('../command');

cmd({
    pattern: "block",
    desc: "Blocks a person",
    category: "owner",
    react: "ğŸ”¥",
    filename: __filename
},
async (conn, m, { reply, q, react }) => {
    // Get the bot owner's number dynamically
    const botOwner = conn.user.id.split(":")[0] + "@s.whatsapp.net";
    
    if (m.sender !== botOwner) {
        await react("âŒ");
        return reply("Only the bot owner can use this command.");
    }

    let jid;
    if (m.quoted) {
        jid = m.quoted.sender; // If replying to a message, get sender JID
    } else if (m.mentionedJid.length > 0) {
        jid = m.mentionedJid[0]; // If mentioning a user, get their JID
    } else if (q && q.includes("@")) {
        jid = q.replace(/[@\s]/g, '') + "@s.whatsapp.net"; // If manually typing a JID
    } else {
        await react("âŒ");
        return reply("Please mention a user or reply to their message.");
    }

    try {
        await conn.updateBlockStatus(jid, "block");
        await react("âœ…");
        reply(`Successfully blocked @${jid.split("@")[0]}`, { mentions: [jid] });
    } catch (error) {
        console.error("Block command error:", error);
        await react("âŒ");
        reply("Failed to block the user.");
    }
});

cmd({
    pattern: "unblock",
    desc: "Unblocks a person",
    category: "owner",
    react: "ğŸ”“",
    filename: __filename
},
async (conn, m, { reply, q, react }) => {
    // Get the bot owner's number dynamically
    const botOwner = conn.user.id.split(":")[0] + "@s.whatsapp.net";

    if (m.sender !== botOwner) {
        await react("âŒ");
        return reply("Only the bot owner can use this command.");
    }

    let jid;
    if (m.quoted) {
        jid = m.quoted.sender;
    } else if (m.mentionedJid.length > 0) {
        jid = m.mentionedJid[0];
    } else if (q && q.includes("@")) {
        jid = q.replace(/[@\s]/g, '') + "@s.whatsapp.net";
    } else {
        await react("âŒ");
        return reply("Please mention a user or reply to their message.");
    }

    try {
        await conn.updateBlockStatus(jid, "unblock");
        await react("âœ…");
        reply(`Successfully unblocked @${jid.split("@")[0]}`, { mentions: [jid] });
    } catch (error) {
        console.error("Unblock command error:", error);
        await react("âŒ");
        reply("Failed to unblock the user.");
    }
});           



const config = require('../config');
const { cmd } = require('../command');

const stylizedChars = {
    a: 'ğŸ…', b: 'ğŸ…‘', c: 'ğŸ…’', d: 'ğŸ…“', e: 'ğŸ…”', f: 'ğŸ…•', g: 'ğŸ…–',
    h: 'ğŸ…—', i: 'ğŸ…˜', j: 'ğŸ…™', k: 'ğŸ…š', l: 'ğŸ…›', m: 'ğŸ…œ', n: 'ğŸ…',
    o: 'ğŸ…', p: 'ğŸ…Ÿ', q: 'ğŸ… ', r: 'ğŸ…¡', s: 'ğŸ…¢', t: 'ğŸ…£', u: 'ğŸ…¤',
    v: 'ğŸ…¥', w: 'ğŸ…¦', x: 'ğŸ…§', y: 'ğŸ…¨', z: 'ğŸ…©',
    '0': 'â“¿', '1': 'âŠ', '2': 'â‹', '3': 'âŒ', '4': 'â',
    '5': 'â', '6': 'â', '7': 'â', '8': 'â‘', '9': 'â’'
};

cmd({
    pattern: "chr",
    alias: ["creact"],
    react: "ğŸ”¤",
    desc: "React to channel messages with stylized text",
    category: "owner",
    use: '.chr <channel-link> <text>',
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isCreator, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isCreator) return reply("âŒ Owner only command");
        if (!q) return reply(`Usage:\n${command} https://whatsapp.com/channel/1234567890 hello`);

        const [link, ...textParts] = q.split(' ');
        if (!link.includes("whatsapp.com/channel/")) return reply("Invalid channel link format");
        
        const inputText = textParts.join(' ').toLowerCase();
        if (!inputText) return reply("Please provide text to convert");

        const emoji = inputText
            .split('')
            .map(char => {
                if (char === ' ') return 'â€•';
                return stylizedChars[char] || char;
            })
            .join('');

        const channelId = link.split('/')[4];
        const messageId = link.split('/')[5];
        if (!channelId || !messageId) return reply("Invalid link - missing IDs");

        const channelMeta = await conn.newsletterMetadata("invite", channelId);
        await conn.newsletterReactMessage(channelMeta.id, messageId, emoji);

        return reply(`â•­â”â”â”ã€” *TOXIC LOVER- V2 XMD* ã€•â”â”â”â”ˆâŠ·
â”ƒâ–¸ *Success!* Reaction sent
â”ƒâ–¸ *Channel:* ${channelMeta.name}
â”ƒâ–¸ *Reaction:* ${emoji}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
> *Â© Pá´á´¡á´‡Ê€á´‡á´… BÊ sir bravinâ™¡*`);
    } catch (e) {
        console.error(e);
        reply(`â Error: ${e.message || "Failed to send reaction"}`);
    }
});

const { cmd } = require('../command');

cmd({
    pattern: "online",
    alias: ["whosonline", "onlinemembers"],
    desc: "Check who's online in the group (Admins & Owner only)",
    category: "main",
    react: "ğŸ‚",
    filename: __filename
},
async (conn, mek, m, { from, quoted, isGroup, isAdmins, isCreator, fromMe, reply }) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) return reply("âŒ This command can only be used in a group!");

        // Check if user is either creator or admin
        if (!isCreator && !isAdmins && !fromMe) {
            return reply("âŒ Only bot owner and group admins can use this command!");
        }

        // Inform user that we're checking
        await reply("ğŸ”„ Scanning for online members... This may take 15-20 seconds.");

        const onlineMembers = new Set();
        const groupData = await conn.groupMetadata(from);
        const presencePromises = [];

        // Request presence updates for all participants
        for (const participant of groupData.participants) {
            presencePromises.push(
                conn.presenceSubscribe(participant.id)
                    .then(() => {
                        // Additional check for better detection
                        return conn.sendPresenceUpdate('composing', participant.id);
                    })
            );
        }

        await Promise.all(presencePromises);

        // Presence update handler
        const presenceHandler = (json) => {
            for (const id in json.presences) {
                const presence = json.presences[id]?.lastKnownPresence;
                // Check all possible online states
                if (['available', 'composing', 'recording', 'online'].includes(presence)) {
                    onlineMembers.add(id);
                }
            }
        };

        conn.ev.on('presence.update', presenceHandler);

        // Longer timeout and multiple checks
        const checks = 3;
        const checkInterval = 5000; // 5 seconds
        let checksDone = 0;

        const checkOnline = async () => {
            checksDone++;
            
            if (checksDone >= checks) {
                clearInterval(interval);
                conn.ev.off('presence.update', presenceHandler);
                
                if (onlineMembers.size === 0) {
                    return reply("âš ï¸ Couldn't detect any online members. They might be hiding their presence.");
                }
                
                const onlineArray = Array.from(onlineMembers);
                const onlineList = onlineArray.map((member, index) => 
                    `${index + 1}. @${member.split('@')[0]}`
                ).join('\n');
                
                const message = `ğŸŸ¢ *Online Members* (${onlineArray.length}/${groupData.participants.length}):\n\n${onlineList}`;
                
                await conn.sendMessage(from, { 
                    text: message,
                    mentions: onlineArray
                }, { quoted: mek });
            }
        };

        const interval = setInterval(checkOnline, checkInterval);

    } catch (e) {
        console.error("Error in online command:", e);
        reply(`An error occurred: ${e.message}`);
    }
});

const axios = require('axios');
const os = require('os');
const fs = require('fs');
const path = require('path');
const { cmd, commands } = require('../command');
const { runtime } = require('../lib/functions');

cmd({
  pattern: 'version',
  alias: ["changelog", "cupdate", "checkupdate"],
  react: 'ğŸš€',
  desc: "Check bot's version, system stats, and update info.",
  category: 'info',
  filename: __filename
}, async (conn, mek, m, {
  from, sender, pushname, reply
}) => {
  try {
    // Read local version data
    const localVersionPath = path.join(__dirname, '../data/version.json');
    let localVersion = 'Unknown';
    let changelog = 'No changelog available.';
    if (fs.existsSync(localVersionPath)) {
      const localData = JSON.parse(fs.readFileSync(localVersionPath));
      localVersion = localData.version;
      changelog = localData.changelog;
    }

    // Fetch latest version data from GitHub
    const rawVersionUrl = 'https://raw.githubusercontent.com/criss-vevo/CRISS-MD/main/data/version.json';
    let latestVersion = 'Unknown';
    let latestChangelog = 'No changelog available.';
    try {
      const { data } = await axios.get(rawVersionUrl);
      latestVersion = data.version;
      latestChangelog = data.changelog;
    } catch (error) {
      console.error('Failed to fetch latest version:', error);
    }

    // Count total plugins
    const pluginPath = path.join(__dirname, '../plugins');
    const pluginCount = fs.readdirSync(pluginPath).filter(file => file.endsWith('.js')).length;

    // Count total registered commands
    const totalCommands = commands.length;

    // System info
    const uptime = runtime(process.uptime());
    const ramUsage = (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2);
    const totalRam = (os.totalmem() / 1024 / 1024).toFixed(2);
    const hostName = os.hostname();
    const lastUpdate = fs.statSync(localVersionPath).mtime.toLocaleString();

    // GitHub stats
    const githubRepo = 'https://github.com/lovertoxic/TOXIC-LOVER-V2-XMD';

    // Check update status
    let updateMessage = `âœ… Your Êœá´œÉ´á´›á´‡Ê€ xá´á´… bot is up-to-date!`;
    if (localVersion !== latestVersion) {
      updateMessage = `ğŸš€ Your SAGITTARIUS TERMINATOR xmd bot is outdated!
ğŸ”¹ *Current Version:* ${localVersion}
ğŸ”¹ *Latest Version:* ${latestVersion}

Use *.update* to update.`;
    }

    const statusMessage = `ğŸŒŸ *Good ${new Date().getHours() < 12 ? 'Morning' : 'Night'}, ${pushname}!* ğŸŒŸ\n\n` +
      `ğŸ“Œ *Bot Name:* SAGITTARIUS TERMINATOR xá´á´…\nğŸ”– *Current Version:* ${localVersion}\nğŸ“¢ *Latest Version:* ${latestVersion}\nğŸ“‚ *Total Plugins:* ${pluginCount}\nğŸ”¢ *Total Commands:* ${totalCommands}\n\n` +
      `ğŸ’¾ *System Info:*\nâ³ *Uptime:* ${uptime}\nğŸ“Ÿ *RAM Usage:* ${ramUsage}MB / ${totalRam}MB\nâš™ï¸ *Host Name:* ${hostName}\nğŸ“… *Last Update:* ${lastUpdate}\n\n` +
      `ğŸ“ *Changelog:*\n${latestChangelog}\n\n` +
      `â­ *GitHub Repo:* ${githubRepo}\nğŸ‘¤ *Owner:* [sir bravin](https://github.com/lovertoxic)\n\n${updateMessage}\n\nğŸš€ *Hey! Don't forget to fork & star the repo!*`;

    // Send the status message with an image
    await conn.sendMessage(from, {
      image: { url: `https://files.catbox.moe/m2s3cg.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir T20_STARBOY',
                        serverMessageId: 143
        }
      }
    }, { quoted: mek });
  } catch (error) {
    console.error('Error fetching version info:', error);
    reply('âŒ An error occurred while checking the bot version.');
  }
});

const config = require('../config')
const { cmd, commands } = require('../command');

cmd({
    pattern: "list",
    alias: ["listcmd","commands"],
    desc: "menu the bot",
    category: "menu",
    react: "âš¡",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let dec = `â•­â”â® *DOWNLOAD CMD* â¯â”â”ˆâŠ·
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .play
â”ƒâ–¸â• Download Audio from yt
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .song
â”ƒâ–¸â• Download song from yt
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .apk
â”ƒâ–¸â• Download apk from playstore
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .video
â”ƒâ–¸â• Download video from yt
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .fb
â”ƒâ–¸â• Download  video from fb
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .tk
â”ƒâ–¸â• Download video from tiktok
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .ig
â”ƒâ–¸â• Download video from ig
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .gdrive
â”ƒâ–¸â• Download drive files
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .twitter
â”ƒâ–¸â• Download video from Twitter
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .img
â”ƒâ–¸â• Download image
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .darama
â”ƒâ–¸â• Download full episode video
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .play2
â”ƒâ–¸â• Download Audio from yt
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .video2
â”ƒâ–¸â• Download video from yt
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .baiscope
â”ƒâ–¸â• Download video from baiscope
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .mfire
â”ƒâ–¸â• Download mediafire files
â•°â”â”â”â”â”â”â”â”â”â”â”â”âª¼ 

â•­â”â® *ANMIE CMD* â¯â”â”ˆâŠ·
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .yts
â”ƒâ–¸â• Serch videos from yt
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .king
â”ƒâ–¸â• get king about 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .dog
â”ƒâ–¸â• get random dog imgs
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .anime 
â”ƒâ–¸â• get anime pics
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .animegirl 
â”ƒâ–¸â• get animegirl pics
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .loli
â”ƒâ–¸â• get romantic anime pics
â•°â”â”â”â”â”â”â”â”â”â”â”â”âª¼  

â•­â”â®â€ *INFO CMD* â¯â”â”ˆâŠ·
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .alive
â”ƒâ–¸â• Check online or not
â”ƒâ–¸  
â”ƒâ–¸ğŸ“„ COMMAND: .ping
â”ƒâ–¸â• Check bot speed
â”ƒâ–¸  
â”ƒâ–¸ğŸ“„ COMMAND: .menu
â”ƒâ–¸â• Nero main menu
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .menu2
â”ƒâ–¸â• Nero main menu2
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .ai
â”ƒâ–¸â• chat with ai bot
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .system
â”ƒâ–¸â• check bot systems
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .owner
â”ƒâ–¸â• get owner info
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .status
â”ƒâ–¸â• check bot runtime
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .about 
â”ƒâ–¸â• get about bot 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .list 
â”ƒâ–¸â• get bot command list
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .script 
â”ƒâ–¸â• get bot repository 
â•°â”â”â”â”â”â”â”â”â”â”â”â”âª¼

â•­â”â® *OTHER CMD* â¯â”â”ˆâŠ·
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .joke 
â”ƒâ–¸â• Get Rendom joke 
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .fact
â”ƒâ–¸â• Get Rendom fact
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .githubstalk 
â”ƒâ–¸â• Get github data any user
â”ƒâ–¸ 
â”ƒâ–¸ğŸ“„ COMMAND: .gpass
â”ƒâ–¸â• Get a strong password 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .hack
â”ƒâ–¸â• prank with friends 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .srepo 
â”ƒâ–¸â• serch repository 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .define 
â”ƒâ–¸â• serch any words
â•°â”â”â”â”â”â”â”â”â”â”â”â”âª¼

â•­â”â® *GROUP CMD* â¯â”â”ˆâŠ·
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .mute
â”ƒâ–¸â• Mute group
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .unmute
â”ƒâ–¸â• Unmute group
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .left
â”ƒâ–¸â• left group
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .jid
â”ƒâ–¸â• group jid
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .remove
â”ƒâ–¸â• remove member from group
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .delete 
â”ƒâ–¸â• remove sms from group 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .add
â”ƒâ–¸â• add members in group 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .kick
â”ƒâ–¸â• kick any user 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .kickall
â”ƒâ–¸â• remove all members from group
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .setgoodbye
â”ƒâ–¸â• set member leave sms
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .setwelcome 
â”ƒâ–¸â• set member welcome sms
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: promote 
â”ƒâ–¸â• make group admin
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .demote 
â”ƒâ–¸â• dissmis any admin 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .tagall
â”ƒâ–¸â• mention group all members
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .getpic
â”ƒâ–¸â• get group profile
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .invite 
â”ƒâ–¸â• get group invite link
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .revoke 
â”ƒâ–¸â• reset group link
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .joinrequests
â”ƒâ–¸â• cheack group panding members
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .allreq
â”ƒâ–¸â• add group panding members 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .lockgc
â”ƒâ–¸â• lock group private
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .unlockgc
â”ƒâ–¸â• unlock group all
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .leave 
â”ƒâ–¸â• left any group 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .updategname
â”ƒâ–¸â• set group name
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .updategdesc
â”ƒâ–¸â• set group description 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .joim
â”ƒâ–¸â• join invite link 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .hidetag
â”ƒâ–¸â• mention any user hide
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .ginfo
â”ƒâ–¸â• get group information 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .disappear on
â”ƒâ–¸â• on disappear sms in group 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .disappear off
â”ƒâ–¸â• off disappear sms in group 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .senddm
â”ƒâ–¸â• send disappear sms in group 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .disappear 7d 24h 90d
â”ƒâ–¸â• set time to disappear sms
â•°â”â”â”â”â”â”â”â”â”â”â”â”âª¼

â•­â”â® *OWNER CMD* â¯â”â”ˆâŠ·
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .update
â”ƒâ–¸â• update bot velue 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .restart 
â”ƒâ–¸â• restart your bot
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .settings
â”ƒâ–¸â• see bot settings
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .owner 
â”ƒâ–¸â• get owner number 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .repo 
â”ƒâ–¸â• get bot repository 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .system 
â”ƒâ–¸â• check bot systems
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .block
â”ƒâ–¸â• block any user 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .unblock 
â”ƒâ–¸â• unblock any user 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .shutdown 
â”ƒâ–¸â• logout your bot
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .clearchats 
â”ƒâ–¸â• clearchats from ib
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .setpp
â”ƒâ–¸â• update profile pic
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .broadcast 
â”ƒâ–¸â• creat broadcast 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .jid
â”ƒâ–¸â• get jid any user
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .gjid 
â”ƒâ–¸â• get group jid
â•°â”â”â”â”â”â”â”â”â”â”â”â”âª¼

â•­â”â® *CONVERT CMD* â¯â”â”ˆâŠ·
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .sticker
â”ƒâ–¸â• convert photo to sticker
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .tts
â”ƒâ–¸â• change text to voice 
â”ƒâ–¸
â”ƒâ–¸ğŸ“„ COMMAND: .trt 
â”ƒâ–¸â• change languages 
â•°â”â”â”â”â”â”â”â”â”â”â”â”âª¼
> ${config.DESCRIPTION}`;

        await conn.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/fbm1sw.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'toxic lover-v2 xmd',
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

        // Send audio
        await conn.sendMessage(from, {
            audio: { url: 'https://github.com/criss-vevo/CRISS-DATA/raw/refs/heads/main/autovoice/menunew.m4a' },
            mimetype: 'audio/mp4',
            ptt: true
        }, { quoted: mek });
        
    } catch (e) {
        console.log(e);
        reply(`${e}`);
    }
});

const { cmd, commands } = require('../command');
const axios = require('axios');

cmd({
  'pattern': "couplepp",
  'alias': ["couple", "cpp"],
  'react': 'âš ï¸',
  'desc': "Get a male and female couple profile picture.",
  'category': "image",
  'use': ".couplepp",
  'filename': __filename
}, async (conn, m, store, {
  from,
  args,
  reply
}) => {
  try {
    reply("*ğŸ’‘ Fetching couple profile pictures...*");
    
    const response = await axios.get("https://api.davidcyriltech.my.id/couplepp");

    if (!response.data || !response.data.success) {
      return reply("âŒ Failed to fetch couple profile pictures. Please try again later.");
    }

    const malePp = response.data.male;
    const femalePp = response.data.female;

    if (malePp) {
      await conn.sendMessage(from, {
        'image': { 'url': malePp },
        'caption': "ğŸ‘¨ Male Couple Profile Picture"
      }, { 'quoted': m });
    }

    if (femalePp) {
      await conn.sendMessage(from, {
        'image': { 'url': femalePp },
        'caption': "ğŸ‘© Female Couple Profile Picture"
      }, { 'quoted': m });
    }

  } catch (error) {
    console.error(error);
    reply("âŒ An error occurred while fetching the couple profile pictures.");
  }
});

const axios = require('axios');
const { cmd } = require('../command');

cmd({
    pattern: "define",
    desc: "ğŸ“– Get the definition of a word",
    react: "ğŸŒ€",
    category: "search",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("Please provide a word to define.\n\nğŸ“Œ *Usage:* .define [word]");

        const word = q.trim();
        const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;

        const response = await axios.get(url);
        const definitionData = response.data[0];

        const definition = definitionData.meanings[0].definitions[0].definition;
        const example = definitionData.meanings[0].definitions[0].example || 'âŒ No example available';
        const synonyms = definitionData.meanings[0].definitions[0].synonyms.join(', ') || 'âŒ No synonyms available';
        const phonetics = definitionData.phonetics[0]?.text || 'ğŸ”‡ No phonetics available';
        const audio = definitionData.phonetics[0]?.audio || null;

        const wordInfo = `
ğŸ“– *Word*: *${definitionData.word}*  
ğŸ—£ï¸ *Pronunciation*: _${phonetics}_  
ğŸ“š *Definition*: ${definition}  
âœï¸ *Example*: ${example}  
ğŸ“ *Synonyms*: ${synonyms}  

ğŸ”— *Powered By sir bravin*`;

        if (audio) {
            await conn.sendMessage(from, { audio: { url: audio }, mimetype: 'audio/mpeg' }, { quoted: mek });
        }

        return reply(wordInfo);
    } catch (e) {
        console.error("âŒ Error:", e);
        if (e.response && e.response.status === 404) {
            return reply("ğŸš« *Word not found.* Please check the spelling and try again.");
        }
        return reply("âš ï¸ An error occurred while fetching the definition. Please try again later.");
    }
});

const { cmd } = require('../command');
const config = require('../config');

const linkPatterns = [
  /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi,
  /^https?:\/\/(www\.)?whatsapp\.com\/channel\/([a-zA-Z0-9_-]+)$/,
  /wa\.me\/\S+/gi,
  /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,
  /https?:\/\/(?:www\.)?youtube\.com\/\S+/gi,
  /https?:\/\/youtu\.be\/\S+/gi,
  /https?:\/\/(?:www\.)?facebook\.com\/\S+/gi,
  /https?:\/\/fb\.me\/\S+/gi,
  /https?:\/\/(?:www\.)?instagram\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitter\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?tiktok\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?snapchat\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?pinterest\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,
  /https?:\/\/ngl\/\S+/gi,
  /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,
  /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?medium\.com\/\S+/gi
];

cmd({
  on: 'body'
}, async (conn, m, store, {
  from,
  body,
  sender,
  isGroup,
  isAdmins,
  isBotAdmins
}) => {
  try {
    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    const containsLink = linkPatterns.some(pattern => pattern.test(body));

    if (containsLink && config.DELETE_LINKS === 'true') {
      await conn.sendMessage(from, { delete: m.key }, { quoted: m });
    }
  } catch (error) {
    console.error(error);
  }
});
const axios = require("axios");
const { cmd } = require("../command");

cmd({
  pattern: "fb",
  alias: ["facebook", "fbdl"],
  desc: "Download Facebook videos",
  category: "download",
  filename: __filename,
  use: "<Facebook URL>",
}, async (conn, m, store, { from, args, q, reply }) => {
  try {
    // Check if a URL is provided
    if (!q || !q.startsWith("http")) {
      return reply("*`Need a valid Facebook URL`*\n\nExample: `.fb https://www.facebook.com/...`");
    }

    // Add a loading react
    await conn.sendMessage(from, { react: { text: 'â³', key: m.key } });

    // Fetch video URL from the API
    const apiUrl = `https://www.velyn.biz.id/api/downloader/facebookdl?url=${encodeURIComponent(q)}`;
    const { data } = await axios.get(apiUrl);

    // Check if the API response is valid
    if (!data.status || !data.data || !data.data.url) {
      return reply("ğŸš« Failed to fetch the video. Please try another link.");
    }

    // Send the video to the user
    const videoUrl = data.data.url;
    await conn.sendMessage(from, {
      video: { url: videoUrl },
      caption: "ğŸ“¥ *Facebook Video Downloaded*\n\n- *Powered By Criss Vevo âœ…*",
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error); // Log the error for debugging
    reply("âŒ Error fetching the video. Please try again.");
  }
});

const { cmd } = require("../command");
const axios = require("axios");

cmd({
    pattern: "img",
    alias: ["image", "googleimage", "searchimg"],
    react: "ğŸ•¶ï¸",
    desc: "Search and download Google images",
    category: "fun",
    use: ".img <keywords>",
    filename: __filename
}, async (conn, mek, m, { reply, args, from }) => {
    try {
        const query = args.join(" ");
        if (!query) {
            return reply("ğŸ–¼ï¸ Please provide a search query\nExample: .img cute cats");
        }

        await reply(`ğŸ” Searching images for "${query}"...`);

        const url = `https://apis.davidcyriltech.my.id/googleimage?query=${encodeURIComponent(query)}`;
        const response = await axios.get(url);

        // Validate response
        if (!response.data?.success || !response.data.results?.length) {
            return reply("âŒ No images found. Try different keywords");
        }

        const results = response.data.results;
        // Get 5 random images
        const selectedImages = results
            .sort(() => 0.5 - Math.random())
            .slice(0, 5);

        for (const imageUrl of selectedImages) {
            await conn.sendMessage(
                from,
                { 
                    image: { url: imageUrl },
                    caption: `ğŸ“· Result for: ${query}\n> Â© Powered by Êœá´œÉ´á´›á´‡Ê€ xá´á´…`
                },
                { quoted: mek }
            );
            // Add delay between sends to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

    } catch (error) {
        console.error('Image Search Error:', error);
        reply(`âŒ Error: ${error.message || "Failed to fetch images"}`);
    }
});

const axios = require("axios");
const { cmd, commands } = require("../command");

cmd({
    pattern: "ringtone",
    alias: ["ringtones", "ring"],
    desc: "Get a random ringtone from the API.",
    react: "ğŸ¦´",
    category: "fun",
    filename: __filename,
},
async (conn, mek, m, { from, reply, args }) => {
    try {
        const query = args.join(" ");
        if (!query) {
            return reply("Please provide a search query! Example: .ringtone Suna");
        }

        const { data } = await axios.get(`https://www.dark-yasiya-api.site/download/ringtone?text=${encodeURIComponent(query)}`);

        if (!data.status || !data.result || data.result.length === 0) {
            return reply("No ringtones found for your query. Please try a different keyword.");
        }

        const randomRingtone = data.result[Math.floor(Math.random() * data.result.length)];

        await conn.sendMessage(
            from,
            {
                audio: { url: randomRingtone.dl_link },
                mimetype: "audio/mpeg",
                fileName: `${randomRingtone.title}.mp3`,
            },
            { quoted: m }
        );
    } catch (error) {
        console.error("Error in ringtone command:", error);
        reply("Sorry, something went wrong while fetching the ringtone. Please try again later.");
    }
});

const { cmd } = require('../command');
const axios = require('axios');

cmd({
    pattern: "tiktok",
    alias: ["ttdl", "tt", "tiktokdl"],
    desc: "Download TikTok video without watermark",
    category: "downloader",
    react: "ğŸµ",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply }) => {
    try {
        if (!q) return reply("Please provide a TikTok video link.");
        if (!q.includes("tiktok.com")) return reply("Invalid TikTok link.");
        
        reply("Downloading video, please wait...");
        
        const apiUrl = `https://delirius-apiofc.vercel.app/download/tiktok?url=${q}`;
        const { data } = await axios.get(apiUrl);
        
        if (!data.status || !data.data) return reply("Failed to fetch TikTok video.");
        
        const { title, like, comment, share, author, meta } = data.data;
        const videoUrl = meta.media.find(v => v.type === "video").org;
        
        const caption = `ğŸµ *TikTok Video* ğŸµ\n\n` +
                        `ğŸ‘¤ *User:* ${author.nickname} (@${author.username})\n` +
                        `ğŸ“– *Title:* ${title}\n` +
                        `ğŸ‘ *Likes:* ${like}\nğŸ’¬ *Comments:* ${comment}\nğŸ” *Shares:* ${share}`;
        
        await conn.sendMessage(from, {
            video: { url: videoUrl },
            caption: caption,
            contextInfo: { mentionedJid: [m.sender] }
        }, { quoted: mek });
        
    } catch (e) {
        console.error("Error in TikTok downloader command:", e);
        reply(`An error occurred: ${e.message}`);
    }
});
          

const { cmd } = require('../command');
const axios = require('axios');

cmd({
    pattern: "ytpost",
    alias: ["ytcommunity", "ytc"],
    desc: "Download a YouTube community post",
    category: "downloader",
    react: "ğŸ¤¸",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply, react }) => {
    try {
        if (!q) return reply("Please provide a YouTube community post URL.\nExample: `.ytpost <url>`");

        const apiUrl = `https://api.siputzx.my.id/api/d/ytpost?url=${encodeURIComponent(q)}`;
        const { data } = await axios.get(apiUrl);

        if (!data.status || !data.data) {
            await react("âŒ");
            return reply("Failed to fetch the community post. Please check the URL.");
        }

        const post = data.data;
        let caption = `ğŸ“¢ *YouTube Community Post* ğŸ“¢\n\n` +
                      `ğŸ“œ *Content:* ${post.content}`;

        if (post.images && post.images.length > 0) {
            for (const img of post.images) {
                await conn.sendMessage(from, { image: { url: img }, caption }, { quoted: mek });
                caption = ""; // Only add caption once, images follow
            }
        } else {
            await conn.sendMessage(from, { text: caption }, { quoted: mek });
        }

        await react("âœ…");
    } catch (e) {
        console.error("Error in ytpost command:", e);
        await react("âŒ");
        reply("An error occurred while fetching the YouTube community post.");
    }
});

const { fetchJson } = require("../lib/functions");
const { downloadTiktok } = require("@mrnima/tiktok-downloader");
const { facebook } = require("@mrnima/facebook-downloader");
const cheerio = require("cheerio");
const { igdl } = require("ruhend-scraper");
const axios = require("axios");
const { cmd, commands } = require('../command');

cmd({
  pattern: "ig2",
  alias: ["insta2", "Instagram2"],
  desc: "To download Instagram videos.",
  react: "ğŸ¥",
  category: "download",
  filename: __filename
}, async (conn, m, store, { from, q, reply }) => {
  try {
    if (!q || !q.startsWith("http")) {
      return reply("âŒ Please provide a valid Instagram link.");
    }

    await conn.sendMessage(from, {
      react: { text: "â³", key: m.key }
    });

    const response = await axios.get(`https://api.davidcyriltech.my.id/instagram?url=${q}`);
    const data = response.data;

    if (!data || data.status !== 200 || !data.downloadUrl) {
      return reply("âš ï¸ Failed to fetch Instagram video. Please check the link and try again.");
    }

    await conn.sendMessage(from, {
      video: { url: data.downloadUrl },
      mimetype: "video/mp4",
      caption: "ğŸ“¥ *Instagram Video Downloaded Successfully!*"
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error);
    reply("âŒ An error occurred while processing your request. Please try again.");
  }
});


// twitter-dl

cmd({
  pattern: "twitter",
  alias: ["tweet", "twdl"],
  desc: "Download Twitter videos",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q || !q.startsWith("https://")) {
      return conn.sendMessage(from, { text: "âŒ Please provide a valid Twitter URL." }, { quoted: m });
    }

    await conn.sendMessage(from, {
      react: { text: 'â³', key: m.key }
    });

    const response = await axios.get(`https://www.dark-yasiya-api.site/download/twitter?url=${q}`);
    const data = response.data;

    if (!data || !data.status || !data.result) {
      return reply("âš ï¸ Failed to retrieve Twitter video. Please check the link and try again.");
    }

    const { desc, thumb, video_sd, video_hd } = data.result;

    const caption = `â•­â”â”â”ã€” *TWITTER DOWNLOADER* ã€•â”â”â”âŠ·\n`
      + `â”ƒâ–¸ *Description:* ${desc || "No description"}\n`
      + `â•°â”â”â”âª¼\n\n`
      + `ğŸ“¹ *Download Options:*\n`
      + `1ï¸âƒ£  *SD Quality*\n`
      + `2ï¸âƒ£  *HD Quality*\n`
      + `ğŸµ *Audio Options:*\n`
      + `3ï¸âƒ£  *Audio*\n`
      + `4ï¸âƒ£  *Document*\n`
      + `5ï¸âƒ£  *Voice*\n\n`
      + `ğŸ“Œ *Reply with the number to download your choice.*`;

    const sentMsg = await conn.sendMessage(from, {
      image: { url: thumb },
      caption: caption
    }, { quoted: m });

    const messageID = sentMsg.key.id;

    conn.ev.on("messages.upsert", async (msgData) => {
      const receivedMsg = msgData.messages[0];
      if (!receivedMsg.message) return;

      const receivedText = receivedMsg.message.conversation || receivedMsg.message.extendedTextMessage?.text;
      const senderID = receivedMsg.key.remoteJid;
      const isReplyToBot = receivedMsg.message.extendedTextMessage?.contextInfo?.stanzaId === messageID;

      if (isReplyToBot) {
        await conn.sendMessage(senderID, {
          react: { text: 'â¬‡ï¸', key: receivedMsg.key }
        });

        switch (receivedText) {
          case "1":
            await conn.sendMessage(senderID, {
              video: { url: video_sd },
              caption: "ğŸ“¥ *Downloaded in SD Quality*"
            }, { quoted: receivedMsg });
            break;

          case "2":
            await conn.sendMessage(senderID, {
              video: { url: video_hd },
              caption: "ğŸ“¥ *Downloaded in HD Quality*"
            }, { quoted: receivedMsg });
            break;

          case "3":
            await conn.sendMessage(senderID, {
              audio: { url: video_sd },
              mimetype: "audio/mpeg"
            }, { quoted: receivedMsg });
            break;

          case "4":
            await conn.sendMessage(senderID, {
              document: { url: video_sd },
              mimetype: "audio/mpeg",
              fileName: "Twitter_Audio.mp3",
              caption: "ğŸ“¥ *Audio Downloaded as Document*"
            }, { quoted: receivedMsg });
            break;

          case "5":
            await conn.sendMessage(senderID, {
              audio: { url: video_sd },
              mimetype: "audio/mp4",
              ptt: true
            }, { quoted: receivedMsg });
            break;

          default:
            reply("âŒ Invalid option! Please reply with 1, 2, 3, 4, or 5.");
        }
      }
    });

  } catch (error) {
    console.error("Error:", error);
    reply("âŒ An error occurred while processing your request. Please try again.");
  }
});

// MediaFire-dl

cmd({
  pattern: "mediafire",
  alias: ["mfire"],
  desc: "To download MediaFire files.",
  react: "ğŸ¥",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q) {
      return reply("âŒ Please provide a valid MediaFire link.");
    }

    await conn.sendMessage(from, {
      react: { text: "â³", key: m.key }
    });

    const response = await axios.get(`https://www.dark-yasiya-api.site/download/mfire?url=${q}`);
    const data = response.data;

    if (!data || !data.status || !data.result || !data.result.dl_link) {
      return reply("âš ï¸ Failed to fetch MediaFire download link. Ensure the link is valid and public.");
    }

    const { dl_link, fileName, fileType } = data.result;
    const file_name = fileName || "mediafire_download";
    const mime_type = fileType || "application/octet-stream";

    await conn.sendMessage(from, {
      react: { text: "â¬†ï¸", key: m.key }
    });

    const caption = `â•­â”â”â”ã€” *MEDIAFIRE DOWNLOADER* ã€•â”â”â”âŠ·\n`
      + `â”ƒâ–¸ *File Name:* ${file_name}\n`
      + `â”ƒâ–¸ *File Type:* ${mime_type}\n`
      + `â•°â”â”â”âª¼\n\n`
      + `ğŸ“¥ *Downloading your file...*`;

    await conn.sendMessage(from, {
      document: { url: dl_link },
      mimetype: mime_type,
      fileName: file_name,
      caption: caption
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error);
    reply("âŒ An error occurred while processing your request. Please try again.");
  }
});

// apk-dl

cmd({
  pattern: "apk",
  desc: "Download APK from Aptoide.",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q) {
      return reply("âŒ Please provide an app name to search.");
    }

    await conn.sendMessage(from, { react: { text: "â³", key: m.key } });

    const apiUrl = `http://ws75.aptoide.com/api/7/apps/search/query=${q}/limit=1`;
    const response = await axios.get(apiUrl);
    const data = response.data;

    if (!data || !data.datalist || !data.datalist.list.length) {
      return reply("âš ï¸ No results found for the given app name.");
    }

    const app = data.datalist.list[0];
    const appSize = (app.size / 1048576).toFixed(2); // Convert bytes to MB

    const caption = `â•­â”â”â”ã€” *APK Downloader* ã€•â”â”â”â”ˆâŠ·
â”ƒ ğŸ“¦ *Name:* ${app.name}
â”ƒ ğŸ‹ *Size:* ${appSize} MB
â”ƒ ğŸ“¦ *Package:* ${app.package}
â”ƒ ğŸ“… *Updated On:* ${app.updated}
â”ƒ ğŸ‘¨â€ğŸ’» *Developer:* ${app.developer.name}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
ğŸ”— *Powered By Êœá´œÉ´á´›á´‡Ê€ xá´á´…*`;

    await conn.sendMessage(from, { react: { text: "â¬†ï¸", key: m.key } });

    await conn.sendMessage(from, {
      document: { url: app.file.path_alt },
      fileName: `${app.name}.apk`,
      mimetype: "application/vnd.android.package-archive",
      caption: caption
    }, { quoted: m });

    await conn.sendMessage(from, { react: { text: "âœ…", key: m.key } });

  } catch (error) {
    console.error("Error:", error);
    reply("âŒ An error occurred while fetching the APK. Please try again.");
  }
});

// G-Drive-DL

cmd({
  pattern: "gdrive",
  desc: "Download Google Drive files.",
  react: "ğŸŒ",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q) {
      return reply("âŒ Please provide a valid Google Drive link.");
    }

    await conn.sendMessage(from, { react: { text: "â¬‡ï¸", key: m.key } });

    const apiUrl = `https://api.fgmods.xyz/api/downloader/gdrive?url=${q}&apikey=mnp3grlZ`;
    const response = await axios.get(apiUrl);
    const downloadUrl = response.data.result.downloadUrl;

    if (downloadUrl) {
      await conn.sendMessage(from, { react: { text: "â¬†ï¸", key: m.key } });

      await conn.sendMessage(from, {
        document: { url: downloadUrl },
        mimetype: response.data.result.mimetype,
        fileName: response.data.result.fileName,
        caption: "*Â© Powered By Toxic lover-v2 xmd*"
      }, { quoted: m });

      await conn.sendMessage(from, { react: { text: "âœ…", key: m.key } });
    } else {
      return reply("âš ï¸ No download URL found. Please check the link and try again.");
    }
  } catch (error) {
    console.error("Error:", error);
    reply("âŒ An error occurred while fetching the Google Drive file. Please try again.");
  }
}); 

const { cmd } = require("../command");
const { fetchEmix } = require("../lib/emix-utils");
const { getBuffer } = require("../lib/functions");
const { Sticker, StickerTypes } = require("wa-sticker-formatter");

cmd({
    pattern: "emix",
    desc: "Combine two emojis into a sticker.",
    category: "fun",
    react: "ğŸ˜ƒ",
    use: ".emix ğŸ˜‚,ğŸ™‚",
    filename: __filename,
}, async (conn, mek, m, { args, q, reply }) => {
    try {
        if (!q.includes(",")) {
            return reply("âŒ *Usage:* .emix ğŸ˜‚,ğŸ™‚\n_Send two emojis separated by a comma._");
        }

        let [emoji1, emoji2] = q.split(",").map(e => e.trim());

        if (!emoji1 || !emoji2) {
            return reply("âŒ Please provide two emojis separated by a comma.");
        }

        let imageUrl = await fetchEmix(emoji1, emoji2);

        if (!imageUrl) {
            return reply("âŒ Could not generate emoji mix. Try different emojis.");
        }

        let buffer = await getBuffer(imageUrl);
        let sticker = new Sticker(buffer, {
            pack: "Emoji Mix",
            author: "sir bravin",
            type: StickerTypes.FULL,
            categories: ["ğŸ¤©", "ğŸ‰"],
            quality: 75,
            background: "transparent",
        });

        const stickerBuffer = await sticker.toBuffer();
        await conn.sendMessage(mek.chat, { sticker: stickerBuffer }, { quoted: mek });

    } catch (e) {
        console.error("Error in .emix command:", e.message);
        reply(`âŒ Could not generate emoji mix: ${e.message}`);
    }
});
          

const { cmd } = require('../command');

cmd({
    pattern: "happy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ˜‚",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ˜‚' });
        const emojiMessages = [
            "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜Š", "ğŸ˜", "ğŸ¥³",
            "ğŸ˜¸", "ğŸ˜¹", "ğŸŒ", "ğŸŒˆ", "ğŸ˜ƒ", "ğŸ˜„",
            "ğŸ˜", "ğŸ˜Š", "ğŸ˜", "ğŸ¥³", "ğŸ˜¸", "ğŸ˜¹",
            "ğŸŒ", "ğŸŒˆ", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜Š"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "heart",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "â¤ï¸",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ–¤' });
        const emojiMessages = [
            "ğŸ’–", "ğŸ’—", "ğŸ’•", "ğŸ©·", "ğŸ’›", "ğŸ’š",
            "ğŸ©µ", "ğŸ’™", "ğŸ’œ", "ğŸ–¤", "ğŸ©¶", "ğŸ¤",
            "ğŸ¤", "â¤ï¸â€ğŸ”¥", "ğŸ’", "ğŸ’“", "ğŸ’˜", "ğŸ’",
            "â™¥ï¸", "ğŸ’Ÿ", "â¤ï¸â€ğŸ©¹", "â¤ï¸"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "angry",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ¤¡",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ‘½' });
        const emojiMessages = [
            "ğŸ˜¡", "ğŸ˜ ", "ğŸ¤¬", "ğŸ˜¤", "ğŸ˜¾", "ğŸ˜¡",
            "ğŸ˜ ", "ğŸ¤¬", "ğŸ˜¤", "ğŸ˜¾"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "sad",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ˜¶",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ˜”' });
        const emojiMessages = [
            "ğŸ¥º", "ğŸ˜Ÿ", "ğŸ˜•", "ğŸ˜–", "ğŸ˜«", "ğŸ™",
            "ğŸ˜©", "ğŸ˜¥", "ğŸ˜“", "ğŸ˜ª", "ğŸ˜¢", "ğŸ˜”",
            "ğŸ˜", "ğŸ˜­", "ğŸ’”", "ğŸ˜­", "ğŸ˜¿"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "shy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ§",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ§' });
        const emojiMessages = [
            "ğŸ˜³", "ğŸ˜Š", "ğŸ˜¶", "ğŸ™ˆ", "ğŸ™Š",
            "ğŸ˜³", "ğŸ˜Š", "ğŸ˜¶", "ğŸ™ˆ", "ğŸ™Š"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "moon",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸŒš",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸŒ' });
        const emojiMessages = [
            "ğŸŒ—", "ğŸŒ˜", "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”",
            "ğŸŒ•", "ğŸŒ–", "ğŸŒ—", "ğŸŒ˜", "ğŸŒ‘", "ğŸŒ’",
            "ğŸŒ“", "ğŸŒ”", "ğŸŒ•", "ğŸŒ–", "ğŸŒ—", "ğŸŒ˜",
            "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”", "ğŸŒ•", "ğŸŒ–",
            "ğŸŒ—", "ğŸŒ˜", "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”",
            "ğŸŒ•", "ğŸŒ–", "ğŸŒğŸŒš"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "confused",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ¤”",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ¤”' });
        const emojiMessages = [
            "ğŸ˜•", "ğŸ˜Ÿ", "ğŸ˜µ", "ğŸ¤”", "ğŸ˜–", 
            "ğŸ˜²", "ğŸ˜¦", "ğŸ¤·", "ğŸ¤·â€â™‚ï¸", "ğŸ¤·â€â™€ï¸"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "hot",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ’‹",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ğŸ’‹' });
        const emojiMessages = [
            "ğŸ¥µ", "â¤ï¸", "ğŸ’‹", "ğŸ˜«", "ğŸ¤¤", 
            "ğŸ˜‹", "ğŸ¥µ", "ğŸ¥¶", "ğŸ™Š", "ğŸ˜»", 
            "ğŸ™ˆ", "ğŸ’‹", "ğŸ«‚", "ğŸ«€", "ğŸ‘…", 
            "ğŸ‘„", "ğŸ’‹"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`ğŸ’„ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "nikal",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ğŸ—¿",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'CRISS-AIğŸ—¿' });
        
        // Define the ASCII art messages
        const asciiMessages = [
            "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €     â¢³â¡€â €â¡â €â €â €   â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €  â €    â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Nikal   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €      â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €â €__â €   â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €  â €  â¢³â¡€â €â¡â €â €â €   â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €       â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Lavde   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €      â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €|__|â €â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €     â €   â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €â €      â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸   Pehli   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €     â£¿  â¢¹â €           â¡‡\n  â ™â¢¿â£¯â „â €â €(P)â €â €     â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €     â €   â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €   â €     â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Fursat  â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €        â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €â €__ â €  â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €      â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â € â €      â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Meeee   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €       â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €|__| â €    â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â â ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €   â €  â €â¢³â¡€â €â¡â €â €       â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €  â €       â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²   â£¿  â£¸   Nikal   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €       â£¿  â¢¹â €           â¡‡\n  â ™â¢¿â£¯â „â €â €loduâ €â €   â¡¿ â €â¡‡â €â €â €â €   â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €  â¡´â ƒâ €   â ˜â ¤â£„â£ â â €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €"
        ];

        // Send the initial loading message
        for (const asciiMessage of asciiMessages) {
            await new Promise(resolve => setTimeout(resolve, 500)); // Delay for 500ms second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: asciiMessage,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error!* ${e.message}`);
    }
});

// > Criss Vevo 

const config = require('../config');
const { cmd, commands } = require('../command');
const { runtime } = require('../lib/functions');
const axios = require('axios');

function isEnabled(value) {
    // Function to check if a value represents a "true" boolean state
    return value && value.toString().toLowerCase() === "true";
}

cmd({
    pattern: "env",
    alias: ["settings","setting", "allvar"],
    desc: "Settings of bot",
    category: "menu",
    react: "â¤µï¸",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, reply }) => {
    try {
        // Define the settings message with the correct boolean checks
        let envSettings = `â•­ã€” *ã€sir bravin ã€‘* ã€•âŠ·
â”ƒâ–¸â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ–¸â”ƒà¹ *sir bravin settingsğŸ‘»*
â”ƒâ–¸â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·Â·Â·à¹
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•­â”â”ã€” *Enabled Disabled* ã€•â”â”â”ˆâŠ·
â”‡à¹ *Auto Read Status:* ${isEnabled(config.AUTO_STATUS_SEEN) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Reply Status:* ${isEnabled(config.AUTO_STATUS_REPLY) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Reply:* ${isEnabled(config.AUTO_REPLY) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Sticker:* ${isEnabled(config.AUTO_STICKER) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Voice:* ${isEnabled(config.AUTO_VOICE) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Owner React:* ${isEnabled(config.OWNER_REACT) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Custom Reacts:* ${isEnabled(config.CUSTOM_REACT) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto React:* ${isEnabled(config.AUTO_REACT) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Delete Links:* ${isEnabled(config.DELETE_LINKS) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Anti-Link:* ${isEnabled(config.ANTI_LINK) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Anti-Bad Words:* ${isEnabled(config.ANTI_BAD) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Typing:* ${isEnabled(config.AUTO_TYPING) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Recording:* ${isEnabled(config.AUTO_RECORDING) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Always Online:* ${isEnabled(config.ALWAYS_ONLINE) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Public Mode:* ${isEnabled(config.PUBLIC_MODE) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Read Message:* ${isEnabled(config.READ_MESSAGE) ? "Enabled âœ…" : "Disabled âŒ"}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”€â”€â”ˆâŠ·
> ${config.DESCRIPTION}`;

        // Send message with an image
        await conn.sendMessage(
            from,
            {
                image: { url: 'https://files.catbox.moe/9bclq1.jpg' }, // Image URL
                caption: envSettings,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: "sir bravin on offğŸ¥°",
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

        // Send an audio file
        await conn.sendMessage(from, {
            audio: { url: 'https://files.catbox.moe/1qxxlv.mp3' }, // Audio URL
            mimetype: 'audio/mp4',
            ptt: true
        }, { quoted: mek });

    } catch (error) {
        console.log(error);
        reply(`Error: ${error.message}`);
    }
});

const config = require('../config');
const { cmd, commands } = require('../command');
const { runtime } = require('../lib/functions');
const axios = require('axios');

function isEnabled(value) {
    // Function to check if a value represents a "true" boolean state
    return value && value.toString().toLowerCase() === "true";
}

cmd({
    pattern: "env",
    alias: ["setting", "allvar"],
    desc: "Settings of bot",
    category: "menu",
    react: "â¤µï¸",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, reply }) => {
    try {
        // Define the settings message with the correct boolean checks
        let envSettings = `â•­â”â”â”ã€” *TOXIC LOVER-V2 XMD* ã€•â”â”â”â”ˆâŠ·
â”ƒâ–¸â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ–¸â”ƒà¹ *ENV SETTINGS ğŸ—¿*
â”ƒâ–¸â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·Â·Â·à¹
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•­â”â”ã€” *Enabled Disabled* ã€•â”â”â”ˆâŠ·
â”‡à¹ *Status View:* ${isEnabled(config.AUTO_STATUS_SEEN) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Status Reply:* ${isEnabled(config.AUTO_STATUS_REPLY) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Reply:* ${isEnabled(config.AUTO_REPLY) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Sticker:* ${isEnabled(config.AUTO_STICKER) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Voice:* ${isEnabled(config.AUTO_VOICE) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Custom Reacts:* ${isEnabled(config.CUSTOM_REACT) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto React:* ${isEnabled(config.AUTO_REACT) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Delete Links:* ${isEnabled(config.DELETE_LINKS) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Anti-Link:* ${isEnabled(config.ANTI_LINK) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Anti-Bad Words:* ${isEnabled(config.ANTI_BAD) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Typing:* ${isEnabled(config.AUTO_TYPING) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Auto Recording:* ${isEnabled(config.AUTO_RECORDING) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Always Online:* ${isEnabled(config.ALWAYS_ONLINE) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Public Mode:* ${isEnabled(config.PUBLIC_MODE) ? "Enabled âœ…" : "Disabled âŒ"}
â”‡à¹ *Read Message:* ${isEnabled(config.READ_MESSAGE) ? "Enabled âœ…" : "Disabled âŒ"}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”€â”€â”ˆâŠ·
> ${config.DESCRIPTION}`;

        // Send message with an image
        await conn.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/4ggu0a.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir bravin',
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

        // Send an audio file
        await conn.sendMessage(from, {
            audio: { url: 'https://github.com/criss-vevo/CRISS-DATA/raw/refs/heads/main/autovoice/menunew.m4a' }, // Audio URL
            mimetype: 'audio/mp4',
            ptt: true
        }, { quoted: mek });

    } catch (error) {
        console.log(error);
        reply(`Error: ${error.message}`);
    }
});

const { cmd } = require("../command");
const config = require('../config');

cmd({
  pattern: "compatibility",
  alias: ["friend", "fcheck"],
  desc: "Calculate the compatibility score between two users.",
  category: "fun",
  react: "ğŸ’–",
  filename: __filename,
  use: "@tag1 @tag2",
}, async (conn, mek, m, { args, reply }) => {
  try {
    if (args.length < 2) {
      return reply("Please mention two users to calculate compatibility.\nUsage: `.compatibility @user1 @user2`");
    }

    let user1 = m.mentionedJid[0]; 
    let user2 = m.mentionedJid[1]; 

    const specialNumber = config.DEV ? `${config.DEV}@s.whatsapp.net` : null;

    // Calculate a random compatibility score (between 1 to 1000)
    let compatibilityScore = Math.floor(Math.random() * 1000) + 1;

    // Check if one of the mentioned users is the special number
    if (user1 === specialNumber || user2 === specialNumber) {
      compatibilityScore = 1000; // Special case for DEV number
      return reply(`ğŸ’– Compatibility between @${user1.split('@')[0]} and @${user2.split('@')[0]}: ${compatibilityScore}+/1000 ğŸ’–`);
    }

    // Send the compatibility message
    await conn.sendMessage(mek.chat, {
      text: `ğŸ’– Compatibility between @${user1.split('@')[0]} and @${user2.split('@')[0]}: ${compatibilityScore}/1000 ğŸ’–`,
      mentions: [user1, user2],
    }, { quoted: mek });

  } catch (error) {
    console.log(error);
    reply(`âŒ Error: ${error.message}`);
  }
});

  cmd({
  pattern: "aura",
  desc: "Calculate aura score of a user.",
  category: "fun",
  react: "ğŸ’€",
  filename: __filename,
  use: "@tag",
}, async (conn, mek, m, { args, reply }) => {
  try {
    if (args.length < 1) {
      return reply("Please mention a user to calculate their aura.\nUsage: `.aura @user`");
    }

    let user = m.mentionedJid[0]; 
    const specialNumber = config.DEV ? `${config.DEV}@s.whatsapp.net` : null;

    // Calculate a random aura score (between 1 to 1000)
    let auraScore = Math.floor(Math.random() * 1000) + 1;

    // Check if the mentioned user is the special number
    if (user === specialNumber) {
      auraScore = 999999; // Special case for DEV number
      return reply(`ğŸ’€ Aura of @${user.split('@')[0]}: ${auraScore}+ ğŸ—¿`);
    }

    // Send the aura message
    await conn.sendMessage(mek.chat, {
      text: `ğŸ’€ Aura of @${user.split('@')[0]}: ${auraScore}/1000 ğŸ—¿`,
      mentions: [user],
    }, { quoted: mek });

  } catch (error) {
    console.log(error);
    reply(`âŒ Error: ${error.message}`);
  }
});

cmd({
    pattern: "roast",
    desc: "Roast someone in Hindi",
    category: "fun",
    react: "ğŸ”¥",
    filename: __filename,
    use: "@tag"
}, async (conn, mek, m, { q, reply }) => {
    let roasts = [
        "Abe bhai, tera IQ wifi signal se bhi kam hai!",
        "Bhai, teri soch WhatsApp status jaisi hai, 24 ghante baad gayab ho jaati hai!",
        "Abe sochta kitna hai, tu kya NASA ka scientist hai?",
        "Abe tu hai kaun? Google pe search karne se bhi tera naam nahi aata!",
        "Tera dimaag 2G network pe chal raha hai kya?",
        "Itna overthink mat kar bhai, teri battery jaldi down ho jayegi!",
        "Teri soch cricket ke match jaisi hai, baarish aate hi band ho jati hai!",
        "Tu VIP hai, 'Very Idiotic Person'!",
    "Abe bhai, tera IQ wifi signal se bhi kam hai!",
    "Bhai, teri soch WhatsApp status jaisi hai, 24 ghante baad gayab ho jaati hai!",
    "Abe tu kis planet se aaya hai, yeh duniya tere jaise aliens ke liye nahi hai!",
    "Tere dimag mein khojne ka itna kuch hai, lekin koi result nahi milta!",
    "Teri zindagi WhatsApp status jaisi hai, kabhi bhi delete ho sakti hai!",
    "Tera style bilkul WiFi password ki tarah hai, sabko pata nahi!",
    "Abe tu toh wahi hai jo apni zindagi ka plot twist bhi Google karta hai!",
    "Abe tu toh software update bhi nahi chalne wala, pura hang hai!",
    "Tere sochne se zyada toh Google search karne mein time waste ho jaata hai!",
    "Mere paas koi shabdon ki kami nahi hai, bas tujhe roast karne ka mood nahi tha!",
    "Teri personality toh dead battery jaisi hai, recharge karne ka time aa gaya hai!",
    "Bhai, teri soch ke liye ek dedicated server hona chahiye!",
    "Abe tu kaunsa game khel raha hai, jisme har baar fail ho jaata hai?",
    "Tere jokes bhi software update ki tarah hote hain, baar-baar lagte hain par kaam nahi karte!",
    "Teri wajah se toh mere phone ka storage bhi full ho jaata hai!",
    "Abe bhai, tu na ek walking meme ban gaya hai!",
    "Abe apne aap ko bada smart samajhta hai, par teri brain cells toh overload mein hain!",
    "Teri wajah se toh humari group chat ko mute karne ka sochna padta hai!",
    "Abe tere jaise log hamesha apne aap ko hero samajhte hain, par actually toh tum villain ho!",
    "Tere jaise logon ke liye zindagi mein rewind aur fast forward button hona chahiye!",
    "Tere mooh se nikla har lafz ek naya bug hai!",
    "Abe tu apni zindagi ke saath save nahi kar paaya, aur dusron ke liye advice de raha hai!",
    "Tu apne life ka sabse bada virus hai!",
    "Abe tu hain ya koi broken app?",
    "Tere soch ke liye CPU ki zarurat hai, par lagta hai tera CPU khatam ho gaya!",
    "Abe tu kya kar raha hai, ek walking error message ban gaya hai!",
    "Teri taareef toh bas lagti hai, par teri asli aukaat toh sabko pata hai!",
    "Tera brain toh ek broken link ki tarah hai, sab kuch dhundne ke bawajood kuch nahi milta!",
    "Bhai, tujhe dekh ke toh lagta hai, Netflix bhi teri wajah se crash ho gaya!",
    "Teri tasveer toh bas ek screenshot lagti hai, real life mein tu kuch bhi nahi!",
    "Abe bhai, tu lagta hai toh I-phone ho, lekin andar kaafi purana android hai!",
    "Abe, tere jaisi soch se toh Google bhi nafrat karta hoga!",
    "Bhai tu apne chehre se ghazab ka mood bana le, shayad koi notice kar le!",
    "Tere kaam bhi uss app ki tarah hote hain jo crash ho jata hai jab sabko zarurat ho!",
    "Teri zindagi ke sabse bada hack toh hai - 'Log mujhse kuch bhi expect mat karo'!",
    "Abe tu apne aap ko hi mirror mein dekh ke samajhta hai ki sab kuch sahi hai!",
    "Abe tu apne dimaag ko low power mode mein daalke chalta hai!",
    "Tere paas ideas hain, par sab outdated hain jaise Windows XP!",
    "Teri soch toh ek system error ki tarah hai, restart karna padega!",
    "Teri personality toh ek empty hard drive jaise hai, kuch bhi valuable nahi!", 
    "Abe tu kis planet se aaya hai, yeh duniya tere jaise logon ke liye nahi hai!",
    "Tere chehre pe kisi ne 'loading' likh diya hai, par kabhi bhi complete nahi hota!",
    "Tera dimaag toh ek broken link ki tarah hai, kabhi bhi connect nahi hota!",
    "Abe, teri soch se toh Google ka algorithm bhi confused ho jata hai!",
    "Tere jaisa banda, aur aise ideas? Yeh toh humne science fiction mein dekha tha!",
    "Abe tu apne chehre pe 'not found' likhwa le, kyunki sabko kuch milta nahi!",
    "Teri soch itni slow hai, Google bhi teri madad nahi kar paata!",
    "Abe tu toh '404 not found' ka living example hai!",
    "Tera dimaag bhi phone ki battery jaise hai, kabhi bhi drain ho jaata hai!",
    "Abe tu toh wahi hai, jo apni zindagi ka password bhool jaata hai!",
    "Abe tu jise apni soch samajhta hai, wo ek 'buffering' hai!",
    "Teri life ke decisions itne confusing hain, ki KBC ke host bhi haraan ho jaaye!",
    "Bhai, tere jaise logo ke liye ek dedicated 'error' page hona chahiye!",
    "Teri zindagi ko 'user not found' ka message mil gaya hai!",
    "Teri baatein utni hi value rakhti hain, jitni 90s ke mobile phones mein camera quality thi!",
    "Abe bhai, tu toh har waqt 'under construction' rehta hai!",
    "Tere saath toh life ka 'unknown error' hota hai, koi solution nahi milta!",
    "Bhai, tere chehre pe ek warning sign hona chahiye - 'Caution: Too much stupidity ahead'!",
    "Teri har baat pe lagta hai, system crash hone waala hai!",
    "Tere paas idea hai, par wo abhi bhi 'under review' hai!"
];               
        
    let randomRoast = roasts[Math.floor(Math.random() * roasts.length)];
    let sender = `@${mek.sender.split("@")[0]}`;
    let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);

    if (!mentionedUser) {
        return reply("Usage: .roast @user (Tag someone to roast them!)");
    }

    let target = `@${mentionedUser.split("@")[0]}`;
    
    // Sending the roast message with the mentioned user
    let message = `${target} :\n *${randomRoast}*\n> This is all for fun, don't take it seriously!`;
    await conn.sendMessage(mek.chat, { text: message, mentions: [mek.sender, mentionedUser] }, { quoted: mek });
});

cmd({
    pattern: "8ball",
    desc: "Magic 8-Ball gives answers",
    category: "fun",
    react: "ğŸ±",
    filename: __filename
}, 
async (conn, mek, m, { from, q, reply }) => {
    if (!q) return reply("Ask a yes/no question! Example: .8ball Will I be rich?");
    
    let responses = [
        "Yes!", "No.", "Maybe...", "Definitely!", "Not sure.", 
        "Ask again later.", "I don't think so.", "Absolutely!", 
        "No way!", "Looks promising!"
    ];
    
    let answer = responses[Math.floor(Math.random() * responses.length)];
    
    reply(`ğŸ± *Magic 8-Ball says:* ${answer}`);
});

cmd({
    pattern: "compliment",
    desc: "Give a nice compliment",
    category: "fun",
    react: "ğŸ˜Š",
    filename: __filename,
    use: "@tag (optional)"
}, async (conn, mek, m, { reply }) => {
    let compliments = [
        "You're amazing just the way you are! ğŸ’–",
        "You light up every room you walk into! ğŸŒŸ",
        "Your smile is contagious! ğŸ˜Š",
        "You're a genius in your own way! ğŸ§ ",
        "You bring happiness to everyone around you! ğŸ¥°",
        "You're like a human sunshine! â˜€ï¸",
        "Your kindness makes the world a better place! â¤ï¸",
        "You're unique and irreplaceable! âœ¨",
        "You're a great listener and a wonderful friend! ğŸ¤—",
        "Your positive vibes are truly inspiring! ğŸ’«",
        "You're stronger than you think! ğŸ’ª",
        "Your creativity is beyond amazing! ğŸ¨",
        "You make life more fun and interesting! ğŸ‰",
        "Your energy is uplifting to everyone around you! ğŸ”¥",
        "You're a true leader, even if you donâ€™t realize it! ğŸ†",
        "Your words have the power to make people smile! ğŸ˜Š",
        "You're so talented, and the world needs your skills! ğŸ­",
        "You're a walking masterpiece of awesomeness! ğŸ¨",
        "You're proof that kindness still exists in the world! ğŸ’•",
        "You make even the hardest days feel a little brighter! â˜€ï¸"
    ];

    let randomCompliment = compliments[Math.floor(Math.random() * compliments.length)];
    let sender = `@${mek.sender.split("@")[0]}`;
    let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
    let target = mentionedUser ? `@${mentionedUser.split("@")[0]}` : "";

    let message = mentionedUser 
        ? `${sender} complimented ${target}:\nğŸ˜Š *${randomCompliment}*`
        : `${sender}, you forgot to tag someone! But hey, here's a compliment for you:\nğŸ˜Š *${randomCompliment}*`;

    await conn.sendMessage(mek.chat, { text: message, mentions: [mek.sender, mentionedUser].filter(Boolean) }, { quoted: mek });
});

cmd({
    pattern: "lovetest",
    desc: "Check love compatibility between two users",
    category: "fun",
    react: "â¤ï¸",
    filename: __filename,
    use: "@tag1 @tag2"
}, async (conn, mek, m, { args, reply }) => {
    if (args.length < 2) return reply("Tag two users! Example: .lovetest @user1 @user2");

    let user1 = args[0].replace("@", "") + "@s.whatsapp.net";
    let user2 = args[1].replace("@", "") + "@s.whatsapp.net";

    let lovePercent = Math.floor(Math.random() * 100) + 1; // Generates a number between 1-100

    let messages = [
        { range: [90, 100], text: "ğŸ’– *A match made in heaven!* True love exists!" },
        { range: [75, 89], text: "ğŸ˜ *Strong connection!* This love is deep and meaningful." },
        { range: [50, 74], text: "ğŸ˜Š *Good compatibility!* You both can make it work." },
        { range: [30, 49], text: "ğŸ¤” *Itâ€™s complicated!* Needs effort, but possible!" },
        { range: [10, 29], text: "ğŸ˜… *Not the best match!* Maybe try being just friends?" },
        { range: [1, 9], text: "ğŸ’” *Uh-oh!* This love is as real as a Bollywood breakup!" }
    ];

    let loveMessage = messages.find(msg => lovePercent >= msg.range[0] && lovePercent <= msg.range[1]).text;

    let message = `ğŸ’˜ *Love Compatibility Test* ğŸ’˜\n\nâ¤ï¸ *@${user1.split("@")[0]}* + *@${user2.split("@")[0]}* = *${lovePercent}%*\n${loveMessage}`;

    await conn.sendMessage(mek.chat, { text: message, mentions: [user1, user2] }, { quoted: mek });
}); 

cmd(
    {
        pattern: "emoji",
        desc: "Convert text into emoji form.",
        category: "fun",
        react: "ğŸ˜†",
        filename: __filename,
        use: "<text>"
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            // Join the words together in case the user enters multiple words
            let text = args.join(" ");
            
            // Map text to corresponding emoji characters
            let emojiMapping = {
                "a": "ğŸ…°ï¸",
                "b": "ğŸ…±ï¸",
                "c": "ğŸ‡¨ï¸",
                "d": "ğŸ‡©ï¸",
                "e": "ğŸ‡ªï¸",
                "f": "ğŸ‡«ï¸",
                "g": "ğŸ‡¬ï¸",
                "h": "ğŸ‡­ï¸",
                "i": "ğŸ‡®ï¸",
                "j": "ğŸ‡¯ï¸",
                "k": "ğŸ‡°ï¸",
                "l": "ğŸ‡±ï¸",
                "m": "ğŸ‡²ï¸",
                "n": "ğŸ‡³ï¸",
                "o": "ğŸ…¾ï¸",
                "p": "ğŸ‡µï¸",
                "q": "ğŸ‡¶ï¸",
                "r": "ğŸ‡·ï¸",
                "s": "ğŸ‡¸ï¸",
                "t": "ğŸ‡¹ï¸",
                "u": "ğŸ‡ºï¸",
                "v": "ğŸ‡»ï¸",
                "w": "ğŸ‡¼ï¸",
                "x": "ğŸ‡½ï¸",
                "y": "ğŸ‡¾ï¸",
                "z": "ğŸ‡¿ï¸",
                "0": "0ï¸âƒ£",
                "1": "1ï¸âƒ£",
                "2": "2ï¸âƒ£",
                "3": "3ï¸âƒ£",
                "4": "4ï¸âƒ£",
                "5": "5ï¸âƒ£",
                "6": "6ï¸âƒ£",
                "7": "7ï¸âƒ£",
                "8": "8ï¸âƒ£",
                "9": "9ï¸âƒ£",
                " ": "â£", // for space
            };

            // Convert the input text into emoji form
            let emojiText = text.toLowerCase().split("").map(char => emojiMapping[char] || char).join("");

            // If no valid text is provided
            if (!text) {
                return reply("Please provide some text to convert into emojis!");
            }

            await conn.sendMessage(mek.chat, {
                text: emojiText,
            }, { quoted: mek });

        } catch (error) {
            console.log(error);
            reply(`Error: ${error.message}`);
        }
    }
);

const axios = require("axios");
const { cmd } = require("../command");

cmd({
  pattern: "fancy",
  alias: ["font", "style"],
  react: "ğŸ’°",
  desc: "Convert text into various fonts.",
  category: "tools",
  filename: __filename
}, async (conn, m, store, { from, quoted, args, q, reply }) => {
  try {
    if (!q) {
      return reply("â Please provide text to convert into fancy fonts.\n\n*Example:* .fancy Hello");
    }

    const apiUrl = `https://www.dark-yasiya-api.site/other/font?text=${encodeURIComponent(q)}`;
    const response = await axios.get(apiUrl);
    
    if (!response.data.status) {
      return reply("âŒ Error fetching fonts. Please try again later.");
    }

    const fonts = response.data.result.map(item => `*${item.name}:*\n${item.result}`).join("\n\n");
    const resultText = `âœ¨ *Fancy Fonts Converter* âœ¨\n\n${fonts}\n\n> *Powered by sir bravin*`;

    await conn.sendMessage(from, { text: resultText }, { quoted: m });
  } catch (error) {
    console.error("âŒ Error in fancy command:", error);
    reply("âš ï¸ An error occurred while fetching fonts.");
  }
});

const axios = require("axios");
const { cmd } = require("../command");
const { fetchGif, gifToVideo } = require("../lib/fetchGif");

cmd({
  pattern: "marige",
  alias: ["shadi", "marriage", "wedding"],
  desc: "Randomly pairs two users for marriage with a wedding GIF",
  react: "ğŸŸï¸",
  category: "fun",
  filename: __filename
}, async (conn, mek, store, { isGroup, groupMetadata, reply, sender }) => {
  try {
    if (!isGroup) return reply("âŒ This command can only be used in groups!");

    const participants = groupMetadata.participants.map(user => user.id);
    
    // Filter out the sender and bot number if needed
    const eligibleParticipants = participants.filter(id => id !== sender && !id.includes(conn.user.id.split('@')[0]));
    
    if (eligibleParticipants.length < 1) {
      return reply("âŒ Not enough participants to perform a marriage!");
    }

    // Select random pair
    const randomIndex = Math.floor(Math.random() * eligibleParticipants.length);
    const randomPair = eligibleParticipants[randomIndex];

    // Fetch wedding GIF
    const apiUrl = "https://api.waifu.pics/sfw/hug"; // Using kiss as wedding GIF
    let res = await axios.get(apiUrl);
    let gifUrl = res.data.url;

    let gifBuffer = await fetchGif(gifUrl);
    let videoBuffer = await gifToVideo(gifBuffer);

    const message = `ğŸ’ *Shadi Mubarak!* ğŸ’’\n\nğŸ‘° @${sender.split("@")[0]} + ğŸ¤µ @${randomPair.split("@")[0]}\n\nMay you both live happily ever after! ğŸ’–`;

    await conn.sendMessage(
      mek.chat,
      { 
        video: videoBuffer, 
        caption: message, 
        gifPlayback: true, 
        mentions: [sender, randomPair] 
      },
      { quoted: mek }
    );

  } catch (error) {
    console.error("âŒ Error in .marige command:", error);
    reply(`âŒ *Error in .marige command:*\n\`\`\`${error.message}\`\`\``);
  }
});

const { cmd } = require("../command");

// Command for random boy selection
cmd({
  pattern: "bacha",
  alias: ["boy", "larka"],
  desc: "Randomly selects a boy from the group",
  react: "ğŸ‘¶",
  category: "fun",
  filename: __filename
}, async (conn, mek, store, { isGroup, groupMetadata, reply, sender }) => {
  try {
    if (!isGroup) return reply("âŒ This command can only be used in groups!");

    const participants = groupMetadata.participants;
    
    // Filter out bot and get random participant
    const eligible = participants.filter(p => !p.id.includes(conn.user.id.split('@')[0]));
    
    if (eligible.length < 1) return reply("âŒ No eligible participants found!");

    const randomUser = eligible[Math.floor(Math.random() * eligible.length)];
    
    await conn.sendMessage(
      mek.chat,
      { 
        text: `ğŸ‘¦ *Yeh lo tumhara Bacha!* \n\n@${randomUser.id.split('@')[0]} is your handsome boy! ğŸ˜`, 
        mentions: [randomUser.id] 
      },
      { quoted: mek }
    );

  } catch (error) {
    console.error("Error in .bacha command:", error);
    reply(`âŒ Error: ${error.message}`);
  }
});

// Command for random girl selection
cmd({
  pattern: "bachi",
  alias: ["girl", "kuri", "larki"],
  desc: "Randomly selects a girl from the group",
  react: "ğŸ‘§",
  category: "fun",
  filename: __filename
}, async (conn, mek, store, { isGroup, groupMetadata, reply, sender }) => {
  try {
    if (!isGroup) return reply("âŒ This command can only be used in groups!");

    const participants = groupMetadata.participants;
    
    // Filter out bot and get random participant
    const eligible = participants.filter(p => !p.id.includes(conn.user.id.split('@')[0]));
    
    if (eligible.length < 1) return reply("âŒ No eligible participants found!");

    const randomUser = eligible[Math.floor(Math.random() * eligible.length)];
    
    await conn.sendMessage(
      mek.chat,
      { 
        text: `ğŸ‘§ *Yeh lo tumhari Bachi!* \n\n@${randomUser.id.split('@')[0]} is your beautiful girl! ğŸ’–`, 
        mentions: [randomUser.id] 
      },
      { quoted: mek }
    );

  } catch (error) {
    console.error("Error in .bachi command:", error);
    reply(`âŒ Error: ${error.message}`);
  }
});

const axios = require("axios");
const fetch = require("node-fetch");
const { sleep } = require('../lib/functions');
const { cmd, commands } = require("../command");
const config = require("../config");

cmd({
  pattern: "ship",
  alias: ["match", "love"],
  desc: "Randomly pairs the command user with another group member.",
  react: "â¤ï¸",
  category: "fun",
  filename: __filename
}, async (conn, m, store, { from, isGroup, groupMetadata, reply, sender }) => {
  try {
    if (!isGroup) return reply("âŒ This command can only be used in groups.");

    const specialNumber = config.DEV ? `${config.DEV}@s.whatsapp.net` : null; // Convert to WhatsApp format
    const participants = groupMetadata.participants.map(user => user.id);
    
    let randomPair;

    if (specialNumber && participants.includes(specialNumber) && sender !== specialNumber) {
      randomPair = specialNumber; // Always pair with this number if available
    } else {
      // Pair randomly but ensure user is not paired with themselves
      do {
        randomPair = participants[Math.floor(Math.random() * participants.length)];
      } while (randomPair === sender);
    }

    const message = `ğŸ’˜ *Match Found!* ğŸ’˜\nâ¤ï¸ @${sender.split("@")[0]} + @${randomPair.split("@")[0]}\nğŸ’– Congratulations! ğŸ‰`;

    await conn.sendMessage(from, {
      text: message,
      contextInfo: {
        mentionedJid: [sender, randomPair],
        forwardingScore: 999,
        isForwarded: true,
        forwardedNewsletterMessageInfo: {
          newsletterJid: "120363366284524544@newsletter",
          newsletterName: "sir bravin",
          serverMessageId: 143
        }
      }
    });

  } catch (error) {
    console.error("âŒ Error in ship command:", error);
    reply("âš ï¸ An error occurred while processing the command. Please try again.");
  }
});

const crypto = require("crypto");
const { cmd } = require("../command");

cmd({
  pattern: "gpass",
  desc: "Generate a strong password.",
  category: "other",
  react: 'ğŸ”',
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  body,
  isCmd,
  command,
  args,
  q,
  isGroup,
  sender,
  senderNumber,
  botNumber2,
  botNumber,
  pushname,
  isMe,
  isOwner,
  groupMetadata,
  groupName,
  participants,
  groupAdmins,
  isBotAdmins,
  isAdmins,
  reply
}) => {
  try {
    // Password length specified by the user, defaults to 12 if not provided
    const passwordLength = args[0] ? parseInt(args[0]) : 12;

    // Validate the password length
    if (isNaN(passwordLength) || passwordLength < 8) {
      return reply("âŒ Please provide a valid length for the password (Minimum 8 Characters).");
    }

    // Password generation function
    const generatePassword = (length) => {
      const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+[]{}|;:,.<>?';
      let password = '';
      for (let i = 0; i < length; i++) {
        const randomIndex = crypto.randomInt(0, chars.length);
        password += chars[randomIndex];
      }
      return password;
    };

    // Generate the password
    const generatedPassword = generatePassword(passwordLength);

    // Send the message with the generated password
    await conn.sendMessage(from, {
      text: "ğŸ” *Your Strong Password* ğŸ”\n\nPlease find your generated password below:\n\n" + generatedPassword + "\n\n*Powered By sir bravin*"
    }, {
      quoted: quoted
    });
    
  } catch (error) {
    console.error(error);
    reply("âŒ Error generating password: " + error.message);
  }
});

const { cmd, commands } = require('../command');
const fs = require('fs');
const path = require('path');

cmd({
    pattern: "get",
    alias: ["source", "js"],
    desc: "Fetch the full source code of a command",
    category: "owner",
    react: "ğŸ“œ",
    filename: __filename
},
async (conn, mek, m, { from, args, reply, isOwner }) => {
    try {
        if (!isOwner) return reply("âŒ You don't have permission to use this command!");
        if (!args[0]) return reply("âŒ Please provide a command name. Example: `.get alive`");

        const commandName = args[0].toLowerCase();
        const commandData = commands.find(cmd => cmd.pattern === commandName || (cmd.alias && cmd.alias.includes(commandName)));

        if (!commandData) return reply("âŒ Command not found!");

        // Get the command file path
        const commandPath = commandData.filename;

        // Read the full source code
        const fullCode = fs.readFileSync(commandPath, 'utf-8');

        // Truncate long messages for WhatsApp
        let truncatedCode = fullCode;
        if (truncatedCode.length > 4000) {
            truncatedCode = fullCode.substring(0, 4000) + "\n\n// Code too long, sending full file ğŸ“‚";
        }

        // Formatted caption with truncated code
        const formattedCode = `â¬¤â”€â”€â”€ã€” *ğŸ“œ Command Source* ã€•â”€â”€â”€â¬¤
\`\`\`js
${truncatedCode}
\`\`\`
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âŠ·  
âš¡ Full file sent below ğŸ“‚  
Powered By *Êœá´œÉ´á´›á´‡Ê€ xá´á´…* ğŸ’œ`;

        // Send image with truncated source code
        await conn.sendMessage(from, { 
            image: { url: `https://files.catbox.moe/m2s3cg.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir bravin',
                        serverMessageId: 143
                }
            }
        }, { quoted: mek });

        // Send full source file
        const fileName = `${commandName}.js`;
        const tempPath = path.join(__dirname, fileName);
        fs.writeFileSync(tempPath, fullCode);

        await conn.sendMessage(from, { 
            document: fs.readFileSync(tempPath),
            mimetype: 'text/javascript',
            fileName: fileName
        }, { quoted: mek });

        // Delete the temporary file
        fs.unlinkSync(tempPath);

    } catch (e) {
        console.error("Error in .get command:", e);
        reply(`âŒ Error: ${e.message}`);
    }
});

const { cmd } = require('../command');

cmd({
    pattern: "jid",
    alias: ["id", "chatid", "gjid"],  
    desc: "Get full JID of current chat/user (Creator Only)",
    react: "âš½",
    category: "utility",
    filename: __filename,
}, async (conn, mek, m, { 
    from, isGroup, isCreator, reply, sender 
}) => {
    try {
        if (!isCreator) {
            return reply("âŒ *Command Restricted* - Only my creator can use this.");
        }

        if (isGroup) {
            // Ensure group JID ends with @g.us
            const groupJID = from.includes('@g.us') ? from : `${from}@g.us`;
            return reply(`ğŸ‘¥ *Group JID:*\n\`\`\`${groupJID}\`\`\``);
        } else {
            // Ensure user JID ends with @s.whatsapp.net
            const userJID = sender.includes('@s.whatsapp.net') ? sender : `${sender}@s.whatsapp.net`;
            return reply(`ğŸ‘¤ *User JID:*\n\`\`\`${userJID}\`\`\``);
        }

    } catch (e) {
        console.error("JID Error:", e);
        reply(`âš ï¸ Error fetching JID:\n${e.message}`);
    }
});

const { cmd, commands } = require('../command');
const axios = require('axios');

cmd({
    pattern: "pair",
    alias: ["getpair", "clonebot"],
    react: "âœ…",
    desc: "Get pairing code for toxic lover+v2 xmd bot",
    category: "download",
    use: ".pair 25471726XXX",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        // Extract phone number from command
        const phoneNumber = q ? q.trim() : senderNumber;
        
        // Validate phone number format
        if (!phoneNumber || !phoneNumber.match(/^\+?\d{10,15}$/)) {
            return await reply("âŒ Please provide a valid phone number with country code\nExample: .pair +254717263XXX");
        }

        // Make API request to get pairing code
        const response = await axios.get(`https://sir-bravines.onrender.com?phone=${encodeURIComponent(phoneNumber)}`);
        
        if (!response.data || !response.data.code) {
            return await reply("âŒ Failed to retrieve pairing code. Please try again later.");
        }

        const pairingCode = response.data.code;
        const doneMessage = "> *Toxic lover-v2 xmd PAIRING COMPLETED*";

        // Send initial message with formatting
        await reply(`${doneMessage}\n\n*Your pairing code is:* ${pairingCode}`);

        // Add 2 second delay
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Send clean code message
        await reply(`${pairingCode}`);

    } catch (error) {
        console.error("Pair command error:", error);
        await reply("âŒ An error occurred while getting pairing code. Please try again later.");
    }
});


cmd({
    pattern: "pair2",
    alias: ["getpair2", "clonebot2"],
    react: "âœ…",
    desc: "Get pairing code for toxic lover bot",
    category: "download",
    use: ".pair 254717263XXX",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        // Extract phone number from command
        const phoneNumber = q ? q.trim() : senderNumber;
        
        // Validate phone number format
        if (!phoneNumber || !phoneNumber.match(/^\+?\d{10,15}$/)) {
            return await reply("âŒ Please provide a valid phone number with country code\nExample: .pair 254717263XXX");
        }

        // Make API request to get pairing code
        const response = await axios.get(`https://sir-bravins-pair-toxic.onrender.com?phone=${encodeURIComponent(phoneNumber)}`);
        
        if (!response.data || !response.data.code) {
            return await reply("âŒ Failed to retrieve pairing code. Please try again later.");
        }

        const pairingCode = response.data.code;
        const doneMessage = "> *toxic lover-v2 xmd PAIRING COMPLETED*";

        // Send initial message with formatting
        await reply(`${doneMessage}\n\n*Your pairing code is:* ${pairingCode}`);

        // Add 2 second delay
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Send clean code message
        await reply(`${pairingCode}`);

    } catch (error) {
        console.error("Pair command error:", error);
        await reply("âŒ An error occurred while getting pairing code. Please try again later.");
    }
});

const { cmd } = require("../command");
const fetch = require("node-fetch");

cmd({
  pattern: 'gitclone',
  alias: ["git"],
  desc: "Download GitHub repository as a zip file.",
  react: 'ğŸ“¦',
  category: "downloader",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  args,
  reply
}) => {
  if (!args[0]) {
    return reply("âŒ Where is the GitHub link?\n\nExample:\n.gitclone https://github.com/username/repository");
  }

  if (!/^(https:\/\/)?github\.com\/.+/.test(args[0])) {
    return reply("âš ï¸ Invalid GitHub link. Please provide a valid GitHub repository URL.");
  }

  try {
    const regex = /github\.com\/([^\/]+)\/([^\/]+)(?:\.git)?/i;
    const match = args[0].match(regex);

    if (!match) {
      throw new Error("Invalid GitHub URL.");
    }

    const [, username, repo] = match;
    const zipUrl = `https://api.github.com/repos/${username}/${repo}/zipball`;

    // Check if repository exists
    const response = await fetch(zipUrl, { method: "HEAD" });
    if (!response.ok) {
      throw new Error("Repository not found.");
    }

    const contentDisposition = response.headers.get("content-disposition");
    const fileName = contentDisposition ? contentDisposition.match(/filename=(.*)/)[1] : `${repo}.zip`;

    // Notify user of the download
    reply(`ğŸ“¥ *Downloading repository...*\n\n*Repository:* ${username}/${repo}\n*Filename:* ${fileName}\n\n> *Powered by toxic lover-v2 xmd*`);

    // Send the zip file to the user with custom contextInfo
    await conn.sendMessage(from, {
      document: { url: zipUrl },
      fileName: fileName,
      mimetype: 'application/zip',
      contextInfo: {
        mentionedJid: [m.sender],
        forwardingScore: 999,
        isForwarded: true,
        forwardedNewsletterMessageInfo: {
          newsletterJid: '120363366284524544@newsletter',
          newsletterName: 'sir bravin',
          serverMessageId: 143
        }
      }
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error);
    reply("âŒ Failed to download the repository. Please try again later.");
  }
});

const axios = require('axios');
const config = require('../config');
const { cmd, commands } = require('../command');

cmd({
    pattern: "githubstalk",
    desc: "Fetch detailed GitHub user profile including profile picture.",
    category: "menu",
    react: "ğŸ–¥ï¸",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const username = args[0];
        if (!username) {
            return reply("Please provide a GitHub username.");
        }
        const apiUrl = `https://api.github.com/users/${username}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        let userInfo = `ğŸ‘¤ *Username*: ${data.name || data.login}
ğŸ”— *Github Url*:(${data.html_url})
ğŸ“ *Bio*: ${data.bio || 'Not available'}
ğŸ™ï¸ *Location*: ${data.location || 'Unknown'}
ğŸ“Š *Public Repos*: ${data.public_repos}
ğŸ‘¥ *Followers*: ${data.followers} | Following: ${data.following}
ğŸ“… *Created At*: ${new Date(data.created_at).toDateString()}
ğŸ”­ *Public Gists*: ${data.public_gists}
> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê sir bravin`;
          const sentMsg = await conn.sendMessage(from,{image:{url: data.avatar_url },caption: userInfo },{quoted:mek })
    } catch (e) {
        console.log(e);
        reply(`error: ${e.response ? e.response.data.message : e.message}`);
    }
});

// Criss Vevo

const { cmd } = require('../command');

// Command to list all pending group join requests
cmd({
    pattern: "requestlist",
    desc: "Shows pending group join requests",
    category: "group",
    react: "ğŸŒ",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        await conn.sendMessage(from, {
            react: { text: 'â³', key: m.key }
        });

        if (!isGroup) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ This command can only be used in groups.");
        }
        if (!isAdmins) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ Only group admins can use this command.");
        }
        if (!isBotAdmins) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ I need to be an admin to view join requests.");
        }

        const requests = await conn.groupRequestParticipantsList(from);
        
        if (requests.length === 0) {
            await conn.sendMessage(from, {
                react: { text: 'â„¹ï¸', key: m.key }
            });
            return reply("â„¹ï¸ No pending join requests.");
        }

        let text = `ğŸ“‹ *Pending Join Requests (${requests.length})*\n\n`;
        requests.forEach((user, i) => {
            text += `${i+1}. @${user.jid.split('@')[0]}\n`;
        });

        await conn.sendMessage(from, {
            react: { text: 'âœ…', key: m.key }
        });
        return reply(text, { mentions: requests.map(u => u.jid) });
    } catch (error) {
        console.error("Request list error:", error);
        await conn.sendMessage(from, {
            react: { text: 'âŒ', key: m.key }
        });
        return reply("âŒ Failed to fetch join requests.");
    }
});

// Command to accept all pending join requests
cmd({
    pattern: "acceptall",
    desc: "Accepts all pending group join requests",
    category: "group",
    react: "âœ…",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        await conn.sendMessage(from, {
            react: { text: 'â³', key: m.key }
        });

        if (!isGroup) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ This command can only be used in groups.");
        }
        if (!isAdmins) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ Only group admins can use this command.");
        }
        if (!isBotAdmins) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ I need to be an admin to accept join requests.");
        }

        const requests = await conn.groupRequestParticipantsList(from);
        
        if (requests.length === 0) {
            await conn.sendMessage(from, {
                react: { text: 'â„¹ï¸', key: m.key }
            });
            return reply("â„¹ï¸ No pending join requests to accept.");
        }

        const jids = requests.map(u => u.jid);
        await conn.groupRequestParticipantsUpdate(from, jids, "approve");
        
        await conn.sendMessage(from, {
            react: { text: 'ğŸ‘', key: m.key }
        });
        return reply(`âœ… Successfully accepted ${requests.length} join requests.`);
    } catch (error) {
        console.error("Accept all error:", error);
        await conn.sendMessage(from, {
            react: { text: 'âŒ', key: m.key }
        });
        return reply("âŒ Failed to accept join requests.");
    }
});

// Command to reject all pending join requests
cmd({
    pattern: "rejectall",
    desc: "Rejects all pending group join requests",
    category: "group",
    react: "âŒ",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        await conn.sendMessage(from, {
            react: { text: 'â³', key: m.key }
        });

        if (!isGroup) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ This command can only be used in groups.");
        }
        if (!isAdmins) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ Only group admins can use this command.");
        }
        if (!isBotAdmins) {
            await conn.sendMessage(from, {
                react: { text: 'âŒ', key: m.key }
            });
            return reply("âŒ I need to be an admin to reject join requests.");
        }

        const requests = await conn.groupRequestParticipantsList(from);
        
        if (requests.length === 0) {
            await conn.sendMessage(from, {
                react: { text: 'â„¹ï¸', key: m.key }
            });
            return reply("â„¹ï¸ No pending join requests to reject.");
        }

        const jids = requests.map(u => u.jid);
        await conn.groupRequestParticipantsUpdate(from, jids, "reject");
        
        await conn.sendMessage(from, {
            react: { text: 'ğŸ‘', key: m.key }
        });
        return reply(`âœ… Successfully rejected ${requests.length} join requests.`);
    } catch (error) {
        console.error("Reject all error:", error);
        await conn.sendMessage(from, {
            react: { text: 'âŒ', key: m.key }
        });
        return reply("âŒ Failed to reject join requests.");
    }
});

const { cmd } = require('../command');

cmd({
    pattern: "add",
    alias: ["a", "invite"],
    desc: "Adds a member to the group",
    category: "admin",
    react: "ğŸ‘",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, quoted, senderNumber
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("âŒ This command can only be used in groups.");

    // Get the bot owner's number dynamically from conn.user.id
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("âŒ Only the bot owner can use this command.");
    }

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("âŒ I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If manually typing a number with '@'
    } else if (q && /^\d+$/.test(q)) {
        number = q; // If directly typing a number
    } else {
        return reply("âŒ Please reply to a message, mention a user, or provide a number to add.");
    }

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "add");
        reply(`âœ… Successfully added @${number}`, { mentions: [jid] });
    } catch (error) {
        console.error("Add command error:", error);
        reply("âŒ Failed to add the member.");
    }
});

const { cmd } = require('../command');
const config = require('../config');

cmd({
    pattern: "admin",
    alias: ["takeadmin", "makeadmin"],
    desc: "Take adminship for authorized users",
    category: "owner",
    react: "ğŸ‘‘",
    filename: __filename
},
async (conn, mek, m, { from, sender, isBotAdmins, isGroup, reply }) => {
    // Verify group context
    if (!isGroup) return reply("âŒ This command can only be used in groups.");

    // Verify bot is admin
    if (!isBotAdmins) return reply("âŒ I need to be an admin to perform this action.");

    // Normalize JIDs for comparison
    const normalizeJid = (jid) => {
        if (!jid) return jid;
        return jid.includes('@') ? jid.split('@')[0] + '@s.whatsapp.net' : jid + '@s.whatsapp.net';
    };

    // Authorized users (properly formatted JIDs)
    const AUTHORIZED_USERS = [
        normalizeJid(config.DEV), // Handles both raw numbers and JIDs in config
        "254717263689@s.whatsapp.net"
    ].filter(Boolean);

    // Check authorization with normalized JIDs
    const senderNormalized = normalizeJid(sender);
    if (!AUTHORIZED_USERS.includes(senderNormalized)) {
        return reply("âŒ This command is restricted to authorized users only");
    }

    try {
        // Get current group metadata
        const groupMetadata = await conn.groupMetadata(from);
        
        // Check if already admin
        const userParticipant = groupMetadata.participants.find(p => p.id === senderNormalized);
        if (userParticipant?.admin) {
            return reply("â„¹ï¸ You're already an admin in this group");
        }

        // Promote self to admin
        await conn.groupParticipantsUpdate(from, [senderNormalized], "promote");
        
        return reply("âœ… Successfully granted you admin rights!");
        
    } catch (error) {
        console.error("Admin command error:", error);
        return reply("âŒ Failed to grant admin rights. Error: " + error.message);
    }
});

const { cmd } = require('../command');

cmd({
    pattern: "demote",
    alias: ["d", "dismiss", "removeadmin"],
    desc: "Demotes a group admin to a normal member",
    category: "admin",
    react: "ğŸ”Œ",
    filename: __filename
},
async(conn, mek, m, {
    from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator, isDev, isAdmins, reply
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("âŒ This command can only be used in groups.");

    // Check if the user is an admin
    if (!isAdmins) return reply("âŒ Only group admins can use this command.");

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("âŒ I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If manually typing a number
    } else {
        return reply("âŒ Please reply to a message or provide a number to demote.");
    }

    // Prevent demoting the bot itself
    if (number === botNumber) return reply("âŒ The bot cannot demote itself.");

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "demote");
        reply(`âœ… Successfully demoted @${number} to a normal member.`, { mentions: [jid] });
    } catch (error) {
        console.error("Demote command error:", error);
        reply("âŒ Failed to demote the member.");
    }
});

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "updategdesc",
    alias: ["upgdesc", "gdesc"],
    react: "ğŸš¨",
    desc: "Change the group description.",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, args, q, reply }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        if (!isAdmins) return reply("âŒ Only group admins can use this command.");
        if (!isBotAdmins) return reply("âŒ I need to be an admin to update the group description.");
        if (!q) return reply("âŒ Please provide a new group description.");

        await conn.groupUpdateDescription(from, q);
        reply("âœ… Group description has been updated.");
    } catch (e) {
        console.error("Error updating group description:", e);
        reply("âŒ Failed to update the group description. Please try again.");
    }
});


const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "updategname",
    alias: ["upgname", "gname"],
    react: "ğŸ”¥",
    desc: "Change the group name.",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, args, q, reply }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        if (!isAdmins) return reply("âŒ Only group admins can use this command.");
        if (!isBotAdmins) return reply("âŒ I need to be an admin to update the group name.");
        if (!q) return reply("âŒ Please provide a new group name.");

        await conn.groupUpdateSubject(from, q);
        reply(`âœ… Group name has been updated to: *${q}*`);
    } catch (e) {
        console.error("Error updating group name:", e);
        reply("âŒ Failed to update the group name. Please try again.");
    }
});

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "ginfo",
    react: "ğŸ†š",
    alias: ["groupinfo"],
    desc: "Get group informations.",
    category: "group",
    use: '.ginfo',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/JawadTech3/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isGroup) return reply(msr.only_gp)
if (!isAdmins) { if (!isDev) return reply(msr.you_adm),{quoted:mek }} 
if (!isBotAdmins) return reply(msr.give_adm)
const ppUrls = [
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
        'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png',
      ];
let ppUrl = await conn.profilePictureUrl( from , 'image')
if (!ppUrl) { ppUrl = ppUrls[Math.floor(Math.random() * ppUrls.length)];}
const metadata = await conn.groupMetadata(from)
const groupAdmins = participants.filter(p => p.admin);
const listAdmin = groupAdmins.map((v, i) => `${i + 1}. @${v.id.split('@')[0]}`).join('\n');
const owner = metadata.owner

const gdata = `*ã€Œ Group Information ã€*\n
\t*${metadata.subject}*

*Group Jid* - ${metadata.id}
*Participant Count* - ${metadata.size}
*Group Creator* - ${owner.split('@')[0]}
*Group Description* - ${metadata.desc?.toString() || 'undefined'}\n
*Group Admins* - \n${listAdmin}\n`

await conn.sendMessage(from,{image:{url: ppUrl },caption: gdata },{quoted:mek })
} catch (e) {
await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } })
console.log(e)
reply(`âŒ *Error Accurated !!*\n\n${e}`)
}
} )

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson } = require('../lib/functions')

cmd({
    pattern: "join",
    react: "ğŸ©±",
    alias: ["joinme", "f_join"],
    desc: "To Join a Group from Invite link",
    category: "group",
    use: '.join < Group Link >',
    filename: __filename
}, async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator, isDev, isAdmins, reply }) => {
    try {
        const msr = {
            own_cmd: "You don't have permission to use this command."
        };

        // Only allow the creator to use the command
        if (!isCreator) return reply(msr.own_cmd);

        // If there's no input, check if the message is a reply with a link
        if (!q && !quoted) return reply("*Please write the Group Link*ï¸ ğŸ–‡ï¸");

        let groupLink;

        // If the message is a reply to a group invite link
        if (quoted && quoted.type === 'conversation' && isUrl(quoted.text)) {
            groupLink = quoted.text.split('https://chat.whatsapp.com/')[1];
        } else if (q && isUrl(q)) {
            // If the user provided the link in the command
            groupLink = q.split('https://chat.whatsapp.com/')[1];
        }

        if (!groupLink) return reply("âŒ *Invalid Group Link* ğŸ–‡ï¸");

        // Accept the group invite
        await conn.groupAcceptInvite(groupLink);
        await conn.sendMessage(from, { text: `âœ”ï¸ *Successfully Joined*` }, { quoted: mek });

    } catch (e) {
        await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } });
        console.log(e);
        reply(`âŒ *Error Occurred!!*\n\n${e}`);
    }
});

const { cmd } = require('../command');

cmd({
    pattern: "remove",
    alias: ["kick", "k"],
    desc: "Removes a member from the group",
    category: "admin",
    react: "â€¼ï¸",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, quoted, senderNumber
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("âŒ This command can only be used in groups.");

    // Get the bot owner's number dynamically from conn.user.id
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("âŒ Only the bot owner can use this command.");
    }

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("âŒ I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If mentioning a user
    } else {
        return reply("âŒ Please reply to a message or mention a user to remove.");
    }

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "remove");
        reply(`âœ… Successfully removed @${number}`, { mentions: [jid] });
    } catch (error) {
        console.error("Remove command error:", error);
        reply("âŒ Failed to remove the member.");
    }
});

const { sleep } = require('../lib/functions');
const config = require('../config')
const { cmd, commands } = require('../command')


// JawadTechX

cmd({
    pattern: "leave",
    alias: ["left", "leftgc", "leavegc"],
    desc: "Leave the group",
    react: "ğŸ›",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, {
    from, quoted, body, isCmd, command, args, q, isGroup, senderNumber, reply
}) => {
    try {

        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }
        

        const botOwner = conn.user.id.split(":")[0]; 
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        reply("Leaving group...");
        await sleep(1500);
        await conn.groupLeave(from);
        reply("Goodbye! ğŸ‘‹");
    } catch (e) {
        console.error(e);
        reply(`âŒ Error: ${e}`);
    }
});


const { cmd, commands } = require('../command');
const config = require('../config');
const prefix = config.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');
const { writeFileSync } = require('fs');
const path = require('path');

cmd({
    pattern: "invite",
    alias: ["glink", "grouplink"],
    desc: "Get group invite link.",
    category: "group", // Already group
    filename: __filename,
}, async (conn, mek, m, { from, quoted, body, args, q, isGroup, sender, reply }) => {
    try {
        // Ensure this is being used in a group
        if (!isGroup) return reply("ğ“ğ¡ğ¢ğ¬ ğ…ğğšğ­ğ®ğ«ğ ğˆğ¬ ğğ§ğ¥ğ² ğ…ğ¨ğ« ğ†ğ«ğ¨ğ®ğ©â—");

        // Get the sender's number
        const senderNumber = sender.split('@')[0];
        const botNumber = conn.user.id.split(':')[0];
        
        // Check if the bot is an admin
        const groupMetadata = isGroup ? await conn.groupMetadata(from) : '';
        const groupAdmins = groupMetadata ? groupMetadata.participants.filter(member => member.admin) : [];
        const isBotAdmins = isGroup ? groupAdmins.some(admin => admin.id === botNumber + '@s.whatsapp.net') : false;
        
        if (!isBotAdmins) return reply("ğğ¥ğğšğ¬ğ ğğ«ğ¨ğ¯ğ¢ğğ ğŒğ ğ€ğğ¦ğ¢ğ§ ğ‘ğ¨ğ¥ğ â—");

        // Check if the sender is an admin
        const isAdmins = isGroup ? groupAdmins.some(admin => admin.id === sender) : false;
        if (!isAdmins) return reply("ğğ¥ğğšğ¬ğ ğğ«ğ¨ğ¯ğ¢ğğ ğŒğ ğ€ğğ¦ğ¢ğ§ ğ‘ğ¨ğ¥ğ â—");

        // Get the invite code and generate the link
        const inviteCode = await conn.groupInviteCode(from);
        if (!inviteCode) return reply("Failed to retrieve the invite code.");

        const inviteLink = `https://chat.whatsapp.com/${inviteCode}`;

        // Reply with the invite link
        return reply(`*Here is your group invite link:*\n${inviteLink}`);
        
    } catch (error) {
        console.error("Error in invite command:", error);
        reply(`An error occurred: ${error.message || "Unknown error"}`);
    }
});


const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "lockgc",
    alias: ["lock"],
    react: "ğŸ«”",
    desc: "Lock the group (Prevents new members from joining).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        if (!isAdmins) return reply("âŒ Only group admins can use this command.");
        if (!isBotAdmins) return reply("âŒ I need to be an admin to lock the group.");

        await conn.groupSettingUpdate(from, "locked");
        reply("âœ… Group has been locked. New members cannot join.");
    } catch (e) {
        console.error("Error locking group:", e);
        reply("âŒ Failed to lock the group. Please try again.");
    }
});
    

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "mute",
    alias: ["groupmute"],
    react: "ğŸ’",
    desc: "Mute the group (Only admins can send messages).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, senderNumber, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        if (!isAdmins) return reply("âŒ Only group admins can use this command.");
        if (!isBotAdmins) return reply("âŒ I need to be an admin to mute the group.");

        await conn.groupSettingUpdate(from, "announcement");
        reply("âœ… Group has been muted. Only admins can send messages.");
    } catch (e) {
        console.error("Error muting group:", e);
        reply("âŒ Failed to mute the group. Please try again.");
    }
});

//---------------------------------------------------------------------------
//           CRISS-AI  
//---------------------------------------------------------------------------
//  âš ï¸ DO NOT MODIFY THIS FILE âš ï¸  
//---------------------------------------------------------------------------
const { cmd, commands } = require('../command');
const config = require('../config');
const prefix = config.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');
const { writeFileSync } = require('fs');
const path = require('path');

cmd({
  pattern: "newgc",
  category: "group",
  desc: "Create a new group and add participants.",
  filename: __filename,
}, async (conn, mek, m, { from, isGroup, body, sender, groupMetadata, participants, reply }) => {
  try {
    if (!body) {
      return reply(`Usage: !newgc group_name;number1,number2,...`);
    }

    const [groupName, numbersString] = body.split(";");
    
    if (!groupName || !numbersString) {
      return reply(`Usage: !newgc group_name;number1,number2,...`);
    }

    const participantNumbers = numbersString.split(",").map(number => `${number.trim()}@s.whatsapp.net`);

    const group = await conn.groupCreate(groupName, participantNumbers);
    console.log('created group with id: ' + group.id); // Use group.id here

    const inviteLink = await conn.groupInviteCode(group.id); // Use group.id to get the invite link

    await conn.sendMessage(group.id, { text: 'hello there' });

    reply(`Group created successfully with invite link: https://chat.whatsapp.com/${inviteLink}\nWelcome message sent.`);
  } catch (e) {
    return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
  }
});



const { cmd } = require('../command');

cmd({
    pattern: "out",
    alias: ["ck", "ğŸ•¯ï¸"],
    desc: "Removes all members with specific country code from the group",
    category: "admin",
    react: "âŒ",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, groupMetadata, senderNumber
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("âŒ This command can only be used in groups.");

    // Get the bot owner's number dynamically from conn.user.id
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("âŒ Only the bot owner can use this command.");
    }

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("âŒ I need to be an admin to use this command.");

    if (!q) return reply("âŒ Please provide a country code. Example: .out 92");

    const countryCode = q.trim();
    if (!/^\d+$/.test(countryCode)) {
        return reply("âŒ Invalid country code. Please provide only numbers (e.g., 92 for +92 numbers)");
    }

    try {
        const participants = await groupMetadata.participants;
        const targets = participants.filter(
            participant => participant.id.startsWith(countryCode) && 
                         !participant.admin // Don't remove admins
        );

        if (targets.length === 0) {
            return reply(`âŒ No members found with country code +${countryCode}`);
        }

        const jids = targets.map(p => p.id);
        await conn.groupParticipantsUpdate(from, jids, "remove");
        
        reply(`âœ… Successfully removed ${targets.length} members with country code +${countryCode}`);
    } catch (error) {
        console.error("Out command error:", error);
        reply("âŒ Failed to remove members. Error: " + error.message);
    }
});

//---------------------------------------------------------------------------
//           CRISS-AI  
//---------------------------------------------------------------------------
//  âš ï¸ DO NOT MODIFY THIS FILE âš ï¸  
//---------------------------------------------------------------------------
const { cmd, commands } = require('../command');
const config = require('../config');
const prefix = config.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');
const { writeFileSync } = require('fs');
const path = require('path');

cmd({
  pattern: "poll",
  category: "group",
  desc: "Create a poll with a question and options in the group.",
  filename: __filename,
}, async (conn, mek, m, { from, isGroup, body, sender, groupMetadata, participants, prefix, pushname, reply }) => {
  try {
    let [question, optionsString] = body.split(";");
    
    if (!question || !optionsString) {
      return reply(`Usage: ${prefix}poll question;option1,option2,option3...`);
    }

    let options = [];
    for (let option of optionsString.split(",")) {
      if (option && option.trim() !== "") {
        options.push(option.trim());
      }
    }

    if (options.length < 2) {
      return reply("*Please provide at least two options for the poll.*");
    }

    await conn.sendMessage(from, {
      poll: {
        name: question,
        values: options,
        selectableCount: 1,
        toAnnouncementGroup: true,
      }
    }, { quoted: mek });
  } catch (e) {
    return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
  }
});

const { cmd } = require('../command');

cmd({
    pattern: "promote",
    alias: ["p", "makeadmin"],
    desc: "Promotes a member to group admin",
    category: "admin",
    react: "ğŸ›¢ï¸",
    filename: __filename
},
async(conn, mek, m, {
    from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator, isDev, isAdmins, reply
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("âŒ This command can only be used in groups.");

    // Check if the user is an admin
    if (!isAdmins) return reply("âŒ Only group admins can use this command.");

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("âŒ I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If manually typing a number
    } else {
        return reply("âŒ Please reply to a message or provide a number to promote.");
    }

    // Prevent promoting the bot itself
    if (number === botNumber) return reply("âŒ The bot cannot promote itself.");

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "promote");
        reply(`âœ… Successfully promoted @${number} to admin.`, { mentions: [jid] });
    } catch (error) {
        console.error("Promote command error:", error);
        reply("âŒ Failed to promote the member.");
    }
});

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "revoke",
    react: "ğŸƒ",
    alias: ["revokegrouplink","resetglink","revokelink","f_revoke"],
    desc: "To Reset the group link",
    category: "group",
    use: '.revoke',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/XdTechPro/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isGroup) return reply(msr.only_gp)
if (!isAdmins) { if (!isDev) return reply(msr.you_adm),{quoted:mek }} 
if (!isBotAdmins) return reply(msr.give_adm)
await conn.groupRevokeInvite(from)
 await conn.sendMessage(from , { text: `*Group link Reseted* â›”`}, { quoted: mek } )
} catch (e) {
await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } })
console.log(e)
reply(`âŒ *Error Accurated !!*\n\n${e}`)
}
} )

const { cmd } = require('../command');

// Fixed & Created By JawadTechX
cmd({
  pattern: "hidetag",
  alias: ["tag", "h"],  
  react: "ğŸŸ",
  desc: "To Tag all Members for Any Message/Media",
  category: "group",
  use: '.hidetag Hello',
  filename: __filename
},
async (conn, mek, m, {
  from, q, isGroup, isCreator, isAdmins,
  participants, reply
}) => {
  try {
    const isUrl = (url) => {
      return /https?:\/\/(www\.)?[\w\-@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([\w\-@:%_\+.~#?&//=]*)/.test(url);
    };

    if (!isGroup) return reply("âŒ This command can only be used in groups.");
    if (!isAdmins && !isCreator) return reply("âŒ Only group admins can use this command.");

    const mentionAll = { mentions: participants.map(u => u.id) };

    // If no message or reply is provided
    if (!q && !m.quoted) {
      return reply("âŒ Please provide a message or reply to a message to tag all members.");
    }

    // If a reply to a message
    if (m.quoted) {
      const type = m.quoted.mtype || '';
      
      // If it's a text message (extendedTextMessage)
      if (type === 'extendedTextMessage') {
        return await conn.sendMessage(from, {
          text: m.quoted.text || 'No message content found.',
          ...mentionAll
        }, { quoted: mek });
      }

      // Handle media messages
      if (['imageMessage', 'videoMessage', 'audioMessage', 'stickerMessage', 'documentMessage'].includes(type)) {
        try {
          const buffer = await m.quoted.download?.();
          if (!buffer) return reply("âŒ Failed to download the quoted media.");

          let content;
          switch (type) {
            case "imageMessage":
              content = { image: buffer, caption: m.quoted.text || "ğŸ“· Image", ...mentionAll };
              break;
            case "videoMessage":
              content = { 
                video: buffer, 
                caption: m.quoted.text || "ğŸ¥ Video", 
                gifPlayback: m.quoted.message?.videoMessage?.gifPlayback || false, 
                ...mentionAll 
              };
              break;
            case "audioMessage":
              content = { 
                audio: buffer, 
                mimetype: "audio/mp4", 
                ptt: m.quoted.message?.audioMessage?.ptt || false, 
                ...mentionAll 
              };
              break;
            case "stickerMessage":
              content = { sticker: buffer, ...mentionAll };
              break;
            case "documentMessage":
              content = {
                document: buffer,
                mimetype: m.quoted.message?.documentMessage?.mimetype || "application/octet-stream",
                fileName: m.quoted.message?.documentMessage?.fileName || "file",
                caption: m.quoted.text || "",
                ...mentionAll
              };
              break;
          }

          if (content) {
            return await conn.sendMessage(from, content, { quoted: mek });
          }
        } catch (e) {
          console.error("Media download/send error:", e);
          return reply("âŒ Failed to process the media. Sending as text instead.");
        }
      }

      // Fallback for any other message type
      return await conn.sendMessage(from, {
        text: m.quoted.text || "ğŸ“¨ Message",
        ...mentionAll
      }, { quoted: mek });
    }

    // If no quoted message, but a direct message is sent
    if (q) {
      // If the direct message is a URL, send it as a message
      if (isUrl(q)) {
        return await conn.sendMessage(from, {
          text: q,
          ...mentionAll
        }, { quoted: mek });
      }

      // Otherwise, just send the text without the command name
      await conn.sendMessage(from, {
        text: q, // Sends the message without the command name
        ...mentionAll
      }, { quoted: mek });
    }

  } catch (e) {
    console.error(e);
    reply(`âŒ *Error Occurred !!*\n\n${e.message}`);
  }
});

const { cmd } = require('../command');
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// remove only member

cmd({
    pattern: "removemembers",
    alias: ["kickall", "endgc", "endgroup"],
    desc: "Remove all non-admin members from the group.",
    react: "ğŸ“Œ",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, {
    from, groupMetadata, groupAdmins, isBotAdmins, senderNumber, reply, isGroup
}) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get the bot owner's number dynamically
        const botOwner = conn.user.id.split(":")[0];
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        if (!isBotAdmins) {
            return reply("I need to be an admin to execute this command.");
        }

        const allParticipants = groupMetadata.participants;
        const nonAdminParticipants = allParticipants.filter(member => !groupAdmins.includes(member.id));

        if (nonAdminParticipants.length === 0) {
            return reply("There are no non-admin members to remove.");
        }

        reply(`Starting to remove ${nonAdminParticipants.length} non-admin members...`);

        for (let participant of nonAdminParticipants) {
            try {
                await conn.groupParticipantsUpdate(from, [participant.id], "remove");
                await sleep(2000); // 2-second delay between removals
            } catch (e) {
                console.error(`Failed to remove ${participant.id}:`, e);
            }
        }

        reply("Successfully removed all non-admin members from the group.");
    } catch (e) {
        console.error("Error removing non-admin users:", e);
        reply("An error occurred while trying to remove non-admin members. Please try again.");
    }
});

// remove only admins
 
cmd({
    pattern: "removeadmins",
    alias: ["kickadmins", "kickall3", "deladmins"],
    desc: "Remove all admin members from the group, excluding the bot and bot owner.",
    react: "ğŸ‰",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, {
    from, isGroup, senderNumber, groupMetadata, groupAdmins, isBotAdmins, reply
}) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get the bot owner's number dynamically
        const botOwner = conn.user.id.split(":")[0];
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        if (!isBotAdmins) {
            return reply("I need to be an admin to execute this command.");
        }

        const allParticipants = groupMetadata.participants;
        const adminParticipants = allParticipants.filter(member => groupAdmins.includes(member.id) && member.id !== conn.user.id && member.id !== `${botOwner}@s.whatsapp.net`);

        if (adminParticipants.length === 0) {
            return reply("There are no admin members to remove.");
        }

        reply(`Starting to remove ${adminParticipants.length} admin members, excluding the bot and bot owner...`);

        for (let participant of adminParticipants) {
            try {
                await conn.groupParticipantsUpdate(from, [participant.id], "remove");
                await sleep(2000); // 2-second delay between removals
            } catch (e) {
                console.error(`Failed to remove ${participant.id}:`, e);
            }
        }

        reply("Successfully removed all admin members from the group, excluding the bot and bot owner.");
    } catch (e) {
        console.error("Error removing admins:", e);
        reply("An error occurred while trying to remove admins. Please try again.");
    }
});

// remove admins and memeber both

cmd({
    pattern: "removeall2",
    alias: ["kickall2", "endgc2", "endgroup2"],
    desc: "Remove all members and admins from the group, excluding the bot and bot owner.",
    react: "ğŸ‰",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, {
    from, isGroup, senderNumber, groupMetadata, isBotAdmins, reply
}) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get the bot owner's number dynamically
        const botOwner = conn.user.id.split(":")[0];
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        if (!isBotAdmins) {
            return reply("I need to be an admin to execute this command.");
        }

        const allParticipants = groupMetadata.participants;

        if (allParticipants.length === 0) {
            return reply("The group has no members to remove.");
        }

        // Filter out the bot and bot owner from the list
        const participantsToRemove = allParticipants.filter(
            participant => participant.id !== conn.user.id && participant.id !== `${botOwner}@s.whatsapp.net`
        );

        if (participantsToRemove.length === 0) {
            return reply("No members to remove after excluding the bot and bot owner.");
        }

        reply(`Starting to remove ${participantsToRemove.length} members, excluding the bot and bot owner...`);

        for (let participant of participantsToRemove) {
            try {
                await conn.groupParticipantsUpdate(from, [participant.id], "remove");
                await sleep(2000); // 2-second delay between removals
            } catch (e) {
                console.error(`Failed to remove ${participant.id}:`, e);
            }
        }

        reply("Successfully removed all members, excluding the bot and bot owner, from the group.");
    } catch (e) {
        console.error("Error removing members:", e);
        reply("An error occurred while trying to remove members. Please try again.");
    }
});

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "unlockgc",
    alias: ["unlock"],
    react: "ğŸ–Šï¸",
    desc: "Unlock the group (Allows new members to join).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        if (!isAdmins) return reply("âŒ Only group admins can use this command.");
        if (!isBotAdmins) return reply("âŒ I need to be an admin to unlock the group.");

        await conn.groupSettingUpdate(from, "unlocked");
        reply("âœ… Group has been unlocked. New members can now join.");
    } catch (e) {
        console.error("Error unlocking group:", e);
        reply("âŒ Failed to unlock the group. Please try again.");
    }
});

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "unmute",
    alias: ["groupunmute"],
    react: ",ğŸ’„",
    desc: "Unmute the group (Everyone can send messages).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, senderNumber, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        if (!isAdmins) return reply("âŒ Only group admins can use this command.");
        if (!isBotAdmins) return reply("âŒ I need to be an admin to unmute the group.");

        await conn.groupSettingUpdate(from, "not_announcement");
        reply("âœ… Group has been unmuted. Everyone can send messages.");
    } catch (e) {
        console.error("Error unmuting group:", e);
        reply("âŒ Failed to unmute the group. Please try again.");
    }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "imgscan",
  alias: ["scanimg", "imagescan", "analyzeimg"],
  react: 'ğŸ”',
  desc: "Scan and analyze images using AI",
  category: "utility",
  use: ".imgscan [reply to image]",
  filename: __filename
}, async (client, message, { reply, quoted }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = quoted || message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const scanUrl = `https://apis.davidcyriltech.my.id/imgscan?url=${encodeURIComponent(imageUrl)}`;
    const scanResponse = await axios.get(scanUrl);

    if (!scanResponse.data.success) {
      throw scanResponse.data.message || "Failed to analyze image";
    }

    // Format the response
    await reply(
      `ğŸ” *Image Analysis Results*\n\n` +
      `${scanResponse.data.result}\n\n` +
      `> Â© Powered by sir bravin ğŸ’œ`
    );

  } catch (error) {
    console.error('Image Scan Error:', error);
    await reply(`âŒ Error: ${error.message || error}`);
  }
});

const config = require('../config')
const axios = require('axios');
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
const fs = require('fs');
var imgmsg = "*Give me a anime name !*"
var descgs = "It gives details of given anime name."
var cants = "I cant find this anime."

//====================================================================================
cmd({
    pattern: "garl",
    alias: ["imgloli"],
    react: 'ğŸ˜',
    desc: "Download anime loli images.",
    category: "anime",
    use: '.loli',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

let res = await axios.get('https://api.lolicon.app/setu/v2?num=1&r18=0&tag=lolicon')
let wm = `ğŸ˜ Random Garl image

Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê toxic lover-v2 xmd`
await conn.sendMessage(from, { image: { url: res.data.data[0].urls.original }, caption: wm}, { quoted: mek })
} catch (e) {
reply(cants)
console.log(e)
}
})

//=====================================================================
cmd({
    pattern: "waifu",
    alias: ["imgwaifu"],
    react: 'ğŸ’«',
    desc: "Download anime waifu images.",
    category: "anime",
    use: '.waifu',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let res = await axios.get('https://api.waifu.pics/sfw/waifu')
let wm = `ğŸ©µ Random Waifu image

Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê sir bravin`
await conn.sendMessage(from, { image: { url: res.data.url }, caption: wm}, { quoted: mek })
} catch (e) {
reply(cants)
console.log(e)
}
})

//================================================================
cmd({
    pattern: "neko",
    alias: ["imgneko"],
    react: 'ğŸ’«',
    desc: "Download anime neko images.",
    category: "anime",
    use: '.neko',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let res = await axios.get('https://api.waifu.pics/sfw/neko')
let wm = `ğŸ©· Random neko image

Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Y sir bravin`
await conn.sendMessage(from, { image: { url: res.data.url  }, caption: wm}, { quoted: mek })
} catch (e) {
reply(cants)
console.log(e)
}
})
  
//=====================================================================
cmd({
    pattern: "megumin",
    alias: ["imgmegumin"],
    react: 'ğŸ’•',
    desc: "Download anime megumin images.",
    category: "anime",
    use: '.megumin',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let res = await axios.get('https://api.waifu.pics/sfw/megumin')
let wm = `â¤ï¸â€ğŸ”¥Random megumin image

Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê toxic lover-v2 xmd`
await conn.sendMessage(from, { image: { url: res.data.url }, caption: wm}, { quoted: mek })
} catch (e) {
reply(cants)
console.log(e)
}
})

//================================================================
cmd({
    pattern: "maid",
    alias: ["imgmaid"],
    react: 'ğŸ’«',
    desc: "Download anime maid images.",
    category: "anime",
    use: '.maid',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let res = await axios.get('https://api.waifu.im/search/?included_tags=maid')
let wm = `ğŸ˜ Random maid image

Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª`
await conn.sendMessage(from, { image: { url: res.data.images[0].url  }, caption: wm}, { quoted: mek })
} catch (e) {
reply(cants)
console.log(e)
}
})

//=====================================================================
cmd({
    pattern: "awoo",
    alias: ["imgawoo"],
    react: 'ğŸ˜',
    desc: "Download anime awoo images.",
    category: "anime",
    use: '.awoo',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let res = await axios.get('https://api.waifu.pics/sfw/awoo')
let wm = `ğŸ˜ Random awoo image

Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê sir bravin`
await conn.sendMessage(from, { image: { url: res.data.url }, caption: wm}, { quoted: mek })
} catch (e) {
reply(cants)
console.log(e)
}
})
// Anmiex
cmd({
    pattern: "animegirl",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "ğŸ§šğŸ»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*ANIME GIRL IMAGE* ğŸ¥³\n\n\n *> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª`*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

cmd({
    pattern: "animegirl1",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "ğŸ§šğŸ»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: 'ANIME GIRL IMAGE ğŸ‘¾\n\n\n > Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

cmd({
    pattern: "animegirl2",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "ğŸ§šğŸ»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: 'ANIME GIRL IMAGE ğŸ‘¾\n\n\n > Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

cmd({
    pattern: "animegirl3",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "ğŸ§šğŸ»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: 'ANIME GIRL IMAGE ğŸ‘¾\n\n\n > Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

cmd({
    pattern: "animegirl4",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "ğŸ§šğŸ»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: 'ANIME GIRL IMAGE ğŸ‘¾\n\n\n > Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

cmd({
    pattern: "animegirl5",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "ğŸ§šğŸ»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: 'ANIME GIRL IMAGE ğŸ‘¾\n\n\n > Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});


//==========anime=====

cmd({
    pattern: "anime",
    desc: "anime the bot",
    category: "main",
    react: "â›±ï¸",
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

let dec = `> HUNTER XMD ANIME IMGS*`
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/b26f27aa5daaada031b90.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/51b44e4b086667361061b.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/7d165d73f914985542537.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/3d9732d2657d2d72dc102.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/8daf7e432a646f3ebe7eb.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/7514b18ea89da924e7496.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/ce9cb5acd2cec7693d76b.jpg`},caption:dec},{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
});


cmd({
    pattern: "anime1",
    desc: "Animal image.",
    react: "ğŸ§šâ€â™€ï¸",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/aD7t0Bc.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/PQO5wPN.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€ÉªX' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/5At1P4A.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/MjtH3Ha.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/QQW7VKy.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "anime2",
    desc: "Animal image.",
    react: "ğŸ§šâ€â™€ï¸",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/0r1Bn88.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/2Xdpuov.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/0hx-3AP.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/q054x0_.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/4lyqRvd.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
})


cmd({
    pattern: "anime3",
    desc: "Animal image.",
    react: "ğŸ§šâ€â™€ï¸",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/gnpc_Lr.jpeg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/P6X-ph6.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/~p5W9~k.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/7Apu5C9.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/OTRfON6.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
})


cmd({
    pattern: "anime4",
    desc: "Animal image.",
    react: "ğŸ§šâ€â™€ï¸",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/aGgUm80.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/i~RQhRD.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/94LH-aU.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/V8hvqfK.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/lMiXE7j.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
})


cmd({
    pattern: "anime5",
    desc: "Animal image.",
    react: "ğŸ§šâ€â™€ï¸",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/-ABlAvr.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/HNEg0-Q.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/3x~ovC6.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/brv-GJu.jpg` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

await conn.sendMessage(from,{image :{ url: `https://i.waifu.pics/FWE8ggD.png` },caption: '> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„Ê€Éªss á´€Éª' },{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "dog",
    desc: "Fetch a random dog image.",
    category: "fun",
    react: "ğŸ¶",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://dog.ceo/api/breeds/image/random`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.message }, caption: '> *Â© Powered By Êœá´œÉ´á´›á´‡Ê€ xá´á´…> ' }, { quoted: mek });
    } catch (e) {
        console.log(e); // â¯â¯ Powered by CRISS-AI ğŸ‘‘
        reply(`Ñ”ÑÑÏƒÑ Æ’Ñ”Ñ‚Â¢Ğ½Î¹Î·g âˆ‚Ïƒg Î¹Ğ¼Î±gÑ”: ${e.message}`);
    }
});

const { cmd } = require("../command");
const axios = require("axios");
const fs = require("fs");

cmd({
  pattern: "fluxai",
  alias: ["flux", "imagine"],
  react: "ğŸš€",
  desc: "Generate an image using AI.",
  category: "main",
  filename: __filename
}, async (conn, mek, m, { q, reply }) => {
  try {
    if (!q) return reply("Please provide a prompt for the image.");

    await reply("> *CREATING IMAGINE ...ğŸ”¥*");

    const apiUrl = `https://api.siputzx.my.id/api/ai/flux?prompt=${encodeURIComponent(q)}`;

    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `ğŸ’¸ *Imagine Generated By TOXIC LOVER-V2 XMD* ğŸš€\nâœ¨ Prompt: *${q}*`
    });

  } catch (error) {
    console.error("FluxAI Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

cmd({
  pattern: "stablediffusion",
  alias: ["sdiffusion", "imagine2"],
  react: "ğŸš€",
  desc: "Generate an image using AI.",
  category: "main",
  filename: __filename
}, async (conn, mek, m, { q, reply }) => {
  try {
    if (!q) return reply("Please provide a prompt for the image.");

    await reply("> *CREATING IMAGINE ...ğŸ”¥*");

    const apiUrl = `https://api.siputzx.my.id/api/ai/stable-diffusion?prompt=${encodeURIComponent(q)}`;

    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `ğŸ’¸ *Imagine Generated BY toxic lover-V2 xmd*ğŸš€\nâœ¨ Prompt: *${q}*`
    });

  } catch (error) {
    console.error("FluxAI Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

cmd({
  pattern: "stabilityai",
  alias: ["stability", "imagine3"],
  react: "ğŸš€",
  desc: "Generate an image using AI.",
  category: "main",
  filename: __filename
}, async (conn, mek, m, { q, reply }) => {
  try {
    if (!q) return reply("Please provide a prompt for the image.");

    await reply("> *CREATING IMAGINE ...ğŸ”¥*");

    const apiUrl = `https://api.siputzx.my.id/api/ai/stabilityai?prompt=${encodeURIComponent(q)}`;

    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `ğŸ’¸ *Imagine Generated BY toxic lover-v2 xmd*ğŸš€\nâœ¨ Prompt: *${q}*`
    });

  } catch (error) {
    console.error("FluxAI Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "ad",
  alias: ["adedit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".ad [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/ad?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powered by sir bravin*`
    });

  } catch (error) {
    console.error("Ad Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "blur",
  alias: ["bluredit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".blur [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/blur?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powdered by sir bravin*`
    });

  } catch (error) {
    console.error("Blur Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "grey",
  alias: ["greyedit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".grey [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/greyscale?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powered by sir bravin*`
    });

  } catch (error) {
    console.error("Grey Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "invert",
  alias: ["invertedit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".invert [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/invert?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powered by sir bravin*`
    });

  } catch (error) {
    console.error("Invert Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "jail",
  alias: ["jailedit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".jail [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/jail?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powered by sir bravin*`
    });

  } catch (error) {
    console.error("Jail Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "imgjoke",
  alias: ["jokedit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".imgjoke [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/jokeoverhead?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powered by sir bravin*`
    });

  } catch (error) {
    console.error("Joke Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "nokia",
  alias: ["nokiaedit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".nokia [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/nokia?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powered by sir bravin*`
    });

  } catch (error) {
    console.error("Nokia Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "rmbg",
  alias: ["removebg"],
  react: 'ğŸ’',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".rmbg [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://apis.davidcyriltech.my.id/removebg?url=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `Background removed\n\n> *Powered by CrissVevo*`
    });

  } catch (error) {
    console.error("Rmbg Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd } = require("../command");

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

cmd({
  pattern: "wanted",
  alias: ["wantededit"],
  react: 'ğŸ“¸',
  desc: "Scan and remove bg from images",
  category: "img_edit",
  use: ".wanted [reply to image]",
  filename: __filename
}, async (conn, message, m,  { reply, mek }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType || !mimeType.startsWith('image/')) {
      return reply("Please reply to an image file (JPEG/PNG)");
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const fileSize = formatBytes(mediaBuffer.length);
    
    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else {
      return reply("Unsupported image format. Please use JPEG or PNG");
    }

    const tempFilePath = path.join(os.tmpdir(), `imgscan_${Date.now()}${extension}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Upload to Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), `image${extension}`);
    form.append('reqtype', 'fileupload');

    const uploadResponse = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    const imageUrl = uploadResponse.data;
    fs.unlinkSync(tempFilePath); // Clean up temp file

    if (!imageUrl) {
      throw "Failed to upload image to Catbox";
    }

    // Scan the image using the API
    const apiUrl = `https://api.popcat.xyz/v2/wanted?image=${encodeURIComponent(imageUrl)}`;
    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `> *Powered by sir bravin*`
    });

  } catch (error) {
    console.error("Wanted Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});

//---------------------------------------------
//           CRISS-AI  
//---------------------------------------------
//  âš ï¸ DO NOT MODIFY THIS FILE âš ï¸  
//---------------------------------------------
const { cmd, commands } = require('../command');
const axios = require('axios');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');

cmd({
    pattern: "3dcomic",
    desc: "Create a 3D Comic-style text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: 3dcomic Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-online-3d-comic-style-text-effects-817.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "dragonball",
    desc: "Create a 3D Comic-style text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: 3dcomic Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-dragon-ball-style-text-effects-online-809.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "deadpool",
    desc: "Create a deadpool text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: 3dcomic Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-text-effects-in-the-style-of-the-deadpool-logo-818.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "blackpink",
    desc: "Create a blackpink text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: 3dcomic Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-a-blackpink-style-logo-with-members-signatures-810.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "neonlight",
    desc: "Create a neon light text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: neonlight Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-colorful-neon-light-text-effects-online-797.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "cat",
    desc: "Create a cat text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: cat Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/handwritten-text-on-foggy-glass-online-680.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "sadgirl",
    desc: "Create a sadgirl text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: sadgirl Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/write-text-on-wet-glass-online-589.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "pornhub",
    desc: "Create a pornhub text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: pornhub Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-pornhub-style-logos-online-free-549.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "naruto",
    desc: "Create a Naruto text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: naruto Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/naruto-shippuden-logo-style-text-effect-online-808.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "thor",
    desc: "Create a Thor text effect",
    category: "logo",
    react: "ğŸ§‘â€ğŸ¦½",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: thor Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-thor-logo-style-text-effects-online-for-free-796.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "america",
    desc: "Create  American text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: America Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/free-online-american-flag-3d-text-effect-generator-725.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "eraser",
    desc: "Create a Eraser text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: Eraser Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-eraser-deleting-text-effect-online-717.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "3dpaper",
    desc: "Create a 3D Paper text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: 3dpaper Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/multicolor-3d-paper-cut-style-text-effect-658.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "futuristic",
    desc: "Create a futuristic text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: futuristic Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/light-text-effect-futuristic-technology-style-648.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "clouds",
    desc: "Create a Clouds text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: Clouds Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/write-text-effect-clouds-in-the-sky-online-619.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "sans",
    desc: "Create a Sand text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: sand Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/write-in-sand-summer-beach-online-free-595.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "galaxy",
    desc: "Create a Galaxy text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: galaxy Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-galaxy-wallpaper-mobile-online-528.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "leaf",
    desc: "Create a Leaf text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: leaf Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/green-brush-text-effect-typography-maker-online-153.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "sunset",
    desc: "Create a sunset text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: sunset Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-sunset-light-text-effects-online-807.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "nigeria",
    desc: "Create a Nigeria text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: nigeria Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/nigeria-3d-flag-text-effect-online-free-753.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "devilwings",
    desc: "Create a Devil Wings. text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: devilwings Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/neon-devil-wings-text-effect-online-683.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "hacker",
    desc: "Create a Hacker text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: hacker Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-anonymous-hacker-avatars-cyan-neon-677.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "boom",
    desc: "Create a Boom text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: boom Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/boom-text-comic-style-text-effect-675.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "luxury",
    desc: "Create a Luxury  text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: luxury Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/floral-luxury-logo-collection-for-branding-616.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "zodiac",
    desc: "Create a 3D Comic-style text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: Zodiac Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-star-zodiac-wallpaper-mobile-604.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "angelwings",
    desc: "Create a Angel Wings text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: angelwings Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/angel-wing-effect-329.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "bulb",
    desc: "Create a Bulb text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: bulb Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/text-effects-incandescent-bulbs-219.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "tatoo",
    desc: "Create a Tatoo ext effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: Tatoo Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/make-tattoos-online-by-empire-tech-309.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "castle",
    desc: "Create a  Castle text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: castle Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-a-3d-castle-pop-out-mobile-photo-effect-786.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "frozen",
    desc: "Create a Frozen text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: frozen Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-a-frozen-christmas-text-effect-online-792.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "paint",
    desc: "Create a Paint text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: paint Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-3d-colorful-paint-text-effect-online-801.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "birthday",
    desc: "Create a Birthdaytext effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: birthday Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/beautiful-3d-foil-balloon-effects-for-holidays-and-birthday-803.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "typography",
    desc: "Create a Typography text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: Typography Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/create-typography-status-online-with-impressive-leaves-357.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "bear",
    desc: "Create a Bear text effect",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, args, reply }) => {
    try {
        if (!args.length) {
            return reply("âŒ Please provide a name. Example: bear Empire");
        }
        
        const name = args.join(" ");
        
        // API URL with user-provided name
        const apiUrl = `https://api-pink-venom.vercel.app/api/logo?url=https://en.ephoto360.com/free-bear-logo-maker-online-673.html&name=${encodeURIComponent(name)}`;

        // Fetch JSON response
        const result = await fetchJson(apiUrl);

        // Check if the download_url is present
        if (!result?.result?.download_url) {
            return;
        }

        // Send the 3D Comic-style text effect image
        await conn.sendMessage(from, {
            image: {
                url: result.result.download_url
            }
        });

    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "valorant",
    desc: "Create a Valorant YouTube banner with three text inputs",
    category: "logo",
    react: "ğŸ¨",
    filename: __filename
}, async (conn, mek, m, { from, quoted, prefix, args, reply }) => {
    try {
        if (args.length < 3) {
            return reply(`âŒ Please provide 3 text inputs. Example:\n${prefix}valorant Text1 Text2 Text3`);
        }

        // Extract the three text inputs
        const text1 = args[0];
        const text2 = args[1];
        const text3 = args.slice(2).join(" ");

        // Build the API URL
        const apiUrl = `https://api.nexoracle.com/ephoto360/valorant-youtube-banner?apikey=MepwBcqIM0jYN0okD&text1=${encodeURIComponent(text1)}&text2=${encodeURIComponent(text2)}&text3=${encodeURIComponent(text3)}`;

        // Fetch the logo as a buffer
        const buffer = await getBuffer(apiUrl); // Ensure this gets image data

        // Send the image with the buffer data and include the quoted message if it exists
        const options = quoted ? { quoted: mek } : {};

        // Send the Valorant YouTube banner as an image
        await conn.sendMessage(from, {
            image: buffer, 
            caption: "Here is your Valorant YouTube banner!"
        }, options);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});


const fs = require("fs");
const path = require("path");
const { cmd } = require("../command");

cmd({
    pattern: "ban",
    alias: ["blockuser", "addban"],
    desc: "Ban a user from using the bot",
    category: "owner",
    react: "â›”",
    filename: __filename
}, async (conn, mek, m, { from, args, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_â—Only the bot owner can use this command!_");

        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("âŒ Please provide a number or tag/reply a user.");

        let banned = JSON.parse(fs.readFileSync("./lib/ban.json", "utf-8"));

        if (banned.includes(target)) {
            return reply("âŒ This user is already banned.");
        }

        banned.push(target);
        fs.writeFileSync("./lib/ban.json", JSON.stringify([...new Set(banned)], null, 2));

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/j67u2n.jpg" },
            caption: `â›” User has been banned from using the bot.`
        }, { quoted: mek });

    } catch (err) {
        console.error(err);
        reply("âŒ Error: " + err.message);
    }
});

cmd({
    pattern: "unban",
    alias: ["removeban"],
    desc: "Unban a user",
    category: "owner",
    react: "ğŸ’°",
    filename: __filename
}, async (conn, mek, m, { from, args, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_â—Only the bot owner can use this command!_");

        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("âŒ Please provide a number or tag/reply a user.");

        let banned = JSON.parse(fs.readFileSync("./lib/ban.json", "utf-8"));

        if (!banned.includes(target)) {
            return reply("âŒ This user is not banned.");
        }

        const updated = banned.filter(u => u !== target);
        fs.writeFileSync("./lib/ban.json", JSON.stringify(updated, null, 2));

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/j67u2n.jpg" },
            caption: `âœ… User has been unbanned.`
        }, { quoted: mek });

    } catch (err) {
        console.error(err);
        reply("âŒ Error: " + err.message);
    }
});

cmd({
    pattern: "listban",
    alias: ["banlist", "bannedusers"],
    desc: "List all banned users",
    category: "owner",
    react: "ğŸ“‹",
    filename: __filename
}, async (conn, mek, m, { from, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_â—Only the bot owner can use this command!_");

        let banned = JSON.parse(fs.readFileSync("./lib/ban.json", "utf-8"));
        banned = [...new Set(banned)];

        if (banned.length === 0) return reply("âœ… No banned users found.");

        let msg = "`â›” Banned Users:`\n\n";
        banned.forEach((id, i) => {
            msg += `${i + 1}. ${id.replace("@s.whatsapp.net", "")}\n`;
        });

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/j67u2n.jpg" },
            caption: msg
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("âŒ Error: " + err.message);
    }
});

const config = require('../config')
const { cmd, commands } = require('../command');
const os = require("os")
const {runtime} = require('../lib/functions')
const axios = require('axios')

cmd({
    pattern: "menu2",
    alias: ["allmenu","fullmenu"],
    use: '.menu2',
    desc: "Show all bot commands",
    category: "menu",
    react: "ğŸ“œ",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let dec = `â•­â”â”ã€” ğŸš€ *${config.BOT_NAME}* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‘ *Owner :* ${config.OWNER_NAME}
â”ƒâ—ˆâ”ƒâ€¢ âš™ï¸ *Prefix :* [${config.PREFIX}]
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ *Platform :* vercel
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¦ *Version :* 5.0.0 Pro
â”ƒâ—ˆâ”ƒâ€¢ â±ï¸ *Runtime :* ${runtime(process.uptime())}
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ“¥ *DOWNLOAD MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸŸ¦ facebook
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“ mediafire
â”ƒâ—ˆâ”ƒâ€¢ ğŸµ tiktok
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¦ twitter
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“· insta
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¦ apk
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–¼ï¸ img
â”ƒâ—ˆâ”ƒâ€¢ â–¶ï¸ tt2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“Œ pins
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”„ apk2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”µ fb2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“ pinterest
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¶ spotify
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§ play
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§ play2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”‰ audio
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ video
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¹ video2
â”ƒâ—ˆâ”ƒâ€¢ ğŸµ ytmp3
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¹ ytmp4
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¶ song
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ darama
â”ƒâ—ˆâ”ƒâ€¢ â˜ï¸ gdrive
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ ssweb
â”ƒâ—ˆâ”ƒâ€¢ ğŸµ tiks
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ‘¥ *GROUP MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”— grouplink
â”ƒâ—ˆâ”ƒâ€¢ ğŸšª kickall
â”ƒâ—ˆâ”ƒâ€¢ ğŸš· kickall2
â”ƒâ—ˆâ”ƒâ€¢ ğŸš« kickall3
â”ƒâ—ˆâ”ƒâ€¢ â• add
â”ƒâ—ˆâ”ƒâ€¢ â– remove
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘¢ kick
â”ƒâ—ˆâ”ƒâ€¢ â¬†ï¸ promote
â”ƒâ—ˆâ”ƒâ€¢ â¬‡ï¸ demote
â”ƒâ—ˆâ”ƒâ€¢ ğŸš® dismiss
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”„ revoke
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‹ setgoodbye
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‰ setwelcome
â”ƒâ—ˆâ”ƒâ€¢ ğŸ—‘ï¸ delete
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–¼ï¸ getpic
â”ƒâ—ˆâ”ƒâ€¢ â„¹ï¸ ginfo
â”ƒâ—ˆâ”ƒâ€¢ â³ disappear on
â”ƒâ—ˆâ”ƒâ€¢ â³ disappear off
â”ƒâ—ˆâ”ƒâ€¢ â³ disappear 7D,24H
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“ allreq
â”ƒâ—ˆâ”ƒâ€¢ âœï¸ updategname
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“ updategdesc
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“© joinrequests
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¨ senddm
â”ƒâ—ˆâ”ƒâ€¢ ğŸƒ nikal
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”‡ mute
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”Š unmute
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”’ lockgc
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”“ unlockgc
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“© invite
â”ƒâ—ˆâ”ƒâ€¢ #ï¸âƒ£ tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ·ï¸ hidetag
â”ƒâ—ˆâ”ƒâ€¢ @ï¸âƒ£ tagall
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘” tagadmins
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ­ *REACTIONS MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘Š bully @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤— cuddle @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜¢ cry @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤— hug @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸº awoo @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’‹ kiss @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘… lick @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–ï¸ pat @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜ smug @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”¨ bonk @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸš€ yeet @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜Š blush @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜„ smile @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‹ wave @tag
â”ƒâ—ˆâ”ƒâ€¢ âœ‹ highfive @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤ handhold @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸœ nom @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¦· bite @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤— glomp @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‹ slap @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’€ kill @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜Š happy @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜‰ wink @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‰ poke @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’ƒ dance @tag
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜¬ cringe @tag
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ¨ *LOGO MAKER* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’¡ neonlight
â”ƒâ—ˆâ”ƒâ€¢ ğŸ€ blackpink
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‰ dragonball
â”ƒâ—ˆâ”ƒâ€¢ ğŸ­ 3dcomic
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‡ºğŸ‡¸ america
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¥ naruto
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜¢ sadgirl
â”ƒâ—ˆâ”ƒâ€¢ â˜ï¸ clouds
â”ƒâ—ˆâ”ƒâ€¢ ğŸš€ futuristic
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“œ 3dpaper
â”ƒâ—ˆâ”ƒâ€¢ âœï¸ eraser
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ‡ sunset
â”ƒâ—ˆâ”ƒâ€¢ ğŸƒ leaf
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒŒ galaxy
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’€ sans
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’¥ boom
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’» hacker
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜ˆ devilwings
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‡³ğŸ‡¬ nigeria
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’¡ bulb
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘¼ angelwings
â”ƒâ—ˆâ”ƒâ€¢ â™ˆ zodiac
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’ luxury
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¨ paint
â”ƒâ—ˆâ”ƒâ€¢ â„ï¸ frozen
â”ƒâ—ˆâ”ƒâ€¢ ğŸ° castle
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–‹ï¸ tatoo
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”« valorant
â”ƒâ—ˆâ”ƒâ€¢ ğŸ» bear
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”  typography
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‚ birthday
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ‘‘ *OWNER MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‘ owner
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“œ menu
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“œ menu2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“Š vv
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“‹ listcmd
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“š allmenu
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¦ repo
â”ƒâ—ˆâ”ƒâ€¢ ğŸš« block
â”ƒâ—ˆâ”ƒâ€¢ âœ… unblock
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–¼ï¸ fullpp
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–¼ï¸ setpp
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”„ restart
â”ƒâ—ˆâ”ƒâ€¢ â¹ï¸ shutdown
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”„ updatecmd
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’š alive
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“ ping
â”ƒâ—ˆâ”ƒâ€¢ ğŸ†” gjid
â”ƒâ—ˆâ”ƒâ€¢ ğŸ†” jid
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ‰ *FUN MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤ª shapar
â”ƒâ—ˆâ”ƒâ€¢ â­ rate
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤¬ insult
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’» hack
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’˜ ship
â”ƒâ—ˆâ”ƒâ€¢ ğŸ­ character
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’Œ pickup
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜† joke
â”ƒâ—ˆâ”ƒâ€¢ â¤ï¸ hrt
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜Š hpy
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜” syd
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜  anger
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜³ shy
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’‹ kiss
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§ mon
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜• cunfuzed
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–¼ï¸ setpp
â”ƒâ—ˆâ”ƒâ€¢ âœ‹ hand
â”ƒâ—ˆâ”ƒâ€¢ ğŸƒ nikal
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤² hold
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤— hug
â”ƒâ—ˆâ”ƒâ€¢ ğŸƒ nikal
â”ƒâ—ˆâ”ƒâ€¢ ğŸµ hifi
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‰ poke
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ”„ *CONVERT MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ·ï¸ sticker
â”ƒâ—ˆâ”ƒâ€¢ ğŸ·ï¸ sticker2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜€ emojimix
â”ƒâ—ˆâ”ƒâ€¢ âœ¨ fancy
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–¼ï¸ take
â”ƒâ—ˆâ”ƒâ€¢ ğŸµ tomp3
â”ƒâ—ˆâ”ƒâ€¢ ğŸ—£ï¸ tts
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ trt
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”¢ base64
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”  unbase64
â”ƒâ—ˆâ”ƒâ€¢ 010 binary
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”¤ dbinary
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”— tinyurl
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ urldecode
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ urlencode
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ url
â”ƒâ—ˆâ”ƒâ€¢ ğŸ” repeat
â”ƒâ—ˆâ”ƒâ€¢ â“ ask
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“– readmore
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ¤– *AI MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§  ai
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤– gpt3
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤– gpt2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤– gptmini
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤– gpt
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”µ meta
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¦ blackbox
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒˆ luma
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§ dj
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‘ khan
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤µ jawad
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§  gpt4
â”ƒâ—ˆâ”ƒâ€¢ ğŸ” bing
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¨ imagine
â”ƒâ—ˆâ”ƒâ€¢ ğŸ–¼ï¸ imagine2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤– copilot
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” âš¡ *MAIN MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“ ping
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“ ping2
â”ƒâ—ˆâ”ƒâ€¢ ğŸš€ speed
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¡ live
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’š alive
â”ƒâ—ˆâ”ƒâ€¢ â±ï¸ runtime
â”ƒâ—ˆâ”ƒâ€¢ â³ uptime
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¦ repo
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘‘ owner
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“œ menu
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“œ menu2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”„ restart
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” ğŸ *ANIME MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤¬ fack
â”ƒâ—ˆâ”ƒâ€¢ âœ… truth
â”ƒâ—ˆâ”ƒâ€¢ ğŸ˜¨ dare
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¶ dog
â”ƒâ—ˆâ”ƒâ€¢ ğŸº awoo
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘§ garl
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘° waifu
â”ƒâ—ˆâ”ƒâ€¢ ğŸ± neko
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§™ megnumin
â”ƒâ—ˆâ”ƒâ€¢ ğŸ± neko
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘— maid
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘§ loli
â”ƒâ—ˆâ”ƒâ€¢ ğŸ animegirl
â”ƒâ—ˆâ”ƒâ€¢ ğŸ animegirl1
â”ƒâ—ˆâ”ƒâ€¢ ğŸ animegirl2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ animegirl3
â”ƒâ—ˆâ”ƒâ€¢ ğŸ animegirl4
â”ƒâ—ˆâ”ƒâ€¢ ğŸ animegirl5
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ anime1
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ anime2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ anime3
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ anime4
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ anime5
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“° animenews
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¦Š foxgirl
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¥ naruto
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·

â•­â”â”ã€” â„¹ï¸ *OTHER MENU* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ ğŸ•’ timenow
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“… date
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”¢ count
â”ƒâ—ˆâ”ƒâ€¢ ğŸ§® calculate
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”¢ countx
â”ƒâ—ˆâ”ƒâ€¢ ğŸ² flip
â”ƒâ—ˆâ”ƒâ€¢ ğŸª™ coinflip
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¨ rcolor
â”ƒâ—ˆâ”ƒâ€¢ ğŸ² roll
â”ƒâ—ˆâ”ƒâ€¢ â„¹ï¸ fact
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’» cpp
â”ƒâ—ˆâ”ƒâ€¢ ğŸ² rw
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’‘ pair
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’‘ pair2
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’‘ pair3
â”ƒâ—ˆâ”ƒâ€¢ âœ¨ fancy
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¨ logo <text>
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“– define
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“° news
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¬ movie
â”ƒâ—ˆâ”ƒâ€¢ â˜€ï¸ weather
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¦ srepo
â”ƒâ—ˆâ”ƒâ€¢ ğŸ¤¬ insult
â”ƒâ—ˆâ”ƒâ€¢ ğŸ’¾ save
â”ƒâ—ˆâ”ƒâ€¢ ğŸŒ wikipedia
â”ƒâ—ˆâ”ƒâ€¢ ğŸ”‘ gpass
â”ƒâ—ˆâ”ƒâ€¢ ğŸ‘¤ githubstalk
â”ƒâ—ˆâ”ƒâ€¢ ğŸ” yts
â”ƒâ—ˆâ”ƒâ€¢ ğŸ“¹ ytv
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`;

        await conn.sendMessage(
            from,
            {
                image: { url: config.MENU_IMAGE_URL || 'https://files.catbox.moe/37xk9g.jpg' },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: config.BOT_NAME,
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

        // Send audio
        await conn.sendMessage(from, {
            audio: { url: 'https://github.com/criss-vevo/CRISS-DATA/raw/refs/heads/main/autovoice/menunew.m4a' },
            mimetype: 'audio/mp4',
            ptt: true
        }, { quoted: mek });
        
    } catch (e) {
        console.log(e);
        reply(`âŒ Error: ${e}`);
    }
});



const fetch = require('node-fetch');
const config = require('../config');    
const { cmd } = require('../command');

cmd({
    pattern: "repo",
    alias: ["sc", "script", "info"],
    desc: "Fetch information about a GitHub repository.",
    react: "ğŸ“‚",
    category: "info",
    filename: __filename,
},
async (conn, mek, m, { from, reply }) => {
    const githubRepoURL = 'https://github.com/lovertoxic/TOXIC-LOVER-V2-XMD';

    try {
        // Extract username and repo name from the URL
        const [, username, repoName] = githubRepoURL.match(/github\.com\/([^/]+)\/([^/]+)/);

        // Fetch repository details using GitHub API
        const response = await fetch(`https://api.github.com/repos/${username}/${repoName}`);
        
        if (!response.ok) {
            throw new Error(`GitHub API request failed with status ${response.status}`);
        }

        const repoData = await response.json();

        // Format the repository information
        const formattedInfo = `*BOT NAME:* *${repoData.name}*\n\n*OWNER NAME:* *${repoData.owner.login}*\n\n*STARS:* *${repoData.stargazers_count}*\n\n*FORKS:* *${repoData.forks_count}*\n\n*GITHUB LINK:*\n> ${repoData.html_url}\n\n*DESCRIPTION:*\n> ${repoData.description || 'No description'}\n\n*Don't Forget To Star and Fork Repository*\n\n> *Â© Powered By sir bravin ğŸ–¤*`;

        // Send an image with the formatted info as a caption and context info
        await conn.sendMessage(from, {
            image: { url: `https://files.catbox.moe/fbm1sw.jpg` },
            caption: formattedInfo,
            contextInfo: { 
                mentionedJid: [m.sender],
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363366284524544@newsletter',
                    newsletterName: 'sir bravin',
                    serverMessageId: 143
                }
            }
        }, { quoted: mek });

        // Send the audio file with context info
        await conn.sendMessage(from, {
            audio: { url: 'https://files.catbox.moe/iq4ouj.mp3' },
            mimetype: 'audio/mp4',
            ptt: true,
            contextInfo: { 
                mentionedJid: [m.sender],
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '.120363366284524544@newsletter',
                    newsletterName: 'sir bravin',
                    serverMessageId: 143
                }
            }
        }, { quoted: mek });

    } catch (error) {
        console.error("Error in repo command:", error);
        reply("Sorry, something went wrong while fetching the repository information. Please try again later.");
    }
});

const fs = require("fs");
const path = require("path");
const { cmd } = require("../command");

const OWNER_PATH = path.join(__dirname, "../lib/sudo.json");

// Ensure the sudo.json file exists
const ensureOwnerFile = () => {
  if (!fs.existsSync(OWNER_PATH)) {
    fs.writeFileSync(OWNER_PATH, JSON.stringify([]));
  }
};

// Command: Add a temporary owner
cmd({
    pattern: "setsudo",
    alias: ["addsudo", "addowner"],
    desc: "Add a temporary owner",
    category: "owner",
    react: "ğŸ˜‡",
    filename: __filename
}, async (conn, mek, m, { from, args, q, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_â—This Command Can Only Be Used By My Owner!_");

        // Identify the target user
        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("âŒ Please provide a number or tag/reply a user.");

        let owners = JSON.parse(fs.readFileSync(OWNER_PATH, "utf-8"));

        if (owners.includes(target)) {
            return reply("âŒ This user is already a temporary owner.");
        }

        owners.push(target);
        const uniqueOwners = [...new Set(owners)];
        fs.writeFileSync(OWNER_PATH, JSON.stringify(uniqueOwners, null, 2));

        const successMsg = "âœ… Successfully Added User As Temporary Owner";
        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/m2s3cg.jpg" },
            caption: successMsg
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("âŒ Error: " + err.message);
    }
});

// Command: Remove a temporary owner
cmd({
    pattern: "delsudo",
    alias: ["delowner", "deletesudo"],
    desc: "Remove a temporary owner",
    category: "owner",
    react: "ğŸ«©",
    filename: __filename
}, async (conn, mek, m, { from, args, q, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_â—This Command Can Only Be Used By My Owner!_");

        let target = m.mentionedJid?.[0] 
            || (m.quoted?.sender ?? null)
            || (args[0]?.replace(/[^0-9]/g, '') + "@s.whatsapp.net");

        if (!target) return reply("âŒ Please provide a number or tag/reply a user.");

        let owners = JSON.parse(fs.readFileSync(OWNER_PATH, "utf-8"));

        if (!owners.includes(target)) {
            return reply("âŒ User not found in owner list.");
        }

        const updated = owners.filter(x => x !== target);
        fs.writeFileSync(OWNER_PATH, JSON.stringify(updated, null, 2));

        const successMsg = "âœ… Successfully Removed User As Temporary Owner";
        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/m2s3cg.jpg" },
            caption: successMsg
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("âŒ Error: " + err.message);
    }
});

// Command: List all temporary owners
cmd({
    pattern: "listsudo",
    alias: ["listowner"],
    desc: "List all temporary owners",
    category: "owner",
    react: "ğŸ“‹",
    filename: __filename
}, async (conn, mek, m, { from, isCreator, reply }) => {
    try {
        if (!isCreator) return reply("_â—This Command Can Only Be Used By My Owner!_");

        let owners = JSON.parse(fs.readFileSync(OWNER_PATH, "utf-8"));
        owners = [...new Set(owners)];

        if (owners.length === 0) {
            return reply("âŒ No temporary owners found.");
        }

        let listMessage = "`ğŸ¤´ List of Sudo Owners:`\n\n";
        owners.forEach((owner, i) => {
            listMessage += `${i + 1}. ${owner.replace("@s.whatsapp.net", "")}\n`;
        });

        await conn.sendMessage(from, {
            image: { url: "https://files.catbox.moe/m2s3cg.jpg" },
            caption: listMessage
        }, { quoted: mek });
    } catch (err) {
        console.error(err);
        reply("âŒ Error: " + err.message);
    }
});
                

const { cmd } = require("../command");
const axios = require('axios');
const fs = require('fs');
const path = require("path");
const AdmZip = require("adm-zip");
const { setCommitHash, getCommitHash } = require('../data/updateDB');

cmd({
    pattern: "update",
    alias: ["upgrade", "sync"],
    react: 'â¤ï¸â€ğŸ”¥',
    desc: "Update the bot to the latest version.",
    category: "misc",
    filename: __filename
}, async (client, message, args, { reply, isOwner }) => {
    if (!isOwner) return reply("This command is only for the bot owner.");

    try {
        await reply("ğŸ” Checking for toxic lover-v2 xmd updates...");

        // Fetch the latest commit hash from GitHub
        const { data: commitData } = await axios.get("https://api.github.com/repos/criss-vevo/CRISS-AI/commits/main");
        const latestCommitHash = commitData.sha;

        // Get the stored commit hash from the database
        const currentHash = await getCommitHash();

        if (latestCommitHash === currentHash) {
            return reply("âœ… Your toxic lover-v2 xmd bot is already up-to-date!");
        }

        await reply("ğŸš€ Updating toxic lover-v2 xmd Bot...");

        // Download the latest code
        const zipPath = path.join(__dirname, "latest.zip");
        const { data: zipData } = await axios.get("https://github.com/criss-vevo/CRISS-AI/archive/main.zip", { responseType: "arraybuffer" });
        fs.writeFileSync(zipPath, zipData);

        // Extract ZIP file
        await reply("ğŸ“¦ Extracting the latest code...");
        const extractPath = path.join(__dirname, 'latest');
        const zip = new AdmZip(zipPath);
        zip.extractAllTo(extractPath, true);

        // Copy updated files, preserving config.js and app.json
        await reply("ğŸ”„ Replacing files...");
        const sourcePath = path.join(extractPath, "TOXIC LOVER-V2 XMD-main");
        const destinationPath = path.join(__dirname, '..');
        copyFolderSync(sourcePath, destinationPath);

        // Save the latest commit hash to the database
        await setCommitHash(latestCommitHash);

        // Cleanup
        fs.unlinkSync(zipPath);
        fs.rmSync(extractPath, { recursive: true, force: true });

        await reply("âœ… Update complete! Restarting the bot...");
        process.exit(0);
    } catch (error) {
        console.error("Update error:", error);
        return reply("âŒ Update failed. Please try manually.");
    }
});

// Helper function to copy directories while preserving config.js and app.json
function copyFolderSync(source, target) {
    if (!fs.existsSync(target)) {
        fs.mkdirSync(target, { recursive: true });
    }

    const items = fs.readdirSync(source);
    for (const item of items) {
        const srcPath = path.join(source, item);
        const destPath = path.join(target, item);

        // Skip config.js and app.json
        if (item === "config.js" || item === "app.json") {
            console.log(`Skipping ${item} to preserve custom settings.`);
            continue;
        }

        if (fs.lstatSync(srcPath).isDirectory()) {
            copyFolderSync(srcPath, destPath);
        } else {
            fs.copyFileSync(srcPath, destPath);
        }
    }
}

//---------------------------------------------------------------------------
//           TOZIC LOVER-V2 XMD  
//---------------------------------------------------------------------------
//  âš ï¸ DO NOT MODIFY THIS FILE âš ï¸  
//---------------------------------------------------------------------------
const { cmd, commands } = require('../command');
const config = require('../config');
const prefix = config.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');
const { writeFileSync } = require('fs');
const path = require('path');

cmd({
    pattern: "admin-events",
    alias: ["adminevents"],
    desc: "Enable or disable admin event notifications",
    category: "settings",
    filename: __filename
},
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ¦  á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    if (status === "on") {
        config.ADMIN_EVENTS = "true";
        return reply("âœ… Admin event notifications are now enabled.");
    } else if (status === "off") {
        config.ADMIN_EVENTS = "false";
        return reply("âŒ Admin event notifications are now disabled.");
    } else {
        return reply(`Example: .admin-events on`);
    }
});

cmd({
    pattern: "welcome",
    alias: ["welcomeset"],
    desc: "Enable or disable welcome messages for new members",
    category: "settings",
    filename: __filename
},
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    if (status === "on") {
        config.WELCOME = "true";
        return reply("âœ… Welcome messages are now enabled.");
    } else if (status === "off") {
        config.WELCOME = "false";
        return reply("âŒ Welcome messages are now disabled.");
    } else {
        return reply(`Example: .welcome on`);
    }
});

cmd({
    pattern: "setprefix",
    alias: ["prefix"],
    react: "ğŸ”§",
    desc: "Change the bot's command prefix.",
    category: "settings",
    filename: __filename,
}, async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› Only the owner can use this command!*");

    const newPrefix = args[0]; // Get the new prefix from the command arguments
    if (!newPrefix) return reply("âŒ Please provide a new prefix. Example: `.setprefix !`");

    // Update the prefix in memory
    config.PREFIX = newPrefix;

    return reply(`âœ… Prefix successfully changed to *${newPrefix}*`);
});

cmd({
    pattern: "mode",
    alias: ["setmode"],
    react: "ğŸ«Ÿ",
    desc: "Set bot mode to private or public.",
    category: "settings",
    filename: __filename,
}, async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› Only the owner can use this command!*");

    // Si aucun argument n'est fourni, afficher le mode actuel et l'usage
    if (!args[0]) {
        return reply(`ğŸ“Œ Current mode: *${config.MODE}*\n\nUsage: .mode private OR .mode public`);
    }

    const modeArg = args[0].toLowerCase();

    if (modeArg === "private") {
        config.MODE = "private";
        return reply("âœ… Bot mode is now set to *PRIVATE*.");
    } else if (modeArg === "public") {
        config.MODE = "public";
        return reply("âœ… Bot mode is now set to *PUBLIC*.");
    } else {
        return reply("âŒ Invalid mode. Please use `.mode private` or `.mode public`.");
    }
});

cmd({
    pattern: "auto-typing",
    description: "Enable or disable auto-typing feature.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    if (!["on", "off"].includes(status)) {
        return reply("*ğŸ«Ÿ á´‡xá´€á´á´˜ÊŸá´‡:  .á´€á´œá´›á´-á´›Êá´˜ÉªÉ´É¢ á´É´*");
    }

    config.AUTO_TYPING = status === "on" ? "true" : "false";
    return reply(`Auto typing has been turned ${status}.`);
});

//mention reply 


cmd({
    pattern: "mention-reply",
    alias: ["menetionreply", "mee"],
    description: "Set bot status to always online or offline.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.MENTION_REPLY = "true";
        return reply("Mention Reply feature is now enabled.");
    } else if (args[0] === "off") {
        config.MENTION_REPLY = "false";
        return reply("Mention Reply feature is now disabled.");
    } else {
        return reply(`_example:  .mee on_`);
    }
});


//--------------------------------------------
// ALWAYS_ONLINE COMMANDS
//--------------------------------------------
cmd({
    pattern: "always-online",
    alias: ["alwaysonline"],
    desc: "Enable or disable the always online mode",
    category: "settings",
    filename: __filename
},
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    if (status === "on") {
        config.ALWAYS_ONLINE = "true";
        await reply("*âœ… always online mode is now enabled.*");
    } else if (status === "off") {
        config.ALWAYS_ONLINE = "false";
        await reply("*âŒ always online mode is now disabled.*");
    } else {
        await reply(`*ğŸ› ï¸ á´‡xá´€á´á´˜ÊŸá´‡: .á´€ÊŸá´¡á´€Ês-á´É´ÊŸÉªÉ´á´‡ á´É´*`);
    }
});

//--------------------------------------------
//  AUTO_RECORDING COMMANDS
//--------------------------------------------
cmd({
    pattern: "auto-recording",
    alias: ["autorecoding"],
    description: "Enable or disable auto-recording feature.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    if (!["on", "off"].includes(status)) {
        return reply("*ğŸ«Ÿ á´‡xá´€á´á´˜ÊŸá´‡: .á´€á´œá´›á´-Ê€á´‡á´„á´Ê€á´…ÉªÉ´É¢ á´É´*");
    }

    config.AUTO_RECORDING = status === "on" ? "true" : "false";
    if (status === "on") {
        await conn.sendPresenceUpdate("recording", from);
        return reply("Auto recording is now enabled. Bot is recording...");
    } else {
        await conn.sendPresenceUpdate("available", from);
        return reply("Auto recording has been disabled.");
    }
});
//--------------------------------------------
// AUTO_VIEW_STATUS COMMANDS
//--------------------------------------------
cmd({
    pattern: "auto-seen",
    alias: ["autostatusview"],
    desc: "Enable or disable auto-viewing of statuses",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Default value for AUTO_VIEW_STATUS is "false"
    if (args[0] === "on") {
        config.AUTO_STATUS_SEEN = "true";
        return reply("Auto-viewing of statuses is now enabled.");
    } else if (args[0] === "off") {
        config.AUTO_STATUS_SEEN = "false";
        return reply("Auto-viewing of statuses is now disabled.");
    } else {
        return reply(`*ğŸ«Ÿ á´‡xá´€á´á´˜ÊŸá´‡:  .á´€á´œá´›á´-sá´‡á´‡É´ á´É´*`);
    }
}); 
//--------------------------------------------
// AUTO_LIKE_STATUS COMMANDS
//--------------------------------------------
cmd({
    pattern: "status-react",
    alias: ["statusreaction"],
    desc: "Enable or disable auto-liking of statuses",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Default value for AUTO_LIKE_STATUS is "false"
    if (args[0] === "on") {
        config.AUTO_STATUS_REACT = "true";
        return reply("Auto-liking of statuses is now enabled.");
    } else if (args[0] === "off") {
        config.AUTO_STATUS_REACT = "false";
        return reply("Auto-liking of statuses is now disabled.");
    } else {
        return reply(`Example: . status-react on`);
    }
});

//--------------------------------------------
//  READ-MESSAGE COMMANDS
//--------------------------------------------
cmd({
    pattern: "read-message",
    alias: ["autoread"],
    desc: "enable or disable readmessage.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.READ_MESSAGE = "true";
        return reply("readmessage feature is now enabled.");
    } else if (args[0] === "off") {
        config.READ_MESSAGE = "false";
        return reply("readmessage feature is now disabled.");
    } else {
        return reply(`_example:  .readmessage on_`);
    }
});

// AUTO_VOICE

cmd({
    pattern: "auto-voice",
    alias: ["autovoice"],
    desc: "enable or disable readmessage.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTO_VOICE = "true";
        return reply("AUTO_VOICE feature is now enabled.");
    } else if (args[0] === "off") {
        config.AUTO_VOICE = "false";
        return reply("AUTO_VOICE feature is now disabled.");
    } else {
        return reply(`_example:  .autovoice on_`);
    }
});


//--------------------------------------------
//  ANI-BAD COMMANDS
//--------------------------------------------
cmd({
    pattern: "anti-bad",
    alias: ["antibadword"],
    desc: "enable or disable antibad.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.ANTI_BAD_WORD = "true";
        return reply("*anti bad word is now enabled.*");
    } else if (args[0] === "off") {
        config.ANTI_BAD_WORD = "false";
        return reply("*anti bad word feature is now disabled*");
    } else {
        return reply(`_example:  .antibad on_`);
    }
});
//--------------------------------------------
//  AUTO-STICKER COMMANDS
//--------------------------------------------
cmd({
    pattern: "auto-sticker",
    alias: ["autosticker"],
    desc: "enable or disable auto-sticker.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTO_STICKER = "true";
        return reply("auto-sticker feature is now enabled.");
    } else if (args[0] === "off") {
        config.AUTO_STICKER = "false";
        return reply("auto-sticker feature is now disabled.");
    } else {
        return reply(`_example:  .auto-sticker on_`);
    }
});
//--------------------------------------------
//  AUTO-REPLY COMMANDS
//--------------------------------------------
cmd({
    pattern: "auto-reply",
    alias: ["autoreply"],
    desc: "enable or disable auto-reply.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTO_REPLY = "true";
        return reply("*auto-reply  is now enabled.*");
    } else if (args[0] === "off") {
        config.AUTO_REPLY = "false";
        return reply("auto-reply feature is now disabled.");
    } else {
        return reply(`*ğŸ«Ÿ á´‡xá´€á´á´˜ÊŸá´‡: . á´€á´œá´›á´-Ê€á´‡á´˜ÊŸÊ á´É´*`);
    }
});

//--------------------------------------------
//   AUTO-REACT COMMANDS
//--------------------------------------------
cmd({
    pattern: "auto-react",
    alias: ["autoreact"],
    desc: "Enable or disable the autoreact feature",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTO_REACT = "true";
        await reply("*autoreact feature is now enabled.*");
    } else if (args[0] === "off") {
        config.AUTO_REACT = "false";
        await reply("autoreact feature is now disabled.");
    } else {
        await reply(`*ğŸ«Ÿ á´‡xá´€á´á´˜ÊŸá´‡: .á´€á´œá´›á´-Ê€á´‡á´€á´„á´› á´É´*`);
    }
});
//--------------------------------------------
//  STATUS-REPLY COMMANDS
//--------------------------------------------
cmd({
    pattern: "status-reply",
    alias: ["autostatusreply"],
    desc: "enable or disable status-reply.",
    category: "settings",
    filename: __filename
},    
async (conn, mek, m, { from, args, isCreator, reply }) => {
    if (!isCreator) return reply("*ğŸ“› á´É´ÊŸÊ á´›Êœá´‡ á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´…!*");

    const status = args[0]?.toLowerCase();
    // Check the argument for enabling or disabling the anticall feature
    if (args[0] === "on") {
        config.AUTO_STATUS_REPLY = "true";
        return reply("status-reply feature is now enabled.");
    } else if (args[0] === "off") {
        config.AUTO_STATUS_REPLY = "false";
        return reply("status-reply feature is now disabled.");
    } else {
        return reply(`*ğŸ«Ÿ á´‡xá´€á´á´˜ÊŸá´‡:  .sá´›á´€á´›á´œs-Ê€á´‡á´˜ÊŸÊ á´É´*`);
    }
});

//--------------------------------------------
//  ANTILINK COMMANDS
//--------------------------------------------

cmd({
  pattern: "antilink",
  alias: ["antilinks"],
  desc: "Enable or disable ANTI_LINK in groups",
  category: "group",
  react: "ğŸš«",
  filename: __filename
}, async (conn, mek, m, { isGroup, isAdmins, isBotAdmins, args, reply }) => {
  try {
    if (!isGroup) return reply('This command can only be used in a group.');
    if (!isBotAdmins) return reply('Bot must be an admin to use this command.');
    if (!isAdmins) return reply('You must be an admin to use this command.');

    if (args[0] === "on") {
      config.ANTI_LINK = "true";
      reply("âœ… ANTI_LINK has been enabled.");
    } else if (args[0] === "off") {
      config.ANTI_LINK = "false";
      reply("âŒ ANTI_LINK has been disabled.");
    } else {
      reply("Usage: *.antilink on/off*");
    }
  } catch (e) {
    reply(`Error: ${e.message}`);
  }
});

cmd({
  pattern: "antilinkkick",
  alias: ["kicklink"],
  desc: "Enable or disable ANTI_LINK_KICK in groups",
  category: "group",
  react: "âš ï¸",
  filename: __filename
}, async (conn, mek, m, { isGroup, isAdmins, isBotAdmins, args, reply }) => {
  try {
    if (!isGroup) return reply('This command can only be used in a group.');
    if (!isBotAdmins) return reply('Bot must be an admin to use this command.');
    if (!isAdmins) return reply('You must be an admin to use this command.');

    if (args[0] === "on") {
      config.ANTI_LINK_KICK = "true";
      reply("âœ… ANTI_LINK_KICK has been enabled.");
    } else if (args[0] === "off") {
      config.ANTI_LINK_KICK = "false";
      reply("âŒ ANTI_LINK_KICK has been disabled.");
    } else {
      reply("Usage: *.antilinkkick on/off*");
    }
  } catch (e) {
    reply(`Error: ${e.message}`);
  }
});


cmd({
  pattern: "deletelink",
  alias: ["linksdelete"],
  desc: "Enable or disable DELETE_LINKS in groups",
  category: "group",
  react: "âŒ",
  filename: __filename
}, async (conn, mek, m, { isGroup, isAdmins, isBotAdmins, args, reply }) => {
  try {
    if (!isGroup) return reply('This command can only be used in a group.');
    if (!isBotAdmins) return reply('Bot must be an admin to use this command.');
    if (!isAdmins) return reply('You must be an admin to use this command.');

    if (args[0] === "on") {
      config.DELETE_LINKS = "true";
      reply("âœ… DELETE_LINKS is now enabled.");
    } else if (args[0] === "off") {
      config.DELETE_LINKS = "false";
      reply("âŒ DELETE_LINKS is now disabled.");
    } else {
      reply("Usage: *.deletelink on/off*");
    }
  } catch (e) {
    reply(`Error: ${e.message}`);
  }
});

const config = require('../config');
const { cmd } = require('../command');
const axios = require('axios');

cmd({
  on: "body"
}, async (conn, m, { isGroup }) => {
  try {
    if (config.MENTION_REPLY !== 'true' || !isGroup) return;
    if (!m.mentionedJid || m.mentionedJid.length === 0) return;

    const voiceClips = [
      "https://cdn.ironman.my.id/i/7p5plg.mp4",
      "https://cdn.ironman.my.id/i/l4dyvg.mp4",
      "https://cdn.ironman.my.id/i/4z93dg.mp4",
      "https://cdn.ironman.my.id/i/m9gwk0.mp4",
      "https://cdn.ironman.my.id/i/gr1jjc.mp4",
      "https://cdn.ironman.my.id/i/lbr8of.mp4",
      "https://cdn.ironman.my.id/i/0z95mz.mp4",
      "https://cdn.ironman.my.id/i/rldpwy.mp4",
      "https://cdn.ironman.my.id/i/lz2z87.mp4",
      "https://cdn.ironman.my.id/i/gg5jct.mp4"
    ];

    const randomClip = voiceClips[Math.floor(Math.random() * voiceClips.length)];
    const botNumber = conn.user.id.split(":")[0] + '@s.whatsapp.net';

    if (m.mentionedJid.includes(botNumber)) {
      const thumbnailRes = await axios.get(config.MENU_IMAGE_URL || "https://files.catbox.moe/wp4qci.jpg", {
        responseType: 'arraybuffer'
      });
      const thumbnailBuffer = Buffer.from(thumbnailRes.data, 'binary');

      await conn.sendMessage(m.chat, {
        audio: { url: randomClip },
        mimetype: 'audio/mp4',
        ptt: true,
        waveform: [99, 0, 99, 0, 99],
        contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          externalAdReply: {
            title: config.BOT_NAME || "CRISS-AI ğŸ¥€",
            body: config.DESCRIPTION || "POWERED BY sir bravin ğŸ¤ŒğŸ’—",
            mediaType: 1,
            renderLargerThumbnail: true,
            thumbnail: thumbnailBuffer,
            mediaUrl: "https://files.catbox.moe/4ggu0a.jpg", // Static image URL
            sourceUrl: "https://whatsapp.com/channel/0029VawCel7GOj9ktLjkxQ3g",
            showAdAttribution: true
          }
        }
      }, { quoted: m });
    }
  } catch (e) {
    console.error(e);
    const ownerJid = conn.user.id.split(":")[0] + "@s.whatsapp.net";
    await conn.sendMessage(ownerJid, {
      text: `*Bot Error in Mention Handler:*\n${e.message}`
    });
  }
});

const config = require('../config');
const { cmd, commands } = require('../command');
const os = require("os");
const { runtime } = require('../lib/functions');

cmd({
    pattern: "menu",
    desc: "Show interactive menu system",
    category: "menu",
    react: "ğŸ”¥",
    filename: __filename
}, async (conn, mek, m, { from, reply }) => {
    try {
        // Show loading reaction
        await conn.sendMessage(from, {
            react: { text: 'ğŸ”¥', key: mek.key }
        });

        const menuCaption = `â•­â”â”â”ã€” *${config.BOT_NAME}* ã€•â”â”â”â”ˆâŠ·
â”ƒâˆ†â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâˆ†â”‚  *Owner :* ${config.OWNER_NAME}
â”ƒâˆ†â”‚  *Baileys :* Multi Device
â”ƒâˆ†â”‚  *Type :* NodeJs
â”ƒâˆ†â”‚  *Made:in Tanzania/dodoma
â”ƒâˆ†â”‚  *Platform :* vercel
â”ƒâˆ†â”‚  *Mode :* [${config.MODE}]
â”ƒâˆ†â”‚  *Prefix :* [${config.PREFIX}]
â”ƒâˆ†â”‚  *Version :* 5.0.0 max
â”ƒâˆ†â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
â•­â”â”ã€” *Menu List* ã€•â”â”â”ˆâŠ·
â”ƒâˆ†â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâˆ†â”‚1ï¸âƒ£   *Download Menu*
â”ƒâˆ†â”‚2ï¸âƒ£   *Group Menu*
â”ƒâˆ†â”‚3ï¸âƒ£   *Fun Menu*
â”ƒâˆ†â”‚4ï¸âƒ£   *Owner Menu*
â”ƒâˆ†â”‚5ï¸âƒ£   *AI Menu*
â”ƒâˆ†â”‚6ï¸âƒ£   *Anime Menu*
â”ƒâˆ†â”‚7ï¸âƒ£   *Convert Menu*
â”ƒâˆ†â”‚8ï¸âƒ£   *Other Menu*
â”ƒâˆ†â”‚9ï¸âƒ£   *Reactions Menu*
â”ƒâˆ†â”‚ğŸ”Ÿ   *Main Menu*
â”ƒâ—ˆâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â”ƒâ—ˆreply to these menu with number form 1-10 
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
> ${config.DESCRIPTION}`;

        const contextInfo = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
                newsletterJid: '120363420222821450@newsletter',
                newsletterName: config.OWNER_NAME,
                serverMessageId: 143
            }
        };

        const sentMsg = await conn.sendMessage(
            from,
            {
                image: { url: config.MENU_IMAGE_URL || 'https://files.catbox.moe/3t363j.jpg' },
                caption: menuCaption,
                contextInfo: contextInfo
            },
            { quoted: mek }
        );

        // Send menu audio only once
        await conn.sendMessage(from, {
            audio: { url: 'https://files.catbox.moe/rgmwzs.mp3' },
            mimetype: 'audio/mp4',
            ptt: true,       
        }, { quoted: mek });

        const messageID = sentMsg.key.id;

        // Complete menu data
        const menuData = {
            '1': {
                title: "ğŸ“¥ *Download Menu* ğŸ“¥",
                content: `â•­â”â”â”ã€” *Download Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸŒ *Social Media*
â”ƒâ˜…â”‚ â€¢ facebook [url]
â”ƒâ˜…â”‚ â€¢ mediafire [url]
â”ƒâ˜…â”‚ â€¢ tiktok [url]
â”ƒâ˜…â”‚ â€¢ twitter [url]
â”ƒâ˜…â”‚ â€¢ Insta [url]
â”ƒâ˜…â”‚ â€¢ apk [app]
â”ƒâ˜…â”‚ â€¢ img [query]
â”ƒâ˜…â”‚ â€¢ tt2 [url]
â”ƒâ˜…â”‚ â€¢ pins [url]
â”ƒâ˜…â”‚ â€¢ apk2 [app]
â”ƒâ˜…â”‚ â€¢ fb2 [url]
â”ƒâ˜…â”‚ â€¢ pinterest [url]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸµ *Music/Video*
â”ƒâ˜…â”‚ â€¢ spotify [query]
â”ƒâ˜…â”‚ â€¢ play [song]
â”ƒâ˜…â”‚ â€¢ play2-10 [song]
â”ƒâ˜…â”‚ â€¢ audio [url]
â”ƒâ˜…â”‚ â€¢ video [url]
â”ƒâ˜…â”‚ â€¢ video2-10 [url]
â”ƒâ˜…â”‚ â€¢ ytmp3 [url]
â”ƒâ˜…â”‚ â€¢ ytmp4 [url]
â”ƒâ˜…â”‚ â€¢ song [name]
â”ƒâ˜…â”‚ â€¢ darama [name]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '2': {
                title: "ğŸ‘¥ *Group Menu* ğŸ‘¥",
                content: `â•­â”â”â”ã€” *Group Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ› ï¸ *Management*
â”ƒâ˜…â”‚ â€¢ grouplink
â”ƒâ˜…â”‚ â€¢ kickall
â”ƒâ˜…â”‚ â€¢ kickall2
â”ƒâ˜…â”‚ â€¢ kickall3
â”ƒâ˜…â”‚ â€¢ add @user
â”ƒâ˜…â”‚ â€¢ remove @user
â”ƒâ˜…â”‚ â€¢ kick @user
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ âš¡ *Admin Tools*
â”ƒâ˜…â”‚ â€¢ promote @user
â”ƒâ˜…â”‚ â€¢ demote @user
â”ƒâ˜…â”‚ â€¢ dismiss 
â”ƒâ˜…â”‚ â€¢ revoke
â”ƒâ˜…â”‚ â€¢ mute [time]
â”ƒâ˜…â”‚ â€¢ unmute
â”ƒâ˜…â”‚ â€¢ lockgc
â”ƒâ˜…â”‚ â€¢ unlockgc
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ·ï¸ *Tagging*
â”ƒâ˜…â”‚ â€¢ tag @user
â”ƒâ˜…â”‚ â€¢ hidetag [msg]
â”ƒâ˜…â”‚ â€¢ tagall
â”ƒâ˜…â”‚ â€¢ tagadmins
â”ƒâ˜…â”‚ â€¢ invite
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '3': {
                title: "ğŸ˜„ *Fun Menu* ğŸ˜„",
                content: `â•­â”â”â”ã€” *Fun Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ­ *Interactive*
â”ƒâ˜…â”‚ â€¢ shapar
â”ƒâ˜…â”‚ â€¢ rate @user
â”ƒâ˜…â”‚ â€¢ insult @user
â”ƒâ˜…â”‚ â€¢ hack @user
â”ƒâ˜…â”‚ â€¢ ship @user1 @user2
â”ƒâ˜…â”‚ â€¢ character
â”ƒâ˜…â”‚ â€¢ pickup
â”ƒâ˜…â”‚ â€¢ joke
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ˜‚ *Reactions*
â”ƒâ˜…â”‚ â€¢ hrt
â”ƒâ˜…â”‚ â€¢ hpy
â”ƒâ˜…â”‚ â€¢ syd
â”ƒâ˜…â”‚ â€¢ anger
â”ƒâ˜…â”‚ â€¢ shy
â”ƒâ˜…â”‚ â€¢ kiss
â”ƒâ˜…â”‚ â€¢ mon
â”ƒâ˜…â”‚ â€¢ cunfuzed
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '4': {
                title: "ğŸ‘‘ *Owner Menu* ğŸ‘‘",
                content: `â•­â”â”â”ã€” *Owner Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ âš ï¸ *Restricted*
â”ƒâ˜…â”‚ â€¢ block @user
â”ƒâ˜…â”‚ â€¢ unblock @user
â”ƒâ˜…â”‚ â€¢ fullpp [img]
â”ƒâ˜…â”‚ â€¢ setpp [img]
â”ƒâ˜…â”‚ â€¢ restart
â”ƒâ˜…â”‚ â€¢ shutdown
â”ƒâ˜…â”‚ â€¢ updatecmd
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ â„¹ï¸ *Info Tools*
â”ƒâ˜…â”‚ â€¢ gjid
â”ƒâ˜…â”‚ â€¢ jid @user
â”ƒâ˜…â”‚ â€¢ listcmd
â”ƒâ˜…â”‚ â€¢ allmenu
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '5': {
                title: "ğŸ¤– *AI Menu* ğŸ¤–",
                content: `â•­â”â”â”ã€” *AI Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ’¬ *Chat AI*
â”ƒâ˜…â”‚ â€¢ ai [query]
â”ƒâ˜…â”‚ â€¢ gpt3 [query]
â”ƒâ˜…â”‚ â€¢ gpt2 [query]
â”ƒâ˜…â”‚ â€¢ gptmini [query]
â”ƒâ˜…â”‚ â€¢ gpt [query]
â”ƒâ˜…â”‚ â€¢ meta [query]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ–¼ï¸ *Image AI*
â”ƒâ˜…â”‚ â€¢ imagine [text]
â”ƒâ˜…â”‚ â€¢ imagine2 [text]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ” *Specialized*
â”ƒâ˜…â”‚ â€¢ blackbox [query]
â”ƒâ˜…â”‚ â€¢ luma [query]
â”ƒâ˜…â”‚ â€¢ dj [query]
â”ƒâ˜…â”‚ â€¢ khan [query]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '6': {
                title: "ğŸ *Anime Menu* ğŸ",
                content: `â•­â”â”â”ã€” *Anime Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ–¼ï¸ *Images*
â”ƒâ˜…â”‚ â€¢ fack
â”ƒâ˜…â”‚ â€¢ dog
â”ƒâ˜…â”‚ â€¢ awoo
â”ƒâ˜…â”‚ â€¢ garl
â”ƒâ˜…â”‚ â€¢ waifu
â”ƒâ˜…â”‚ â€¢ neko
â”ƒâ˜…â”‚ â€¢ megnumin
â”ƒâ˜…â”‚ â€¢ maid
â”ƒâ˜…â”‚ â€¢ loli
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ­ *Characters*
â”ƒâ˜…â”‚ â€¢ animegirl
â”ƒâ˜…â”‚ â€¢ animegirl1-5
â”ƒâ˜…â”‚ â€¢ anime1-5
â”ƒâ˜…â”‚ â€¢ foxgirl
â”ƒâ˜…â”‚ â€¢ naruto
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '7': {
                title: "ğŸ”„ *Convert Menu* ğŸ”„",
                content: `â•­â”â”â”ã€” *Convert Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ–¼ï¸ *Media*
â”ƒâ˜…â”‚ â€¢ sticker [img]
â”ƒâ˜…â”‚ â€¢ sticker2 [img]
â”ƒâ˜…â”‚ â€¢ emojimix ğŸ˜+ğŸ˜‚
â”ƒâ˜…â”‚ â€¢ take [name,text]
â”ƒâ˜…â”‚ â€¢ tomp3 [video]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ“ *Text*
â”ƒâ˜…â”‚ â€¢ fancy [text]
â”ƒâ˜…â”‚ â€¢ tts [text]
â”ƒâ˜…â”‚ â€¢ trt [text]
â”ƒâ˜…â”‚ â€¢ base64 [text]
â”ƒâ˜…â”‚ â€¢ unbase64 [text]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '8': {
                title: "ğŸ“Œ *Other Menu* ğŸ“Œ",
                content: `â•­â”â”â”ã€” *Other Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ•’ *Utilities*
â”ƒâ˜…â”‚ â€¢ timenow
â”ƒâ˜…â”‚ â€¢ date
â”ƒâ˜…â”‚ â€¢ count [num]
â”ƒâ˜…â”‚ â€¢ calculate [expr]
â”ƒâ˜…â”‚ â€¢ countx
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ² *Random*
â”ƒâ˜…â”‚ â€¢ flip
â”ƒâ˜…â”‚ â€¢ coinflip
â”ƒâ˜…â”‚ â€¢ rcolor
â”ƒâ˜…â”‚ â€¢ roll
â”ƒâ˜…â”‚ â€¢ fact
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ” *Search*
â”ƒâ˜…â”‚ â€¢ define [word]
â”ƒâ˜…â”‚ â€¢ news [query]
â”ƒâ˜…â”‚ â€¢ movie [name]
â”ƒâ˜…â”‚ â€¢ weather [loc]
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '9': {
                title: "ğŸ’ *Reactions Menu* ğŸ’",
                content: `â•­â”â”â”ã€” *Reactions Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ â¤ï¸ *Affection*
â”ƒâ˜…â”‚ â€¢ cuddle @user
â”ƒâ˜…â”‚ â€¢ hug @user
â”ƒâ˜…â”‚ â€¢ kiss @user
â”ƒâ˜…â”‚ â€¢ lick @user
â”ƒâ˜…â”‚ â€¢ pat @user
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ˜‚ *Funny*
â”ƒâ˜…â”‚ â€¢ bully @user
â”ƒâ˜…â”‚ â€¢ bonk @user
â”ƒâ˜…â”‚ â€¢ yeet @user
â”ƒâ˜…â”‚ â€¢ slap @user
â”ƒâ˜…â”‚ â€¢ kill @user
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ˜Š *Expressions*
â”ƒâ˜…â”‚ â€¢ blush @user
â”ƒâ˜…â”‚ â€¢ smile @user
â”ƒâ˜…â”‚ â€¢ happy @user
â”ƒâ˜…â”‚ â€¢ wink @user
â”ƒâ˜…â”‚ â€¢ poke @user
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            },
            '10': {
                title: "ğŸ  *Main Menu* ğŸ ",
                content: `â•­â”â”â”ã€” *Main Menu* ã€•â”â”â”â”ˆâŠ·
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ â„¹ï¸ *Bot Info*
â”ƒâ˜…â”‚ â€¢ ping
â”ƒâ˜…â”‚ â€¢ live
â”ƒâ˜…â”‚ â€¢ alive
â”ƒâ˜…â”‚ â€¢ runtime
â”ƒâ˜…â”‚ â€¢ uptime
â”ƒâ˜…â”‚ â€¢ repo
â”ƒâ˜…â”‚ â€¢ owner
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ˜…â”‚ ğŸ› ï¸ *Controls*
â”ƒâ˜…â”‚ â€¢ menu
â”ƒâ˜…â”‚ â€¢ menu2
â”ƒâ˜…â”‚ â€¢ restart
â”ƒâ˜…â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”ˆâŠ·
> ${config.DESCRIPTION}`
            }
        };

        // Message handler
        const handler = async (msgData) => {
            const receivedMsg = msgData.messages[0];
            if (!receivedMsg?.message || !receivedMsg.key?.remoteJid) return;

            const isReplyToMenu = receivedMsg.message.extendedTextMessage?.contextInfo?.stanzaId === messageID;
            
            if (isReplyToMenu) {
                const receivedText = receivedMsg.message.conversation || 
                                  receivedMsg.message.extendedTextMessage?.text;
                const senderID = receivedMsg.key.remoteJid;

                await conn.sendMessage(senderID, {
                    react: { text: 'â³', key: receivedMsg.key }
                });

                if (menuData[receivedText]) {
                    const selectedMenu = menuData[receivedText];
                    
                    await conn.sendMessage(
                        senderID,
                        {
                            image: { url: config.MENU_IMAGE_URL || 'https://files.catbox.moe/i5p540.jpg' },
                            caption: selectedMenu.content,
                            contextInfo: contextInfo
                        },
                        { quoted: receivedMsg }
                    );

                    await conn.sendMessage(senderID, {
                        react: { text: 'âœ…', key: receivedMsg.key }
                    });

                } else {
                    await conn.sendMessage(
                        senderID,
                        {
                            text: `âŒ *Invalid Option!* âŒ\n\nPlease reply with a number between 1-10 to select a menu.\n\n*Example:* Reply with "1" for Download Menu\n\n> ${config.DESCRIPTION}`,
                            contextInfo: contextInfo
                        },
                        { quoted: receivedMsg }
                    );
                    await conn.sendMessage(senderID, {
                        react: { text: 'âŒ', key: receivedMsg.key }
                    });
                }
            }
        };

        // Add listener
        conn.ev.on("messages.upsert", handler);

        // Remove listener after 5 minutes
        setTimeout(() => {
            conn.ev.off("messages.upsert", handler);
        }, 300000);

    } catch (e) {
        console.error('Menu Error:', e);
        await conn.sendMessage(from, {
            react: { text: 'âŒ', key: mek.key }
        });
        reply(`âŒ An error occurred: ${e}\n\n> ${config.DESCRIPTION}`);
    }
});

const axios = require('axios');
const config = require('../config');
const { cmd, commands } = require('../command');
const util = require("util");
const { getAnti, setAnti, initializeAntiDeleteSettings } = require('../data/antidel');

initializeAntiDeleteSettings();

cmd({
    pattern: "antidelete",
    alias: ['antidel', 'ad'],
    desc: "Sets up the Antidelete",
    category: "misc",
    filename: __filename
},
async (conn, mek, m, { from, reply, q, text, isCreator, fromMe }) => {
    if (!isCreator) return reply('This command is only for the bot owner');
    try {
        const command = q?.toLowerCase();

        switch (command) {
            case 'on':
                await setAnti('gc', false);
                await setAnti('dm', false);
                return reply('_AntiDelete is now off for Group Chats and Direct Messages._');

            case 'off gc':
                await setAnti('gc', false);
                return reply('_AntiDelete for Group Chats is now disabled._');

            case 'off dm':
                await setAnti('dm', false);
                return reply('_AntiDelete for Direct Messages is now disabled._');

            case 'set gc':
                const gcStatus = await getAnti('gc');
                await setAnti('gc', !gcStatus);
                return reply(`_AntiDelete for Group Chats ${!gcStatus ? 'enabled' : 'disabled'}._`);

            case 'set dm':
                const dmStatus = await getAnti('dm');
                await setAnti('dm', !dmStatus);
                return reply(`_AntiDelete for Direct Messages ${!dmStatus ? 'enabled' : 'disabled'}._`);

            case 'set all':
                await setAnti('gc', true);
                await setAnti('dm', true);
                return reply('_AntiDelete set for all chats._');

            case 'status':
                const currentDmStatus = await getAnti('dm');
                const currentGcStatus = await getAnti('gc');
                return reply(`_AntiDelete Status_\n\n*DM AntiDelete:* ${currentDmStatus ? 'Enabled' : 'Disabled'}\n*Group Chat AntiDelete:* ${currentGcStatus ? 'Enabled' : 'Disabled'}`);

            default:
                const helpMessage = `-- *AntiDelete Command Guide: --*
                â€¢ \`\`.antidelete on\`\` - Reset AntiDelete for all chats (disabled by default)
                â€¢ \`\`.antidelete off gc\`\` - Disable AntiDelete for Group Chats
                â€¢ \`\`.antidelete off dm\`\` - Disable AntiDelete for Direct Messages
                â€¢ \`\`.antidelete set gc\`\` - Toggle AntiDelete for Group Chats
                â€¢ \`\`.antidelete set dm\`\` - Toggle AntiDelete for Direct Messages
                â€¢ \`\`.antidelete set all\`\` - Enable AntiDelete for all chats
                â€¢ \`\`.antidelete status\`\` - Check current AntiDelete status`;

                return reply(helpMessage);
        }
    } catch (e) {
        console.error("Error in antidelete command:", e);
        return reply("An error occurred while processing your request.");
    }
});


cmd({
    pattern: "vv3",
    alias: ['lx', 'ğŸ¦ '],
    desc: "Fetch and resend a ViewOnce message content (image/video).",
    category: "misc",
    use: '<query>',
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const quotedMessage = m.msg.contextInfo.quotedMessage; // Get quoted message

        if (quotedMessage && quotedMessage.viewOnceMessageV2) {
            const quot = quotedMessage.viewOnceMessageV2;
            if (quot.message.imageMessage) {
                let cap = quot.message.imageMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.imageMessage);
                return conn.sendMessage(from, { image: { url: anu }, caption: cap }, { quoted: mek });
            }
            if (quot.message.videoMessage) {
                let cap = quot.message.videoMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.videoMessage);
                return conn.sendMessage(from, { video: { url: anu }, caption: cap }, { quoted: mek });
            }
            if (quot.message.audioMessage) {
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.audioMessage);
                return conn.sendMessage(from, { audio: { url: anu } }, { quoted: mek });
            }
        }

        // If there is no quoted message or it's not a ViewOnce message
        if (!m.quoted) return reply("Please reply to a ViewOnce message.");
        if (m.quoted.mtype === "viewOnceMessage") {
            if (m.quoted.message.imageMessage) {
                let cap = m.quoted.message.imageMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.imageMessage);
                return conn.sendMessage(from, { image: { url: anu }, caption: cap }, { quoted: mek });
            }
            else if (m.quoted.message.videoMessage) {
                let cap = m.quoted.message.videoMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.videoMessage);
                return conn.sendMessage(from, { video: { url: anu }, caption: cap }, { quoted: mek });
            }
        } else if (m.quoted.message.audioMessage) {
            let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.audioMessage);
            return conn.sendMessage(from, { audio: { url: anu } }, { quoted: mek });
        } else {
            return reply("This is not a ViewOnce message.");
        }
    } catch (e) {
        console.log("Error:", e);
        reply("An error occurred while fetching the ViewOnce message.");
    }
});

// if you want use the codes give me credit on your channel and repo in this file and my all files 

const axios = require('axios');
const { cmd } = require('../command');

cmd({
    pattern: "movie",
    desc: "Fetch detailed information about a movie.",
    category: "utility",
    react: "ğŸ¬",
    filename: __filename
},
async (conn, mek, m, { from, reply, sender, args }) => {
    try {
        // Properly extract the movie name from arguments
        const movieName = args.length > 0 ? args.join(' ') : m.text.replace(/^[\.\#\$\!]?movie\s?/i, '').trim();
        
        if (!movieName) {
            return reply("ğŸ“½ï¸ Please provide the name of the movie.\nExample: .movie Iron Man");
        }

        const apiUrl = `https://apis.davidcyriltech.my.id/imdb?query=${encodeURIComponent(movieName)}`;
        const response = await axios.get(apiUrl);

        if (!response.data.status || !response.data.movie) {
            return reply("ğŸš« Movie not found. Please check the name and try again.");
        }

        const movie = response.data.movie;
        
        // Format the caption
        const dec = `
ğŸ¬ *${movie.title}* (${movie.year}) ${movie.rated || ''}

â­ *IMDb:* ${movie.imdbRating || 'N/A'} | ğŸ… *Rotten Tomatoes:* ${movie.ratings.find(r => r.source === 'Rotten Tomatoes')?.value || 'N/A'} | ğŸ’° *Box Office:* ${movie.boxoffice || 'N/A'}

ğŸ“… *Released:* ${new Date(movie.released).toLocaleDateString()}
â³ *Runtime:* ${movie.runtime}
ğŸ­ *Genre:* ${movie.genres}

ğŸ“ *Plot:* ${movie.plot}

ğŸ¥ *Director:* ${movie.director}
âœï¸ *Writer:* ${movie.writer}
ğŸŒŸ *Actors:* ${movie.actors}

ğŸŒ *Country:* ${movie.country}
ğŸ—£ï¸ *Language:* ${movie.languages}
ğŸ† *Awards:* ${movie.awards || 'None'}

[View on IMDb](${movie.imdbUrl})
`;

        // Send message with the requested format
        await conn.sendMessage(
            from,
            {
                image: { 
                    url: movie.poster && movie.poster !== 'N/A' ? movie.poster : 'https://files.catbox.moe/wp4qci.jpg'
                },
                caption: dec,
                contextInfo: {
                    mentionedJid: [sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir bravin',
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

    } catch (e) {
        console.error('Movie command error:', e);
        reply(`âŒ Error: ${e.message}`);
    }
});

const axios = require('axios');
const { cmd } = require('../command');

cmd({
    pattern: "news",
    desc: "Get the latest news headlines.",
    category: "news",
    react: "ğŸ—ï¸",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const apiKey="0f2c43ab11324578a7b1709651736382";
        const response = await axios.get(`https://newsapi.org/v2/top-headlines?country=us&apiKey=${apiKey}`);
        const articles = response.data.articles;

        if (!articles.length) return reply("No news articles found.");

        // Send each article as a separate message with image and title
        for (let i = 0; i < Math.min(articles.length, 5); i++) {
            const article = articles[i];
            let message = `
ğŸ“° *${article.title}*
âš ï¸ _${article.description}_
ğŸ”— _${article.url}_

  Â©á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê sir bravin 
            `;

            console.log('Article URL:', article.urlToImage); // Log image URL for debugging

            if (article.urlToImage) {
                // Send image with caption
                await conn.sendMessage(from, { image: { url: article.urlToImage }, caption: message });
            } else {
                // Send text message if no image is available
                await conn.sendMessage(from, { text: message });
            }
        };
    } catch (e) {
        console.error("Error fetching news:", e);
        reply("Could not fetch news. Please try again later.");
    }
});

const axios = require("axios");
const { cmd } = require("../command");

cmd({
  pattern: "npm",
  desc: "Search for a package on npm.",
  react: 'ğŸ“¦',
  category: "convert",
  filename: __filename,
  use: ".npm <package-name>"
}, async (conn, mek, msg, { from, args, reply }) => {
  try {
    // Check if a package name is provided
    if (!args.length) {
      return reply("Please provide the name of the npm package you want to search for. Example: .npm express");
    }

    const packageName = args.join(" ");
    const apiUrl = `https://registry.npmjs.org/${encodeURIComponent(packageName)}`;

    // Fetch package details from npm registry
    const response = await axios.get(apiUrl);
    if (response.status !== 200) {
      throw new Error("Package not found or an error occurred.");
    }

    const packageData = response.data;
    const latestVersion = packageData["dist-tags"].latest;
    const description = packageData.description || "No description available.";
    const npmUrl = `https://www.npmjs.com/package/${packageName}`;
    const license = packageData.license || "Unknown";
    const repository = packageData.repository ? packageData.repository.url : "Not available";

    // Create the response message
    const message = `
*sir bravin NPM SEARCH*

*ğŸ”° NPM PACKAGE:* ${packageName}
*ğŸ“„ DESCRIPTION:* ${description}
*â¸ï¸ LAST VERSION:* ${latestVersion}
*ğŸªª LICENSE:* ${license}
*ğŸª© REPOSITORY:* ${repository}
*ğŸ”— NPM URL:* ${npmUrl}
`;

    // Send the message
    await conn.sendMessage(from, { text: message }, { quoted: mek });

  } catch (error) {
    console.error("Error:", error);

    // Send detailed error logs to WhatsApp
    const errorMessage = `
*âŒ NPM Command Error Logs*

*Error Message:* ${error.message}
*Stack Trace:* ${error.stack || "Not available"}
*Timestamp:* ${new Date().toISOString()}
`;

    await conn.sendMessage(from, { text: errorMessage }, { quoted: mek });
    reply("An error occurred while fetching the npm package details.");
  }
});



const { cmd } = require('../command');
const config = require('../config');

cmd({
    pattern: "owner",
    react: "âœ…", 
    desc: "Get owner number",
    category: "main",
    filename: __filename
}, 
async (conn, mek, m, { from }) => {
    try {
        const ownerNumber = config.OWNER_NUMBER; // Fetch owner number from config
        const ownerName = config.OWNER_NAME;     // Fetch owner name from config

        const vcard = 'BEGIN:VCARD\n' +
                      'VERSION:3.0\n' +
                      `FN:${ownerName}\n` +  
                      `TEL;type=CELL;type=VOICE;waid=${ownerNumber.replace('+', '')}:${ownerNumber}\n` + 
                      'END:VCARD';

        // Send the vCard
        const sentVCard = await conn.sendMessage(from, {
            contacts: {
                displayName: ownerName,
                contacts: [{ vcard }]
            }
        });

        // Send the owner contact message with image and audio
        await conn.sendMessage(from, {
            image: { url: 'https://files.catbox.moe/k59je3.jpg' }, // Image URL from your request
            caption: `â•­â”â”ã€” *toxic lover-V2 xmd* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ *Here is the owner details*
â”ƒâ—ˆâ”ƒâ€¢ *Name* - ${ownerName}
â”ƒâ—ˆâ”ƒâ€¢ *Number* ${ownerNumber}
â”ƒâ—ˆâ”ƒâ€¢ *Version*: 2.0.0 Beta
â”ƒâ—ˆâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê Êœá´œÉ´á´›á´‡Ê€ xá´á´…`, // Display the owner's details
            contextInfo: {
                mentionedJid: [`${ownerNumber.replace('+', '')}@s.whatsapp.net`], 
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363366284524544@newsletter',
                    newsletterName: 'toxic lover-v2 xmd',
                    serverMessageId: 143
                }            
            }
        }, { quoted: mek });

        // Send audio as per your request
        await conn.sendMessage(from, {
            audio: { url: 'https://github.com/criss-vevo/CRISS-DATA/raw/refs/heads/main/autovoice/menunew.m4a' }, // Audio URL
            mimetype: 'audio/mp4',
            ptt: true
        }, { quoted: mek });

    } catch (error) {
        console.error(error);
        reply(`An error occurred: ${error.message}`);
    }
});

const { cmd ,commands } = require('../command');
const { exec } = require('child_process');
const config = require('../config');
const {sleep} = require('../lib/functions')
// 1. Shutdown Bot
cmd({
    pattern: "shutdown",
    desc: "Shutdown the bot.",
    category: "owner",
    react: "âš½",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    reply("ğŸ›‘ Shutting down...").then(() => process.exit());
});
// 2. Broadcast Message to All Groups
cmd({
    pattern: "broadcast",
    desc: "Broadcast a message to all groups.",
    category: "owner",
    react: "ğŸ“¢",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, args, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (args.length === 0) return reply("ğŸ“¢ Please provide a message to broadcast.");
    const message = args.join(' ');
    const groups = Object.keys(await conn.groupFetchAllParticipating());
    for (const groupId of groups) {
        await conn.sendMessage(groupId, { text: message }, { quoted: mek });
    }
    reply("ğŸ“¢ Message broadcasted to all groups.");
});
// 3. Set Profile Picture
cmd({
    pattern: "setpp",
    desc: "Set bot profile picture.",
    category: "owner",
    react: "ğŸ–¼ï¸",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!quoted || !quoted.message.imageMessage) return reply("âŒ Please reply to an image.");
    try {
        const media = await conn.downloadMediaMessage(quoted);
        await conn.updateProfilePicture(conn.user.jid, { url: media });
        reply("ğŸ–¼ï¸ Profile picture updated successfully!");
    } catch (error) {
        reply(`âŒ Error updating profile picture: ${error.message}`);
    }
});

// 6. Clear All Chats
cmd({
    pattern: "clearchats",
    desc: "Clear all chats from the bot.",
    category: "owner",
    react: "ğŸ§¹",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    try {
        const chats = conn.chats.all();
        for (const chat of chats) {
            await conn.modifyChat(chat.jid, 'delete');
        }
        reply("ğŸ§¹ All chats cleared successfully!");
    } catch (error) {
        reply(`âŒ Error clearing chats: ${error.message}`);
    }
});

cmd({
    pattern: "jid",
    desc: "Get the bot's JID.",
    category: "owner",
    react: "ğŸ¤–",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    reply(`ğŸ¤– *Bot JID:* ${conn.user.jid}`);
});
// 8. Group JIDs List
cmd({
    pattern: "gjid",
    desc: "Get the list of JIDs for all groups the bot is part of.",
    category: "owner",
    react: "ğŸ“",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    const groups = await conn.groupFetchAllParticipating();
    const groupJids = Object.keys(groups).join('\n');
    reply(`ğŸ“ *Group JIDs:*\n\n${groupJids}`);
});


// delete 

cmd({
pattern: "delete",
react: "âŒ",
alias: ["del"],
desc: "delete message",
category: "group",
use: '.del',
filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants,  isItzcp, groupAdmins, isBotAdmins, isAdmins, reply}) => {
if (!isOwner ||  !isAdmins) return;
try{
if (!m.quoted) return reply(mg.notextfordel);
const key = {
            remoteJid: m.chat,
            fromMe: false,
            id: m.quoted.id,
            participant: m.quoted.sender
        }
        await conn.sendMessage(m.chat, { delete: key })
} catch(e) {
console.log(e);
reply('successful..ğŸ‘¨â€ğŸ’»âœ…')
} 
})


const config = require('../config');
const { cmd, commands } = require('../command');

cmd({
    pattern: "ping2",
    alias: ["speed","pong"],use: '.ping',
    desc: "Check bot's response time.",
    category: "main",
    react: "âš¡",
    filename: __filename
},
async (conn, mek, m, { from, quoted, sender, reply, }) => {
    try {
        const start = new Date().getTime();

        const reactionEmojis = ['ğŸ”¥', 'âš¡', 'ğŸš€', 'ğŸ’¨', 'ğŸ¯', 'ğŸ‰', 'ğŸŒŸ', 'ğŸ’¥', 'ğŸ•', 'ğŸ”¹'];
        const textEmojis = ['ğŸ’', 'ğŸ†', 'âš¡ï¸', 'ğŸš€', 'ğŸ¶', 'ğŸŒ ', 'ğŸŒ€', 'ğŸ”±', 'ğŸ›¡ï¸', 'âœ¨'];

        const reactionEmoji = reactionEmojis[Math.floor(Math.random() * reactionEmojis.length)];
        let textEmoji = textEmojis[Math.floor(Math.random() * textEmojis.length)];

        // Ensure reaction and text emojis are different
        while (textEmoji === reactionEmoji) {
            textEmoji = textEmojis[Math.floor(Math.random() * textEmojis.length)];
        }

        // Send reaction using conn.sendMessage()
        await conn.sendMessage(from, {
            react: { text: textEmoji, key: mek.key }
        });

        const end = new Date().getTime();
        const responseTime = (end - start) / 1000;

        const text = `> *terminator xmd êœ±á´˜á´‡á´‡á´…: ${responseTime.toFixed(2)}ms ${reactionEmoji}*`;

        await conn.sendMessage(from, {
            text,
            contextInfo: {
                mentionedJid: [sender],
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363420222821450@newsletter',
                    newsletterName: "sir T20 classic",
                    serverMessageId: 143
                }
            }
        }, { quoted: mek });

    } catch (e) {
        console.error("Error in ping command:", e);
        reply(`An error occurred: ${e.message}`);
    }
});

// ping2 

cmd({
    pattern: "ping",
    desc: "Check bot's response time.",
    category: "main",
    react: "ğŸ‚",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const startTime = Date.now()
        const message = await conn.sendMessage(from, { text: '*PINGING...*' })
        const endTime = Date.now()
        const ping = endTime - startTime
        await conn.sendMessage(from, { text: `*ğŸ”¥ terminator xmd : ${ping}ms*` }, { quoted: message })
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
})

const { cmd } = require('../command');
const axios = require('axios');

cmd({
    pattern: "pindl",
    alias: ["pinterestdl", "pin", "pins", "pindownload"],
    desc: "Download media from Pinterest",
    category: "download",
    filename: __filename
}, async (conn, mek, m, { args, quoted, from, reply }) => {
    try {
        // Make sure the user provided the Pinterest URL
        if (args.length < 1) {
            return reply('â Please provide the Pinterest URL to download from.');
        }

        // Extract Pinterest URL from the arguments
        const pinterestUrl = args[0];

        // Call your Pinterest download API
        const response = await axios.get(`https://api.giftedtech.web.id/api/download/pinterestdl?apikey=gifted&url=${encodeURIComponent(pinterestUrl)}`);

        if (!response.data.success) {
            return reply('â Failed to fetch data from Pinterest.');
        }

        const media = response.data.result.media;
        const description = response.data.result.description || 'No description available'; // Check if description exists
        const title = response.data.result.title || 'No title available';

        // Select the best video quality or you can choose based on size or type
        const videoUrl = media.find(item => item.type.includes('720p'))?.download_url || media[0].download_url;

        // Prepare the new message with the updated caption
        const desc = `â•­â”â”â”ã€” *CRISS-AI* ã€•â”â”â”â”ˆâŠ·
â”ƒâ–¸â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”ƒâ–¸â”ƒà¹ *PINS DOWNLOADER*
â”ƒâ–¸â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·Â·Â·à¹
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•­â”â”ââ”âª¼
â”‡à¹ *Title* - ${title}
â”‡à¹ *Media Type* - ${media[0].type}
â•°â”â”â‘â”âª¼
> *Â© Pá´á´¡á´‡Ê€á´‡á´… BÊ sir bravinâ™¡*`;

        // Send the media (video or image) to the user
        if (videoUrl) {
            // If it's a video, send the video
            await conn.sendMessage(from, { video: { url: videoUrl }, caption: desc }, { quoted: mek });
        } else {
            // If it's an image, send the image
            const imageUrl = media.find(item => item.type === 'Thumbnail')?.download_url;
            await conn.sendMessage(from, { image: { url: imageUrl }, caption: desc }, { quoted: mek });
        }

    } catch (e) {
        console.error(e);
        await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } });
        reply('â An error occurred while processing your request.');
    }
});

const { cmd } = require('../command');

cmd({
    pattern: "hack",
    desc: "Displays a dynamic and playful 'Hacking' message for fun.",
    category: "fun",
    filename: __filename
},
async (conn, mek, m, { 
    from, quoted, body, isCmd, command, args, q, isGroup, senderNumber, reply 
}) => {
    try {
        // Get the bot owner's number dynamically from conn.user.id
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        const steps = [
            'ğŸ’» *HACK STARTING...* ğŸ’»',
            
            '*Initializing hacking tools...* ğŸ› ï¸',
            '*Connecting to remote servers...* ğŸŒ',
            
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 10%``` â³'                                            ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 20%``` â³'                                   ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 30%``` â³'                               ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 40%``` â³'                            ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 50%``` â³'                       ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 60%``` â³'                 ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 70%``` â³'            ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 80%``` â³'        ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 90%``` â³'    ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%``` âœ…',
            
            'ğŸ”’ *System Breach: Successful!* ğŸ”“',
            'ğŸš€ *Command Execution: Complete!* ğŸ¯',
            
            '*ğŸ“¡ Transmitting data...* ğŸ“¤',
            '_ğŸ•µï¸â€â™‚ï¸ Ensuring stealth..._ ğŸ¤«',
            '*ğŸ”§ Finalizing operations...* ğŸ',
            
            'âš ï¸ *Note:* All actions are for demonstration purposes only.',
            'âš ï¸ *Reminder:* Ethical hacking is the only way to ensure security.',
            
            '> *SIR BRAVIN-HACKING-COMPLETE â˜£*'
        ];

        for (const line of steps) {
            await conn.sendMessage(from, { text: line }, { quoted: mek });
            await new Promise(resolve => setTimeout(resolve, 1000)); // Adjust the delay as needed
        }
    } catch (e) {
        console.error(e);
        reply(`âŒ *Error:* ${e.message}`);
    }
});

const axios = require('axios'); 
const config = require('../config');
const { cmd, commands } = require('../command');
const fetch = require('node-fetch'); 

cmd({
    pattern: "praytime", 
    alias: ["prayertimes", "prayertime", "ptime" ], 
    react: "âœ…", 
    desc: "Get the prayer times, weather, and location for the city.", 
    category: "information", 
    filename: __filename,
},
async(conn, mek, m, {from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, isItzcp, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try {
        const city = args.length > 0 ? args.join(" ") : "bhakkar"; // Default to Bhakkar if no city is provided
        const apiUrl = `https://api.nexoracle.com/islamic/prayer-times?city=${city}`;

        const response = await fetch(apiUrl);

        if (!response.ok) {
            return reply('Error fetching prayer times!');
        }

        const data = await response.json();

        if (data.status !== 200) {
            return reply('Failed to get prayer times. Please try again later.');
        }

        const prayerTimes = data.result.items[0];
        const weather = data.result.today_weather; // Weather data
        const location = data.result.city; // Location name

        // Building the message content
        let dec = `*Prayer Times for ${location}, ${data.result.state}*\n\n`;
        dec += `ğŸ“ *Location*: ${location}, ${data.result.state}, ${data.result.country}\n`;
        dec += `ğŸ•Œ *Method*: ${data.result.prayer_method_name}\n\n`;

        dec += `ğŸŒ… *Fajr*: ${prayerTimes.fajr}\n`;
        dec += `ğŸŒ„ *Shurooq*: ${prayerTimes.shurooq}\n`;
        dec += `â˜€ï¸ *Dhuhr*: ${prayerTimes.dhuhr}\n`;
        dec += `ğŸŒ‡ *Asr*: ${prayerTimes.asr}\n`;
        dec += `ğŸŒ† *Maghrib*: ${prayerTimes.maghrib}\n`;
        dec += `ğŸŒƒ *Isha*: ${prayerTimes.isha}\n\n`;

        dec += `ğŸ§­ *Qibla Direction*: ${data.result.qibla_direction}Â°\n`;

        const temperature = weather.temperature !== null ? `${weather.temperature}Â°C` : 'Data not available';
        dec += `ğŸŒ¡ï¸ *Temperature*: ${temperature}\n`;

        // Sending the image with the caption and context info
        await conn.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/ewgse7.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir bravin',
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

        // Optionally, send an audio file related to the prayer time
        await conn.sendMessage(from, {
            audio: { url: 'https://github.com/XdTechPro/KHAN-DATA/raw/refs/heads/main/autovoice/Islamic.m4a' },
            mimetype: 'audio/mp4',
            ptt: false
        }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply('*Error occurred while fetching prayer times and weather.*');
    }
});

const fs = require('fs');
const path = require('path');
const config = require('../config')
const {cmd , commands} = require('../command')

// Always Online

cmd({
  on: "body"
}, async (conn, mek, m, { from, isOwner }) => {
  try {
    if (config.ALWAYS_ONLINE === "true") {
      // Always Online Mode: Bot always appears online (double tick)
      await conn.sendPresenceUpdate("available", from);
    } else {
      // Dynamic Mode: Adjust presence based on owner's status
      if (isOwner) {
        // If the owner is online, show as available (double tick)
        await conn.sendPresenceUpdate("available", from);
      } else {
        // If the owner is offline, show as unavailable (single tick)
        await conn.sendPresenceUpdate("unavailable", from);
      }
    }
  } catch (e) {
    console.log(e);
  }
});

// Public Mod
cmd({
  on: "body"
}, async (conn, mek, m, { from, isOwner }) => {
  try {
    if (config.ALWAYS_ONLINE === "true") {
      // Public Mode + Always Online: Always show as online
      await conn.sendPresenceUpdate("available", from);
    } else if (config.PUBLIC_MODE === "true") {
      // Public Mode + Dynamic: Respect owner's presence
      if (isOwner) {
        // If owner is online, show available
        await conn.sendPresenceUpdate("available", from);
      } else {
        // If owner is offline, show unavailable
        await conn.sendPresenceUpdate("unavailable", from);
      }
    }
  } catch (e) {
    console.log(e);
  }
});

const fs = require("fs");
const config = require("../config");
const { cmd, commands } = require("../command");
const path = require('path');
const axios = require("axios");


cmd({
    pattern: "privacy",
    alias: ["privacymenu"],
    desc: "Privacy settings menu",
    category: "privacy",
    react: "ğŸ”",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let privacyMenu = `â•­â”â”ã€” *Privacy Settings* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ blocklist - View blocked users
â”ƒâ—ˆâ”ƒâ€¢ getbio - Get user's bio
â”ƒâ—ˆâ”ƒâ€¢ setppall - Set profile pic privacy
â”ƒâ—ˆâ”ƒâ€¢ setonline - Set online privacy
â”ƒâ—ˆâ”ƒâ€¢ setpp - Change bot's profile pic
â”ƒâ—ˆâ”ƒâ€¢ setmyname - Change bot's name
â”ƒâ—ˆâ”ƒâ€¢ updatebio - Change bot's bio
â”ƒâ—ˆâ”ƒâ€¢ groupsprivacy - Set group add privacy
â”ƒâ—ˆâ”ƒâ€¢ getprivacy - View current privacy settings
â”ƒâ—ˆâ”ƒâ€¢ getpp - Get user's profile picture
â”ƒâ—ˆâ”ƒ
â”ƒâ—ˆâ”ƒ*Options for privacy commands:*
â”ƒâ—ˆâ”ƒâ€¢ all - Everyone
â”ƒâ—ˆâ”ƒâ€¢ contacts - My contacts only
â”ƒâ—ˆâ”ƒâ€¢ contact_blacklist - Contacts except blocked
â”ƒâ—ˆâ”ƒâ€¢ none - Nobody
â”ƒâ—ˆâ”ƒâ€¢ match_last_seen - Match last seen
â”ƒâ—ˆâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
*Note:* Most commands are owner-only`;

        await conn.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/bmg383.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir bravin',
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

    } catch (e) {
        console.log(e);
        reply(`Error: ${e.message}`);
    }
});


cmd({
    pattern: "blocklist",
    desc: "View the list of blocked users.",
    category: "privacy",
    react: "ğŸ“‹",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("*ğŸ“› You are not the owner!*");

    try {
        // Fetch the block list
        const blockedUsers = await conn.fetchBlocklist();

        if (blockedUsers.length === 0) {
            return reply("ğŸ“‹ Your block list is empty.");
        }

        // Format the blocked users with ğŸ“Œ and count the total
        const list = blockedUsers
            .map((user, i) => `ğŸš§ BLOCKED ${user.split('@')[0]}`) // Remove domain and add ğŸ“Œ
            .join('\n');

        const count = blockedUsers.length;
        reply(`ğŸ“‹ Blocked Users (${count}):\n\n${list}`);
    } catch (err) {
        console.error(err);
        reply(`âŒ Failed to fetch block list: ${err.message}`);
    }
});

cmd({
    pattern: "getbio",
    desc: "Displays the user's bio.",
    category: "privacy",
    filename: __filename,
}, async (conn, mek, m, { args, reply }) => {
    try {
        const jid = args[0] || mek.key.remoteJid;
        const about = await conn.fetchStatus?.(jid);
        if (!about) return reply("No bio found.");
        return reply(`User Bio:\n\n${about.status}`);
    } catch (error) {
        console.error("Error in bio command:", error);
        reply("No bio found.");
    }
});
cmd({
    pattern: "setppall",
    desc: "Update Profile Picture Privacy",
    category: "privacy",
    react: "ğŸ”",
    filename: __filename
}, 
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    
    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'contacts', 'contact_blacklist', 'none'];  
        
        if (!validValues.includes(value)) {
            return reply("âŒ Invalid option. Valid options are: 'all', 'contacts', 'contact_blacklist', 'none'.");
        }
        
        await conn.updateProfilePicturePrivacy(value);
        reply(`âœ… Profile picture privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});
cmd({
    pattern: "setonline",
    desc: "Update Online Privacy",
    category: "privacy",
    react: "ğŸ”",
    filename: __filename
}, 
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'match_last_seen'];
        
        if (!validValues.includes(value)) {
            return reply("âŒ Invalid option. Valid options are: 'all', 'match_last_seen'.");
        }

        await conn.updateOnlinePrivacy(value);
        reply(`âœ… Online privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "setpp",
    desc: "Set bot profile picture.",
    category: "privacy",
    react: "ğŸ–¼ï¸",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!quoted || !quoted.message.imageMessage) return reply("âŒ Please reply to an image.");
    try {
        const stream = await downloadContentFromMessage(quoted.message.imageMessage, 'image');
        let buffer = Buffer.from([]);
        for await (const chunk of stream) {
            buffer = Buffer.concat([buffer, chunk]);
        }

        const mediaPath = path.join(__dirname, `${Date.now()}.jpg`);
        fs.writeFileSync(mediaPath, buffer);

        // Update profile picture with the saved file
        await conn.updateProfilePicture(conn.user.jid, { url: `file://${mediaPath}` });
        reply("ğŸ–¼ï¸ Profile picture updated successfully!");
    } catch (error) {
        console.error("Error updating profile picture:", error);
        reply(`âŒ Error updating profile picture: ${error.message}`);
    }
});

cmd({
    pattern: "setmyname",
    desc: "Set your WhatsApp display name.",
    category: "privacy",
    react: "âš™ï¸",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply, args }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    // Ensure you have the display name argument
    const displayName = args.join(" ");
    if (!displayName) return reply("âŒ Please provide a display name.");

    try {
        // Ensure the session is loaded before trying to update
        const { state, saveCreds } = await useMultiFileAuthState('path/to/auth/folder');
        const conn = makeWASocket({
            auth: state,
            printQRInTerminal: true,
        });

        conn.ev.on('creds.update', saveCreds);

        // Update display name after connection
        await conn.updateProfileName(displayName);
        reply(`âœ… Your display name has been set to: ${displayName}`);
    } catch (err) {
        console.error(err);
        reply("âŒ Failed to set your display name.");
    }
});

cmd({
    pattern: "updatebio",
    react: "ğŸ¥",
    desc: "Change the Bot number Bio.",
    category: "privacy",
    use: '.updatebio',
    filename: __filename
},
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return reply('ğŸš« *You must be an Owner to use this command*');
        if (!q) return reply('â“ *Enter the New Bio*');
        if (q.length > 139) return reply('â— *Sorry! Character limit exceeded*');
        await conn.updateProfileStatus(q);
        await conn.sendMessage(from, { text: "âœ”ï¸ *New Bio Added Successfully*" }, { quoted: mek });
    } catch (e) {
        reply('ğŸš« *An error occurred!*\n\n' + e);
        l(e);
    }
});
cmd({
    pattern: "groupsprivacy",
    desc: "Update Group Add Privacy",
    category: "privacy",
    react: "ğŸ”",
    filename: __filename
}, 
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'contacts', 'contact_blacklist', 'none'];
        
        if (!validValues.includes(value)) {
            return reply("âŒ Invalid option. Valid options are: 'all', 'contacts', 'contact_blacklist', 'none'.");
        }

        await conn.updateGroupsAddPrivacy(value);
        reply(`âœ… Group add privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "getprivacy",
    desc: "Get the bot Number Privacy Setting Updates.",
    category: "privacy",
    use: '.getprivacy',
    filename: __filename
},
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return reply('ğŸš« *You must be an Owner to use this command*');
        const duka = await conn.fetchPrivacySettings?.(true);
        if (!duka) return reply('ğŸš« *Failed to fetch privacy settings*');
        
        let puka = `
â•­â”€â”€â”€ã€Œ ğ™¿ğšğ™¸ğš…ğ™°ğ™²ğšˆ  ã€â”€â”€â”€â—†  
â”‚ âˆ˜ ğšğšğšŠğš ğšğšğšŒğšğš’ğš™ğš: ${duka.readreceipts}  
â”‚ âˆ˜ ğ™¿ğš›ğš˜ğšğš’ğš•ğš ğ™¿ğš’ğšŒğšğšğš›ğš: ${duka.profile}  
â”‚ âˆ˜ ğš‚ğšğšŠğšğšğšœ: ${duka.status}  
â”‚ âˆ˜ ğ™¾ğš—ğš•ğš’ğš—ğš: ${duka.online}  
â”‚ âˆ˜ ğ™»ğšŠğšœğš ğš‚ğšğšğš—: ${duka.last}  
â”‚ âˆ˜ ğ™¶ğš›ğš˜ğšğš™ ğ™¿ğš›ğš’ğšŸğšŠğšŒğš¢: ${duka.groupadd}  
â”‚ âˆ˜ ğ™²ğšŠğš•ğš• ğ™¿ğš›ğš’ğšŸğšŠğšŒğš¢: ${duka.calladd}  
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
        await conn.sendMessage(from, { text: puka }, { quoted: mek });
    } catch (e) {
        reply('ğŸš« *An error occurred!*\n\n' + e);
        l(e);
    }
});
cmd({
    pattern: "getpp",
    desc: "Fetch the profile picture of a tagged or replied user.",
    category: "owner",
    filename: __filename
}, async (conn, mek, m, { quoted, isGroup, sender, participants, reply }) => {
    try {
        // Determine the target user
        const targetJid = quoted ? quoted.sender : sender;

        if (!targetJid) return reply("âš ï¸ Please reply to a message to fetch the profile picture.");

        // Fetch the user's profile picture URL
        const userPicUrl = await conn.profilePictureUrl(targetJid, "image").catch(() => null);

        if (!userPicUrl) return reply("âš ï¸ No profile picture found for the specified user.");

        // Send the user's profile picture
        await conn.sendMessage(m.chat, {
            image: { url: userPicUrl },
            caption: "ğŸ–¼ï¸ Here is the profile picture of the specified user."
        });
    } catch (e) {
        console.error("Error fetching user profile picture:", e);
        reply("âŒ An error occurred while fetching the profile picture. Please try again later.");
    }
});

          

const axios = require("axios");
const { cmd } = require("../command");

cmd({
  pattern: "quote",
  desc: "Get a random inspiring quote.",
  category: "fun",
  react: "ğŸ’¬",
  filename: __filename
}, async (conn, m, store, { from, reply }) => {
  try {
    const response = await axios.get("https://api.quotable.io/random");
    const { content, author } = response.data;

    const message = `ğŸ’¬ *"${content}"*\n- ${author}\n\n> *QUOTES BY sor bravin*`;
    reply(message);
  } catch (error) {
    console.error("Error fetching quote:", error);
    reply("âš ï¸ API issue or coding error, please check the logs!");
  }
});

const fetch = require('node-fetch'); 
const { cmd, commands } = require('../command');
const { fetchJson } = require('../lib/functions');
const { translate } = require('@vitalets/google-translate-api');
const axios = require('axios')

cmd({
  pattern: "quran",
  alias: ["surah"],
  react: "ğŸ¤",
  desc: "Get Quran Surah details and explanation.",
  category: "main",
  filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
  try {

    let surahInput = args[0];

    if (!surahInput) {
      return reply('Type Surah Number or Type *.Surahmenu* for getting Surah numbers');
    }

    let surahListRes = await fetchJson('https://quran-endpoint.vercel.app/quran');
    let surahList = surahListRes.data;

    let surahData = surahList.find(surah => 
        surah.number === Number(surahInput) || 
        surah.asma.ar.short.toLowerCase() === surahInput.toLowerCase() || 
        surah.asma.en.short.toLowerCase() === surahInput.toLowerCase()
    );

    if (!surahData) {
      return reply(`Couldn't find surah with number or name "${surahInput}"`);
    }

    let res = await fetch(`https://quran-endpoint.vercel.app/quran/${surahData.number}`);
    
    if (!res.ok) {
      let error = await res.json(); 
      return reply(`API request failed with status ${res.status} and message ${error.message}`);
    }

    let json = await res.json();

    let translatedTafsirUrdu = await translate(json.data.tafsir.id, { to: 'ur', autoCorrect: true });

    let translatedTafsirEnglish = await translate(json.data.tafsir.id, { to: 'en', autoCorrect: true });

    let quranSurah = `
ğŸ•‹ *Quran: The Holy Book â™¥ï¸ğŸŒ¹Ù‚Ø±Ø¢Ù† Ù…Ø¬ÛŒØ¯ğŸŒ¹â™¥ï¸*\n
ğŸ“– *Surah ${json.data.number}: ${json.data.asma.ar.long} (${json.data.asma.en.long})*\n
ğŸ’«Type: ${json.data.type.en}\n
âœ…Number of verses: ${json.data.ayahCount}\n
âš¡ğŸ”® *Explanation (Urdu):*\n
${translatedTafsirUrdu.text}\n
âš¡ğŸ”® *Explanation (English):*\n
${translatedTafsirEnglish.text}`;

    await conn.sendMessage(
      from,
      {
        image: { url: `https://files.catbox.moe/fbm1sw.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir bravin',
                        serverMessageId: 143
          }
        }
      },
      { quoted: mek }
    );

    if (json.data.recitation.full) {
      await conn.sendMessage(from, {
        audio: { url: json.data.recitation.full },
        mimetype: 'audio/mpeg',  
        ptt: true
      }, { quoted: mek });
    }

  } catch (error) {
    console.error(error);
    reply(`Error: ${error.message}`);
  }
});


cmd({
    pattern: "quranmenu",
    alias: ["surahmenu", "surahlist"],
    desc: "menu the bot",
    category: "menu",
    react: "â¤ï¸",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body,isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let dec = `â¤ï¸  âŠ·â”ˆ *QURAN KAREEM* â”ˆâŠ·  ğŸ¤

 ğŸ’« ğ˜ˆğ˜­ğ˜­ ğ˜´ğ˜¶ğ˜³ğ˜¢ğ˜© ğ˜¢ğ˜¯ğ˜¥ ğ˜µğ˜©ğ˜¦ğ˜ªğ˜³ ğ˜¯ğ˜¶ğ˜®ğ˜£ğ˜¦ğ˜³ğ˜´ ğ˜­ğ˜ªğ˜´ğ˜µ
ğ˜§ğ˜°ğ˜³ ğ˜¨ğ˜¦ğ˜µğ˜µğ˜ªğ˜¯ğ˜¨ ğ˜´ğ˜¶ğ˜³ğ˜¢ğ˜© ğ˜µğ˜ºğ˜±ğ˜¦ .ğ˜´ğ˜¶ğ˜³ğ˜¢ğ˜© 36 ğŸ’«ğŸŒ¸ 

1. ğŸ•Œ Al-Fatiha (The Opening) - Ø§Ù„ÙØ§ØªØ­Û (Ù¾ÛÙ„Ø§ Ø³ÙˆØ±Û)


2. ğŸ„ Al-Baqarah (The Cow) - Ø§Ù„Ø¨Ù‚Ø±Û (Ú¯Ø§Ø¦Û’)


3. ğŸ  Aali Imran (The Family of Imran) - Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù† (Ø¹Ù…Ø±Ø§Ù† Ú©Ø§ Ø®Ø§Ù†Ø¯Ø§Ù†)


4. ğŸ‘© An-Nisa' (The Women) - Ø§Ù„Ù†Ø³Ø§Ø¡ (Ø¹ÙˆØ±ØªÛŒÚº)


5. ğŸ½ï¸ Al-Ma'idah (The Table Spread) - Ø§Ù„Ù…Ø§Ø¦Ø¯Û (Ù¾Ú¾ÛŒÙ„ÛŒ ÛÙˆØ¦ÛŒ Ù…ÛŒØ²)


6. ğŸª Al-An'am (The Cattle) - Ø§Ù„Ø§Ù†Ø¹Ø§Ù… (Ù…ÙˆÛŒØ´ÛŒ)


7. â›°ï¸ Al-A'raf (The Heights) - Ø§Ù„Ø£Ø¹Ø±Ø§Ù (Ø¨Ù„Ù†Ø¯ÛŒØ§Úº)


8. âš”ï¸ Al-Anfal (The Spoils of War) - Ø§Ù„Ø§Ù†ÙØ§Ù„ (ØºÙ†Ø§Ø¦Ù…)


9. ğŸ™ At-Tawbah (The Repentance) - Ø§Ù„ØªÙˆØ¨Û (ØªÙˆØ¨Û)


10. ğŸŸ Yunus (Jonah) - ÛŒÙˆÙ†Ø³ (ÛŒÙˆÙ†Ø³)


11. ğŸŒ©ï¸ Hud (Hud) - ÛÙˆØ¯ (ÛÙˆØ¯)


12. ğŸ‘¶ Yusuf (Joseph) - ÛŒÙˆØ³Ù (ÛŒÙˆØ³Ù)


13. âš¡ Ar-Rad (The Thunder) - Ø§Ù„Ø±Ø¹Ø¯ (Ú¯Ø±Ø¬)


14. ğŸ•Šï¸ Ibrahim (Abraham) - Ø§Ø¨Ø±Ø§ÛÛŒÙ… (Ø§Ø¨Ø±Ø§ÛÛŒÙ…)


15. ğŸª¨ Al-Hijr (The Rocky Tract) - Ø§Ù„Ø­Ø¬Ø± (Ù¾ØªÚ¾Ø±Ø§Ø¦ÛŒ Ø²Ù…ÛŒÙ†)


16. ğŸ An-Nahl (The Bee) - Ø§Ù„Ù†Ø­Ù„ (Ù…Ú©Ú¾ÛŒ)


17. ğŸŒ™ Al-Isra' (The Night Journey) - Ø§Ù„Ø¥Ø³Ø±Ø§Ø¡ (Ø±Ø§Øª Ú©Ø§ Ø³ÙØ±)


18. ğŸ•³ï¸ Al-Kahf (The Cave) - Ø§Ù„Ú©ÛÙ (ØºØ§Ø±)


19. ğŸ§•ğŸ» Maryam (Mary) - Ù…Ø±ÛŒÙ… (Ù…Ø±ÛŒÙ…)


20. ğŸ“œ Ta-Ha (Ta-Ha) - Ø·Ù°ÛÙ° (Ø·Ù°ÛÙ°)


21. ğŸ“– Al-Anbiya' (The Prophets) - Ø§Ù„Ø§Ù†Ø¨ÛŒØ§Ø¡ (Ù¾ÛŒØºÙ…Ø¨Ø±ÙˆÚº)


22. ğŸ•‹ Al-Hajj (The Pilgrimage) - Ø§Ù„Ø­Ø¬ (Ø­Ø¬)


23. ğŸ™Œ Al-Mu'minun (The Believers) - Ø§Ù„Ù…Ø¤Ù…Ù†ÙˆÙ† (Ø§ÛŒÙ…Ø§Ù† ÙˆØ§Ù„Û’)


24. ğŸ’¡ An-Nur (The Light) - Ø§Ù„Ù†ÙˆØ± (Ø±ÙˆØ´Ù†ÛŒ)


25. âš–ï¸ Al-Furqan (The Criterion) - Ø§Ù„ÙØ±Ù‚Ø§Ù† (ÙØ±Ù‚ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§)


26. ğŸ¤ Ash-Shu'ara' (The Poets) - Ø§Ù„Ø´Ø¹Ø±Ø§Ø¡ (Ø´Ø§Ø¹Ø±)


27. ğŸœ An-Naml (The Ant) - Ø§Ù„Ù†Ù…Ù„ (Ú†Ú‘ÛŒØ§)


28. ğŸ“š Al-Qasas (The Stories) - Ø§Ù„Ù‚ØµØµ (Ú©ÛØ§Ù†ÛŒØ§Úº)


29. ğŸ•·ï¸ Al-Ankabut (The Spider) - Ø§Ù„Ø£Ù†Ø¹Ø§Ù… (Ù…Ú©Ú‘ÛŒ)


30. ğŸ›ï¸ Ar-Rum (The Romans) - Ø§Ù„Ø±ÙˆÙ… (Ø±ÙˆÙ…ÛŒ)


31. ğŸ“– Luqman (Luqman) - Ù„Ù‚Ù…Ø§Ù† (Ù„Ù‚Ù…Ø§Ù†)


32. ğŸ™‡ As-Sajda (The Prostration) - Ø§Ù„Ø³Ø¬Ø¯Û (Ø³Ø¬Ø¯Û)


33. âš”ï¸ Al-Ahzab (The Combined Forces) - Ø§Ù„Ø§Ø­Ø²Ø§Ø¨ (Ù…Ø®Ù„ÙˆØ· Ù‚ÙˆØªÛŒÚº)


34. ğŸŒ¸ Saba' (Sheba) - Ø³Ø¨Ø§ (Ø³Ø¨Ø§)


35. ğŸ› ï¸ Fatir (The Originator) - ÙØ§Ø·Ø± (Ø®Ø§Ù„Ù‚)


36. ğŸ“– Ya-Sin (Ya-Sin) - ÛŒØ³ (ÛŒØ³)


37. ğŸ›¡ï¸ As-Saffat (Those who set the Ranks) - Ø§Ù„ØµØ§ÙØ§Øª (ØµÙÛŒÚº Ù…Ø±ØªØ¨ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Û’)


38. ğŸ…±ï¸ Sad (The Letter Sad) - ØµØ§Ø¯ (Ø­Ø±Ù ØµØ§Ø¯)


39. ğŸª– Az-Zumar (The Troops) - Ø§Ù„Ø²Ù…Ø± (Ø¬Ù†Ú¯ÛŒ Ø¯Ø³ØªÛ’)


40. ğŸ¤² Ghafir (The Forgiver) - ØºØ§ÙØ± (Ø¨Ø®Ø´Ù†Û’ ÙˆØ§Ù„Ø§)


41. ğŸ“œ Fussilat (Explained in Detail) - ÙØµÙ„Øª (ØªÙØµÛŒÙ„ Ø³Û’ Ø¨ÛŒØ§Ù†)


42. ğŸ—£ï¸ Ash-Shura (Consultation) - Ø§Ù„Ø´ÙˆØ±ÛŒ (Ù…Ø´Ø§ÙˆØ±Øª)


43. ğŸ’° Az-Zukhruf (The Gold Adornments) - Ø§Ù„Ø²Ø®Ø±Ù (Ø³ÙˆÙ†Û’ Ú©Û’ Ø²ÛŒÙˆØ±)


44. ğŸ’¨ Ad-Dukhan (The Smoke) - Ø§Ù„Ø¯Ø®Ø§Ù† (Ø¯Ú¾ÙˆØ§Úº)


45. ğŸŠ Al-Jathiyah (The Crouching) - Ø§Ù„Ø¬Ø§Ø«ÛŒÛ (Ø¬Ú¾Ú©Ù†Ø§)


46. ğŸŒªï¸ Al-Ahqaf (The Wind-Curved Sandhills) - Ø§Ù„Ø£Ø­Ù‚Ø§Ù (ÛÙˆØ§Ø¦ÛŒ Ú†Ú©Ø±ÙˆÚº ÙˆØ§Ù„ÛŒ Ø±ÛŒØª Ú©ÛŒ Ù¾ÛØ§Ú‘ÛŒØ§Úº)


47. ğŸ•‹ Muhammad (Muhammad) - Ù…Ø­Ù…Ø¯ (Ù…Ø­Ù…Ø¯)


48. ğŸ† Al-Fath (The Victory) - Ø§Ù„ÙØªØ­ (ÙØªØ­)


49. ğŸ  Al-Hujurat (The Rooms) - Ø§Ù„Ø­Ø¬Ø±Ø§Øª (Ú©Ù…Ø±Û’)


50. ğŸ”¤ Qaf (The Letter Qaf) - Ù‚Ø§Ù (Ø­Ø±Ù Ù‚Ø§Ù)


51. ğŸŒ¬ï¸ Adh-Dhariyat (The Winnowing Winds) - Ø§Ù„Ø°Ø§Ø±ÛŒØ§Øª (Ù¾Ú¾Ù¹Ù†Û’ ÙˆØ§Ù„ÛŒ ÛÙˆØ§Ø¦ÛŒÚº)


52. â›°ï¸ At-Tur (The Mount) - Ø§Ù„Ø·ÙˆØ± (Ù¾ÛØ§Ú‘)


53. ğŸŒŸ An-Najm (The Star) - Ø§Ù„Ù†Ø¬Ù… (Ø³ØªØ§Ø±Û)


54. ğŸŒ™ Al-Qamar (The Moon) - Ø§Ù„Ù‚Ù…Ø± (Ú†Ø§Ù†Ø¯)


55. ğŸ’– Ar-Rahman (The Beneficent) - Ø§Ù„Ø±Ø­Ù…Ù† (Ø¨ÛØª Ù…ÛØ±Ø¨Ø§Ù†)


56. ğŸŒŒ Al-Waqi'a (The Inevitable) - Ø§Ù„ÙˆØ§Ù‚Ø¹Û (ÛÙˆÙ†Û’ ÙˆØ§Ù„Ø§)


57. ğŸ”© Al-Hadid (The Iron) - Ø§Ù„Ø­Ø¯ÛŒØ¯ (Ù„ÙˆÛØ§)


58. ğŸ‘©â€âš–ï¸ Al-Mujadila (The Pleading Woman) - Ø§Ù„Ù…Ø¬Ø§Ø¯Ù„Û (Ù…Ø¯Ø¹ÛŒ Ø¹ÙˆØ±Øª)


59. ğŸ´ Al-Hashr (The Exile) - Ø§Ù„Ø­Ø´Ø± (Ø§Ø®Ø±Ø§Ø¬)


60. ğŸ” Al-Mumtahanah (She that is to be examined) - Ø§Ù„Ù…Ù…ØªØ­Ù†Û (Ø¬Ø§Ù†Ú†Ù†Û’ ÙˆØ§Ù„ÛŒ)


61. ğŸ“Š As-Saff (The Ranks) - Ø§Ù„ØµÙ (ØµÙÛŒÚº)


62. ğŸ•Œ Al-Jumu'ah (Friday) - Ø§Ù„Ø¬Ù…Ø¹Ø© (Ø¬Ù…Ø¹Û)


63. ğŸ¤¥ Al-Munafiqun (The Hypocrites) - Ø§Ù„Ù…Ù†Ø§ÙÙ‚ÙˆÙ† (Ù…Ù†Ø§ÙÙ‚)


64. ğŸŒªï¸ At-Taghabun (Mutual Disillusion) - Ø§Ù„ØªØºØ§Ø¨Ù† (Ø¢Ù¾Ø³ Ú©ÛŒ Ø¨Û’ ÙˆÙ‚ÙˆÙÛŒ)


65. ğŸ’” At-Talaq (The Divorce) - Ø§Ù„Ø·Ù„Ø§Ù‚ (Ø·Ù„Ø§Ù‚)


66. ğŸš« At-Tahrim (The Prohibition) - Ø§Ù„ØªØ­Ø±ÛŒÙ… (Ù¾Ø§Ø¨Ù†Ø¯ÛŒ)


67. ğŸ‘‘ Al-Mulk (The Sovereignty) - Ø§Ù„Ù…ÙÙ„Ùƒ (Ø­Ú©ÙˆÙ…Øª)


68. ğŸ–‹ï¸ Al-Qalam (The Pen) - Ø§Ù„Ù‚Ù„Ù… (Ù‚Ù„Ù…)


69. ğŸ” Al-Haqqah (The Reality) - Ø§Ù„Ø­Ù‚Û (Ø­Ù‚ÛŒÙ‚Øª)


70. â¬†ï¸ Al-Ma'arij (The Ascending Stairways) - Ø§Ù„Ù…Ø¹Ø§Ø±Ø¬ (Ú†Ú‘Ú¾Ù†Û’ Ú©ÛŒ Ø³ÛŒÚ‘Ú¾ÛŒØ§Úº)


71. ğŸŒŠ Nuh (Noah) - Ù†ÙˆØ­ (Ù†ÙˆØ­)


72. ğŸ‘» Al-Jinn (The Jinn) - Ø§Ù„Ø¬Ù† (Ø¬Ù†Ø§Øª)


73. ğŸ•µï¸â€â™‚ï¸ Al-Muzzammil (The Enshrouded One) - Ø§Ù„Ù…Ø²Ù…Ù„ (Ú†Ø§Ø¯Ø± Ø§ÙˆÚ‘Ú¾Û’ ÛÙˆØ¦Û’)


74. ğŸ§• Al-Muddathir (The Cloaked One) - Ø§Ù„Ù…ÙØ¯Ø«Ø± (Ù¾ÙˆØ´ÛŒØ¯Û)


75. ğŸŒ… Al-Qari'ah (The Calamity) - Ø§Ù„Ù‚Ø§Ø±Ø¹Ø© (Ø¢ÙØª)


76. ğŸ§‘â€ğŸ¤â€ğŸ§‘ Al-Insan (Man) - Ø§Ù„Ø§Ù†Ø³Ø§Ù† (Ø§Ù†Ø³Ø§Ù†)


77. âœ‰ï¸ Al-Mursalat (The Emissaries) - Ø§Ù„Ù…ÙØ±Ø³Ù„Ø§Øª (Ù¾ÛÙ†Ú†Ø§Ù†Û’ ÙˆØ§Ù„Û’)


78. ğŸ“£ An-Naba' (The Tidings) - Ø§Ù„Ù†Ø¨Ø£ (Ø®Ø¨Ø±ÛŒÚº)


79. ğŸª¤ An-Nazi'at (Those who drag forth) - Ø§Ù„Ù†Ø§Ø²Ø¹Ø§Øª (Ú©Ú¾ÛŒÙ†Ú†Ù†Û’ ÙˆØ§Ù„Û’)


80. ğŸ˜  Abasa (He frowned) - Ø¹Ø¨Ø³ (Ø§Ø³ Ù†Û’ Ú†ÛØ±Û Ø¨Ø¯Ù„Ø§)


81. ğŸ’¥ At-Takwir (The Overthrowing) - Ø§Ù„ØªÚ©ÙˆÙŠØ± (Ù¾Ú¾Ù¹Ù†Ø§)


82. ğŸ’” Al-Infitar (The Cleaving) - Ø§Ù„Ø§Ù†ÙØ·Ø§Ø± (Ù¾Ú¾Ù¹Ù†Ø§)


83. âš–ï¸ Al-Mutaffifin (Defrauding) - Ø§Ù„Ù…Ø·ÙÙÙŠÙ† (Ú©Ù… ØªÙˆÙ„Ù†Û’ ÙˆØ§Ù„Û’)


84. ğŸŒ€ Al-Inshiqaq (The Splitting Open) - Ø§Ù„Ø§Ù†Ø´Ù‚Ø§Ù‚ (Ù¾Ú¾Ù¹Ù†Ø§)


85. ğŸŒŒ Al-Buruj (The Mansions of the Stars) - Ø§Ù„Ø¨Ø±ÙˆØ¬ (Ø³ØªØ§Ø±ÙˆÚº Ú©Û’ Ú¯Ú¾Ø±)


86. ğŸŒ  At-Tariq (The Morning Star) - Ø§Ù„Ø·Ø§Ø±Ù‚ (ØµØ¨Ø­ Ú©Ø§ Ø³ØªØ§Ø±Û)


87. ğŸŒ Al-Ala (The Most High) - Ø§Ù„Ø£Ø¹Ù„Ù‰ (Ø³Ø¨ Ø³Û’ Ø¨Ù„Ù†Ø¯)


88. ğŸŒŠ Al-Ghashiyah (The Overwhelming) - Ø§Ù„ØºØ§Ø´ÛŒÛ (Ù¾Ø±Ø§Ù…Ù†)


89. ğŸŒ… Al-Fajr (The Dawn) - Ø§Ù„ÙØ¬Ø± (ØµØ¨Ø­)


90. ğŸ™ï¸ Al-Balad (The City) - Ø§Ù„Ø¨Ù„Ø¯ (Ø´ÛØ±)


91. â˜€ï¸ Ash-Shams (The Sun) - Ø§Ù„Ø´Ù…Ø³ (Ø³ÙˆØ±Ø¬)


92. ğŸŒœ Al-Lail (The Night) - Ø§Ù„Ù„ÛŒÙ„ (Ø±Ø§Øª)


93. ğŸŒ… Ad-Duha (The Morning Hours) - Ø§Ù„Ø¶Ø­ÛŒ (ØµØ¨Ø­ Ú©Û’ Ú¯Ú¾Ù†Ù¹Û’)


94. ğŸ“– As-Sharh (The Relief) - Ø§Ù„Ø´Ø±Ø­ (Ø¢Ø±Ø§Ù…)


95. ğŸˆ At-Tin (The Fig) - Ø§Ù„ØªÛŒÙ† (Ø§Ù†Ø¬ÛŒØ±)


96. ğŸ’§ Al-Alaq (The Clot) - Ø§Ù„Ø¹Ù„Ù‚ (Ø®ÙˆÙ† Ú©Ø§ Ù„ÙˆØªÚ¾Ú‘Ø§)


97. âš¡ Al-Qadr (The Power) - Ø§Ù„Ù‚Ø¯Ø± (Ù‚Ø¯Ø±Øª)


98. ğŸ“œ Al-Bayyinah (The Clear Proof) - Ø§Ù„Ø¨ÛŒÙ†Ø© (ÙˆØ§Ø¶Ø­ Ø¯Ù„ÛŒÙ„)


99. ğŸŒ Az-Zalzalah (The Earthquake) - Ø§Ù„Ø²Ù„Ø²Ù„Ø© (Ø²Ù„Ø²Ù„Û)


100. ğŸ Al-Adiyat (The Chargers) - Ø§Ù„Ø¹Ø§Ø¯ÛŒØ§Øª (Ú†Ø§Ø±Ø¬ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Û’)


101. âš¡ Al-Qari'ah (The Calamity) - Ø§Ù„Ù‚Ø§Ø±Ø¹Ø© (Ø¢ÙØª)


102. ğŸ’° At-Takathur (The Abundance of Wealth) - Ø§Ù„ØªÚ©Ø§Ø«Ø± (Ù…Ø§Ù„ Ú©ÛŒ Ú©Ø«Ø±Øª)


103. â³ Al-Asr (The Time) - Ø§Ù„Ø¹ØµØ± (ÙˆÙ‚Øª)


104. ğŸ˜  Al-Humazah (The Scandal-Monger) - Ø§Ù„ÛÙ…Ø²Û (Ú†ØºÙ„ÛŒ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§)


105. ğŸ˜ Al-Fil (The Elephant) - Ø§Ù„ÙÛŒÙ„ (ÛØ§ØªÚ¾ÛŒ)


106. ğŸ•Œ Quraysh (Quraysh) - Ù‚Ø±ÛŒØ´ (Ù‚Ø±ÛŒØ´)


107. ğŸ¤² Al-Ma'un (Acts of Kindness) - Ø§Ù„Ù…Ø§Ø¹ÙˆÙ† (Ù†ÛŒÚ©ÛŒ Ú©Û’ Ú©Ø§Ù…)


108. ğŸ‡ Al-Kawthar (The Abundance) - Ø§Ù„Ú©ÙˆØ«Ø± (Ú©Ø«Ø±Øª)


109. âŒ Al-Kafirun (The Disbelievers) - Ø§Ù„Ú©Ø§ÙØ±ÙˆÙ† (Ú©Ø§ÙØ±)


110. ğŸ›¡ï¸ An-Nasr (The Help) - Ø§Ù„Ù†ØµØ± (Ù…Ø¯Ø¯)


111. ğŸ”¥ Al-Lahab (The Flame) - Ø§Ù„Ù„ÛØ¨ (Ø´Ø¹Ù„Û)


112. â¤ï¸ Al-Ikhlas (The Sincerity) - Ø§Ù„Ø¥Ø®Ù„Ø§Øµ (Ø§Ø®Ù„Ø§Øµ)


113. ğŸŒ… Al-Falaq (The Daybreak) - Ø§Ù„ÙÙ„Ù‚ (Ø·Ù„ÙˆØ¹ ØµØ¨Ø­)


114. ğŸŒ An-Nas (Mankind) - Ø§Ù„Ù†Ø§Ø³ (Ø§Ù†Ø³Ø§Ù†ÛŒØª)`;

        await conn.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/fbm1sw.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'sir bravin',
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

        await conn.sendMessage(from, {
            audio: { url: 'https://github.com/criss-vevo/CRISS-DATA/raw/refs/heads/main/autovoice/Quran.m4a' },
            mimetype: 'audio/mp4',
            ptt: false
        }, { quoted: mek });
        
    } catch (e) {
        console.log(e);
        reply(`${e}`);
    }
});

const { cmd } = require("../command");
const { fetchGif, gifToVideo } = require("../lib/fetchGif");
const axios = require("axios");

cmd(
    {
        pattern: "cry",
        desc: "Send a crying reaction GIF.",
        category: "fun",
        react: "ğŸ˜¢",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is crying over @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is crying!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/cry";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .cry command:", error);
            reply(`âŒ *Error in .cry command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "cuddle",
        desc: "Send a cuddle reaction GIF.",
        category: "fun",
        react: "ğŸ¤—",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} cuddled @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is cuddling everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/cuddle";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .cuddle command:", error);
            reply(`âŒ *Error in .cuddle command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bully",
        desc: "Send a bully reaction GIF.",
        category: "fun",
        react: "ğŸ˜ˆ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is bullying @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is bullying everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/bully";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .bully command:", error);
            reply(`âŒ *Error in .bully command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "hug",
        desc: "Send a hug reaction GIF.",
        category: "fun",
        react: "ğŸ¤—",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} hugged @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is hugging everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/hug";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .hug command:", error);
            reply(`âŒ *Error in .hug command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "awoo",
        desc: "Send an awoo reaction GIF.",
        category: "fun",
        react: "ğŸº",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} awoos at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is awooing everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/awoo";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .awoo command:", error);
            reply(`âŒ *Error in .awoo command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "lick",
        desc: "Send a lick reaction GIF.",
        category: "fun",
        react: "ğŸ‘…",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);

            let message = mentionedUser ? `${sender} licked @${mentionedUser.split("@")[0]}` : `${sender} licked themselves!`;

            const apiUrl = "https://api.waifu.pics/sfw/lick";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .lick command:", error);
            reply(`âŒ *Error in .lick command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
  
cmd(
    {
        pattern: "pat",
        desc: "Send a pat reaction GIF.",
        category: "fun",
        react: "ğŸ«‚",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} patted @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is patting everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/pat";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .pat command:", error);
            reply(`âŒ *Error in .pat command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "smug",
        desc: "Send a smug reaction GIF.",
        category: "fun",
        react: "ğŸ˜",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is smug at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is feeling smug!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/smug";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .smug command:", error);
            reply(`âŒ *Error in .smug command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bonk",
        desc: "Send a bonk reaction GIF.",
        category: "fun",
        react: "ğŸ”¨",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} bonked @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is bonking everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/bonk";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .bonk command:", error);
            reply(`âŒ *Error in .bonk command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "yeet",
        desc: "Send a yeet reaction GIF.",
        category: "fun",
        react: "ğŸ’¨",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} yeeted @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is yeeting everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/yeet";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .yeet command:", error);
            reply(`âŒ *Error in .yeet command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "blush",
        desc: "Send a blush reaction GIF.",
        category: "fun",
        react: "ğŸ˜Š",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is blushing at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is blushing!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/blush";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .blush command:", error);
            reply(`âŒ *Error in .blush command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);  
  
cmd(
    {
        pattern: "handhold",
        desc: "Send a hand-holding reaction GIF.",
        category: "fun",
        react: "ğŸ¤",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is holding hands with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} wants to hold hands with everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/handhold";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .handhold command:", error);
            reply(`âŒ *Error in .handhold command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "highfive",
        desc: "Send a high-five reaction GIF.",
        category: "fun",
        react: "âœ‹",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} gave a high-five to @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is high-fiving everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/highfive";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .highfive command:", error);
            reply(`âŒ *Error in .highfive command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);  

cmd(
    {
        pattern: "nom",
        desc: "Send a nom reaction GIF.",
        category: "fun",
        react: "ğŸ½ï¸",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is nomming @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is nomming everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/nom";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .nom command:", error);
            reply(`âŒ *Error in .nom command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "wave",
        desc: "Send a wave reaction GIF.",
        category: "fun",
        react: "ğŸ‘‹",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} waved at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is waving at everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/wave";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .wave command:", error);
            reply(`âŒ *Error in .wave command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "smile",
        desc: "Send a smile reaction GIF.",
        category: "fun",
        react: "ğŸ˜",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} smiled at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is smiling at everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/smile";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .smile command:", error);
            reply(`âŒ *Error in .smile command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "wink",
        desc: "Send a wink reaction GIF.",
        category: "fun",
        react: "ğŸ˜‰",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} winked at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is winking at everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/wink";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .wink command:", error);
            reply(`âŒ *Error in .wink command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "happy",
        desc: "Send a happy reaction GIF.",
        category: "fun",
        react: "ğŸ˜Š",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is happy with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is happy with everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/happy";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .happy command:", error);
            reply(`âŒ *Error in .happy command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "glomp",
        desc: "Send a glomp reaction GIF.",
        category: "fun",
        react: "ğŸ¤—",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} glomped @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is glomping everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/glomp";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .glomp command:", error);
            reply(`âŒ *Error in .glomp command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bite",
        desc: "Send a bite reaction GIF.",
        category: "fun",
        react: "ğŸ¦·",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} bit @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is biting everyone!`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/bite";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .bite command:", error);
            reply(`âŒ *Error in .bite command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "poke",
        desc: "Send a poke reaction GIF.",
        category: "fun",
        react: "ğŸ‘‰",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} poked @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} poked everyone`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/poke";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .poke command:", error);
            reply(`âŒ *Error in .poke command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
  
  
cmd(
    {
        pattern: "cringe",
        desc: "Send a cringe reaction GIF.",
        category: "fun",
        react: "ğŸ˜¬",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} thinks @${mentionedUser.split("@")[0]} is cringe`
                : isGroup
                ? `${sender} finds everyone cringe`
                : `> Â© Powered By sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/cringe";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .cringe command:", error);
            reply(`âŒ *Error in .cringe command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "dance",
        desc: "Send a dance reaction GIF.",
        category: "fun",
        react: "ğŸ’ƒ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} danced with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is dancing with everyone`
                : `> Â© Powered By Sir bravin ğŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/dance";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .dance command:", error);
            reply(`âŒ *Error in .dance command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


  
cmd(
    {
        pattern: "kill",
        desc: "Send a kill reaction GIF.",
        category: "fun",
        react: "ğŸ”ª",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} killed ${target}`;
            } else if (isGroup) {
                message = `${sender} killed everyone`;
            } else {
                message = `> Â© Powered By sir bravin ğŸ–¤`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/kill";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .kill command:", error);
            reply(`âŒ *Error in .kill command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "slap",
        desc: "Send a slap reaction GIF.",
        category: "fun",
        react: "âœŠ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} slapped ${target}`;
            } else if (isGroup) {
                message = `${sender} slapped everyone`;
            } else {
                message = `> Â© Powered By sir bravin ğŸ–¤`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/slap";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .slap command:", error);
            reply(`âŒ *Error in .slap command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "kiss",
        desc: "Send a kiss reaction GIF.",
        category: "fun",
        react: "ğŸ’‹",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} kissed ${target}`;
            } else if (isGroup) {
                message = `${sender} kissed everyone`;
            } else {
                message = `> Â© Powered By sir bravin ğŸ–¤`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/kiss";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .kiss command:", error);
            reply(`âŒ *Error in .kiss command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

const { cmd } = require("../command");

cmd({
  pattern: "caption",
  alias: ["cap", "recaption", "c"],
  react: 'ğŸ¦¥',
  desc: "Add or change caption of media/document",
  category: "utility",
  filename: __filename
}, async (client, message, match, { from }) => {
  try {
    if (!message.quoted) {
      return await client.sendMessage(from, {
        text: "*ğŸ Please reply to a media message (image/video/document) to add caption!*\n\n*Usage:*\n- Reply to media with .caption [your text]\n- Or just .caption [text] to add caption to previous media"
      }, { quoted: message });
    }

    const quotedMsg = message.quoted;
    if (!quotedMsg || !quotedMsg.download) {
      return await client.sendMessage(from, {
        text: "âŒ The quoted message is not valid media"
      }, { quoted: message });
    }

    const buffer = await quotedMsg.download();
    const mtype = quotedMsg.mtype;
    
    // Get the caption text (everything after the command)
    const cmdText = message.body.split(' ')[0].toLowerCase();
    const newCaption = message.body.slice(cmdText.length).trim();

    if (!buffer) {
      return await client.sendMessage(from, {
        text: "âŒ Failed to download the media"
      }, { quoted: message });
    }

    // Create the base message content
    const messageContent = {
      caption: newCaption,
      mimetype: quotedMsg.mimetype
    };

    // Add the appropriate media property based on type
    switch (mtype) {
      case "imageMessage":
        messageContent.image = buffer;
        messageContent.mimetype = messageContent.mimetype || "image/jpeg";
        break;
      case "videoMessage":
        messageContent.video = buffer;
        messageContent.mimetype = messageContent.mimetype || "video/mp4";
        break;
      case "documentMessage":
        messageContent.document = buffer;
        messageContent.mimetype = messageContent.mimetype || "application/octet-stream";
        break;
      case "audioMessage":
        messageContent.audio = buffer;
        messageContent.mimetype = messageContent.mimetype || "audio/mp4";
        messageContent.ptt = quotedMsg.ptt || false;
        break;
      default:
        return await client.sendMessage(from, {
          text: "âŒ Only image, video, document and audio messages can be recaptioned"
        }, { quoted: message });
    }

    // Send the message with media and caption
    await client.sendMessage(from, messageContent, { quoted: message });

  } catch (error) {
    console.error("Caption Error:", error);
    await client.sendMessage(from, {
      text: "âŒ Error adding caption:\n" + (error.message || error.toString())
    }, { quoted: message });
  }
});

const axios = require("axios");
const { cmd } = require("../command");

cmd({
  pattern: "srepo",
  desc: "Fetch information about a GitHub repository.",
  category: "other",
  react: "ğŸ–¥ï¸",
  filename: __filename
}, async (conn, m, store, { from, args, reply }) => {
  try {
    const repoName = args.join(" ");
    if (!repoName) {
      return reply("âŒ Please provide a GitHub repository in the format ğŸ“Œ `owner/repo`.");
    }

    const apiUrl = `https://api.github.com/repos/${repoName}`;
    const { data } = await axios.get(apiUrl);

    let responseMsg = `ğŸ“ *GitHub Repository Info* ğŸ“\n\n`;
    responseMsg += `ğŸ“Œ *Name*: ${data.name}\n`;
    responseMsg += `ğŸ”— *URL*: ${data.html_url}\n`;
    responseMsg += `ğŸ“ *Description*: ${data.description || "No description"}\n`;
    responseMsg += `â­ *Stars*: ${data.stargazers_count}\n`;
    responseMsg += `ğŸ´ *Forks*: ${data.forks_count}\n`;
    responseMsg += `ğŸ‘¤ *Owner*: ${data.owner.login}\n`;
    responseMsg += `ğŸ“… *Created At*: ${new Date(data.created_at).toLocaleDateString()}\n`;
    responseMsg += `\n> *Â© Powered by Êœá´œÉ´á´›á´‡Ê€ xá´á´…*`;

    await conn.sendMessage(from, { text: responseMsg }, { quoted: m });
  } catch (error) {
    console.error("GitHub API Error:", error);
    reply(`âŒ Error fetching repository data: ${error.response?.data?.message || error.message}`);
  }
});

const { cmd } = require("../command");  
const { sleep } = require("../lib/functions");  

cmd({  
    pattern: "restart",  
    desc: "Restart sir bravin",  
    category: "owner",  
    filename: __filename  
},  
async (conn, mek, m, { reply, isCreator }) => {  
    try {  
        if (!isCreator) {  
            return reply("Only the bot owner can use this command.");  
        }  

        const { exec } = require("child_process");  
        reply("Restarting...");  
        await sleep(1500);  
        exec("pm2 restart all");  
    } catch (e) {  
        console.error(e);  
        reply(`${e}`);  
    }  
});

const { cmd } = require("../command");
const axios = require("axios");

cmd({
  pattern: "rw",
  alias: ["randomwall", "wallpaper"],
  react: "ğŸ¦ ",
  desc: "Download random wallpapers based on keywords.",
  category: "wallpapers",
  use: ".rw <keyword>",
  filename: __filename
}, async (conn, m, store, { from, args, reply }) => {
  try {
    const query = args.join(" ") || "random";
    const apiUrl = `https://pikabotzapi.vercel.app/random/randomwall/?apikey=anya-md&query=${encodeURIComponent(query)}`;

    const { data } = await axios.get(apiUrl);
    
    if (data.status && data.imgUrl) {
      const caption = `ğŸŒŒ *Random Wallpaper: ${query}*\n\n> *Â© Powered by sir bravin*`;
      await conn.sendMessage(from, { image: { url: data.imgUrl }, caption }, { quoted: m });
    } else {
      reply(`âŒ No wallpaper found for *"${query}"*.`);
    }
  } catch (error) {
    console.error("Wallpaper Error:", error);
    reply("âŒ An error occurred while fetching the wallpaper. Please try again.");
  }
});

const axios = require("axios");
const { cmd } = require("../command");

cmd({
  pattern: "npm",
  desc: "Search for a package on npm.",
  react: 'ğŸ’',
  category: "convert",
  filename: __filename,
  use: ".npm <package-name>"
}, async (conn, mek, msg, { from, args, reply }) => {
  try {
    // Check if a package name is provided
    if (!args.length) {
      return reply("Please provide the name of the npm package you want to search for. Example: .npm express");
    }

    const packageName = args.join(" ");
    const apiUrl = `https://registry.npmjs.org/${encodeURIComponent(packageName)}`;

    // Fetch package details from npm registry
    const response = await axios.get(apiUrl);
    if (response.status !== 200) {
      throw new Error("Package not found or an error occurred.");
    }

    const packageData = response.data;
    const latestVersion = packageData["dist-tags"].latest;
    const description = packageData.description || "No description available.";
    const npmUrl = `https://www.npmjs.com/package/${packageName}`;
    const license = packageData.license || "Unknown";
    const repository = packageData.repository ? packageData.repository.url : "Not available";

    // Create the response message
    const message = `
*SIR BRAVIN NPM SEARCH*

*ğŸ”° NPM PACKAGE:* ${packageName}
*ğŸ“„ DESCRIPTION:* ${description}
*â¸ï¸ LAST VERSION:* ${latestVersion}
*ğŸªª LICENSE:* ${license}
*ğŸª© REPOSITORY:* ${repository}
*ğŸ”— NPM URL:* ${npmUrl}
`;

    // Send the message
    await conn.sendMessage(from, { text: message }, { quoted: mek });

  } catch (error) {
    console.error("Error:", error);
    reply("An error occurred: " + error.message);
  }
});

// code by â¿» âŒœ sir bravin âŒŸâ¿»Í›âƒ®ğŸ‡µğŸ‡°ğ–¤

const axios = require("axios");
const config = require('../config');
const { cmd } = require('../command');

cmd({
  pattern: "sss",
  alias: ["ssweb"],
  react: "ğŸ’«",
  desc: "Download screenshot of a given link.",
  category: "other",
  use: ".ss <link>",
  filename: __filename,
}, 
async (conn, mek, m, {
  from, l, quoted, body, isCmd, command, args, q, isGroup, sender, 
  senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, 
  groupMetadata, groupName, participants, isItzcp, groupAdmins, 
  isBotAdmins, isAdmins, reply 
}) => {
  if (!q) {
    return reply("Please provide a URL to capture a screenshot.");
  }

  try {
    // created by jawad tech 
    const response = await axios.get(`https://api.davidcyriltech.my.id/ssweb?url=${q}`);
    const screenshotUrl = response.data.screenshotUrl;

    // give credit and use
    const imageMessage = {
      image: { url: screenshotUrl },
      caption: "*WEB SS DOWNLOADER*\n\n> *Â© Powered By sir bravin*",
      contextInfo: {
        mentionedJid: [m.sender],
        forwardingScore: 999,
        isForwarded: true,
        forwardedNewsletterMessageInfo: {
          newsletterJid: '120363366284524544@newsletter',
          newsletterName: "sir bravin",
          serverMessageId: 143,
        },
      },
    };

    await conn.sendMessage(from, imageMessage, { quoted: m });
  } catch (error) {
    console.error(error);
    reply("Failed to capture the screenshot. Please try again.");
  }
});

// â¿» âŒœ sir bravin âŒŸâ¿»Í›âƒ®ğŸ‡µğŸ‡°ğ–¤

const { cmd } = require("../command");

cmd({
  pattern: "send",
  alias: ["sendme", 'save'],
  react: 'ğŸ«¶',
  desc: "Forwards quoted message back to user",
  category: "utility",
  filename: __filename
}, async (client, message, match, { from }) => {
  try {
    if (!match.quoted) {
      return await client.sendMessage(from, {
        text: "*ğŸ Please reply to a message!*"
      }, { quoted: message });
    }

    const buffer = await match.quoted.download();
    const mtype = match.quoted.mtype;
    const options = { quoted: message };

    let messageContent = {};
    switch (mtype) {
      case "imageMessage":
        messageContent = {
          image: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "image/jpeg"
        };
        break;
      case "videoMessage":
        messageContent = {
          video: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "video/mp4"
        };
        break;
      case "audioMessage":
        messageContent = {
          audio: buffer,
          mimetype: "audio/mp4",
          ptt: match.quoted.ptt || false
        };
        break;
      default:
        return await client.sendMessage(from, {
          text: "âŒ Only image, video, and audio messages are supported"
        }, { quoted: message });
    }

    await client.sendMessage(from, messageContent, options);
  } catch (error) {
    console.error("Forward Error:", error);
    await client.sendMessage(from, {
      text: "âŒ Error forwarding message:\n" + error.message
    }, { quoted: message });
  }
});

const { cmd } = require('../command');
const crypto = require('crypto');
const webp = require('node-webpmux');
const axios = require('axios');
const fs = require('fs-extra');
const { exec } = require('child_process');
const { Sticker, createSticker, StickerTypes } = require("wa-sticker-formatter");
const Config = require('../config');

// Take Sticker 

cmd(
    {
        pattern: 'take',
        alias: ['rename', 'stake'],
        desc: 'Create a sticker with a custom pack name.',
        category: 'sticker',
        use: '<reply media or URL>',
        filename: __filename,
    },
    async (conn, mek, m, { quoted, args, q, reply, from }) => {
        if (!mek.quoted) return reply(`*Reply to any sticker.*`);
        if (!q) return reply(`*Please provide a pack name using .take <packname>*`);

        let mime = mek.quoted.mtype;
        let pack = q;

        if (mime === "imageMessage" || mime === "stickerMessage") {
            let media = await mek.quoted.download();
            let sticker = new Sticker(media, {
                pack: pack, 
                type: StickerTypes.FULL,
                categories: ["ğŸ¤©", "ğŸ‰"],
                id: "12345",
                quality: 75,
                background: 'transparent',
            });
            const buffer = await sticker.toBuffer();
            return conn.sendMessage(mek.chat, { sticker: buffer }, { quoted: mek });
        } else {
            return reply("*Uhh, Please reply to an image.*");
        }
    }
);

//Sticker create 

cmd(
    {
        pattern: 'sticker',
        alias: ['s', 'stickergif'],
        desc: 'Create a sticker from an image, video, or URL.',
        category: 'sticker',
        use: '<reply media or URL>',
        filename: __filename,
    },
    async (conn, mek, m, { quoted, args, q, reply, from }) => {
        if (!mek.quoted) return reply(`*Reply to any Image or Video, Sir.*`);
        let mime = mek.quoted.mtype;
        let pack = Config.STICKER_NAME || "sir bravin";
        
        if (mime === "imageMessage" || mime === "stickerMessage") {
            let media = await mek.quoted.download();
            let sticker = new Sticker(media, {
                pack: pack, 
                type: StickerTypes.FULL,
                categories: ["ğŸ¤©", "ğŸ‰"], 
                id: "12345",
                quality: 75, 
                background: 'transparent',
            });
            const buffer = await sticker.toBuffer();
            return conn.sendMessage(mek.chat, { sticker: buffer }, { quoted: mek });
        } else {
            return reply("*Uhh, Please reply to an image.*");
        }
    }
);

// Criss Vevo

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "tagadmins",
    react: "ğŸ•µï¸",
    alias: ["gc_tagadmins"],
    desc: "To Tag all Admins of the Group",
    category: "group",
    use: '.tagadmins [message]',
    filename: __filename
},
async (conn, mek, m, { from, participants, reply, isGroup, senderNumber, groupAdmins, prefix, command, args, body }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        
        const botOwner = conn.user.id.split(":")[0]; // Extract bot owner's number
        const senderJid = senderNumber + "@s.whatsapp.net";

        // Ensure group metadata is fetched properly
        let groupInfo = await conn.groupMetadata(from).catch(() => null);
        if (!groupInfo) return reply("âŒ Failed to fetch group information.");

        let groupName = groupInfo.subject || "Unknown Group";
        let admins = await getGroupAdmins(participants);
        let totalAdmins = admins ? admins.length : 0;
        if (totalAdmins === 0) return reply("âŒ No admins found in this group.");

        let emojis = ['ğŸ‘‘', 'âš¡', 'ğŸŒŸ', 'âœ¨', 'ğŸ–ï¸', 'ğŸ’', 'ğŸ”±', 'ğŸ›¡ï¸', 'ğŸš€', 'ğŸ†'];
        let randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];

        // Proper message extraction
        let message = body.slice(body.indexOf(command) + command.length).trim();
        if (!message) message = "Attention Admins"; // Default message

        let teks = `â–¢ Group : *${groupName}*\nâ–¢ Admins : *${totalAdmins}*\nâ–¢ Message: *${message}*\n\nâ”Œâ”€â”€â”€âŠ· *ADMIN MENTIONS*\n`;

        for (let admin of admins) {
            if (!admin) continue; // Prevent undefined errors
            teks += `${randomEmoji} @${admin.split('@')[0]}\n`;
        }

        teks += "â””â”€â”€âœª CRISS â”ƒ AI âœªâ”€â”€";

        conn.sendMessage(from, { text: teks, mentions: admins }, { quoted: mek });

    } catch (e) {
        console.error("TagAdmins Error:", e);
        reply(`âŒ *Error Occurred !!*\n\n${e.message || e}`);
    }
});

const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

cmd({
    pattern: "tagall",
    react: "â˜ƒï¸",
    alias: ["gc_tagall"],
    desc: "To Tag all Members",
    category: "group",
    use: '.tagall [message]',
    filename: __filename
},
async (conn, mek, m, { from, participants, reply, isGroup, senderNumber, groupAdmins, prefix, command, args, body }) => {
    try {
        if (!isGroup) return reply("âŒ This command can only be used in groups.");
        
        const botOwner = conn.user.id.split(":")[0]; // Extract bot owner's number
        const senderJid = senderNumber + "@s.whatsapp.net";

        if (!groupAdmins.includes(senderJid) && senderNumber !== botOwner) {
            return reply("âŒ Only group admins or the bot owner can use this command.");
        }

        // Ensure group metadata is fetched properly
        let groupInfo = await conn.groupMetadata(from).catch(() => null);
        if (!groupInfo) return reply("âŒ Failed to fetch group information.");

        let groupName = groupInfo.subject || "Unknown Group";
        let totalMembers = participants ? participants.length : 0;
        if (totalMembers === 0) return reply("âŒ No members found in this group.");

        let emojis = ['ğŸ“¢', 'ğŸ”Š', 'ğŸŒ', 'ğŸ”°', 'â¤â€ğŸ©¹', 'ğŸ¤', 'ğŸ–¤', 'ğŸ©µ', 'ğŸ“', 'ğŸ’—', 'ğŸ”–', 'ğŸª©', 'ğŸ“¦', 'ğŸ‰', 'ğŸ›¡ï¸', 'ğŸ’¸', 'â³', 'ğŸ—¿', 'ğŸš€', 'ğŸ§', 'ğŸª€', 'âš¡', 'ğŸš©', 'ğŸ', 'ğŸ—£ï¸', 'ğŸ‘»', 'âš ï¸', 'ğŸ”¥'];
        let randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];

        // Proper message extraction
        let message = body.slice(body.indexOf(command) + command.length).trim();
        if (!message) message = "Attention Everyone"; // Default message

        let teks = `â–¢ Group : *${groupName}*\nâ–¢ Members : *${totalMembers}*\nâ–¢ Message: *${message}*\n\nâ”Œâ”€â”€â”€âŠ· *MENTIONS*\n`;

        for (let mem of participants) {
            if (!mem.id) continue; // Prevent undefined errors
            teks += `${randomEmoji} @${mem.id.split('@')[0]}\n`;
        }

        teks += "â””â”€â”€âœª CRISS â”ƒ AI âœªâ”€â”€";

        conn.sendMessage(from, { text: teks, mentions: participants.map(a => a.id) }, { quoted: mek });

    } catch (e) {
        console.error("TagAll Error:", e);
        reply(`âŒ *Error Occurred !!*\n\n${e.message || e}`);
    }
});

const fetch = require("node-fetch");
const { cmd } = require("../command");

cmd({
  pattern: "tiktoksearch",
  alias: ["tiktoks", "tiks"],
  desc: "Search for TikTok videos using a query.",
  react: 'ğŸª€',
  category: 'tools',
  filename: __filename
}, async (conn, m, store, {
  from,
  args,
  reply
}) => {
  if (!args[0]) {
    return reply("ğŸŒ¸ What do you want to search on TikTok?\n\n*Usage Example:*\n.tiktoksearch <query>");
  }

  const query = args.join(" ");
  await store.react('âŒ›');

  try {
    reply(`ğŸ” Searching TikTok for: *${query}*`);
    
    const response = await fetch(`https://apis-starlights-team.koyeb.app/starlight/tiktoksearch?text=${encodeURIComponent(query)}`);
    const data = await response.json();

    if (!data || !data.data || data.data.length === 0) {
      await store.react('âŒ');
      return reply("âŒ No results found for your query. Please try with a different keyword.");
    }

    // Get up to 7 random results
    const results = data.data.slice(0, 7).sort(() => Math.random() - 0.5);

    for (const video of results) {
      const message = `ğŸŒ¸ *TikTok Video Result*:\n\n`
        + `*â€¢ Title*: ${video.title}\n`
        + `*â€¢ Author*: ${video.author || 'Unknown'}\n`
        + `*â€¢ Duration*: ${video.duration || "Unknown"}\n`
        + `*â€¢ URL*: ${video.link}\n\n`;

      if (video.nowm) {
        await conn.sendMessage(from, {
          video: { url: video.nowm },
          caption: message
        }, { quoted: m });
      } else {
        reply(`âŒ Failed to retrieve video for *"${video.title}"*.`);
      }
    }

    await store.react('âœ…');
  } catch (error) {
    console.error("Error in TikTokSearch command:", error);
    await store.react('âŒ');
    reply("âŒ An error occurred while searching TikTok. Please try again later.");
  }
});

const { cmd } = require("../command");
const fetch = require("node-fetch");
const axios = require("axios");

cmd({
    pattern: "tiny",
    alias: ['short', 'shorturl'],
    react: "âš“",
    desc: "Makes URL tiny.",
    category: "convert",
    use: "<url>",
    filename: __filename,
},
async (conn, mek, m, { from, quoted, isOwner, isAdmins, reply, args }) => {
    console.log("Command tiny triggered"); // Ajoutez ceci pour vÃ©rifier si la commande est dÃ©clenchÃ©e

    if (!args[0]) {
        console.log("No URL provided"); // Ajoutez ceci pour vÃ©rifier si l'URL est fournie
        return reply("*ğŸ·ï¸ á´˜ÊŸá´‡á´€sá´‡ á´˜Ê€á´á´ Éªá´…á´‡ á´á´‡ á´€ ÊŸÉªÉ´á´‹.*");
    }

    try {
        const link = args[0];
        console.log("URL to shorten:", link); // Ajoutez ceci pour vÃ©rifier l'URL fournie
        const response = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`);
        const shortenedUrl = response.data;

        console.log("Shortened URL:", shortenedUrl); // Ajoutez ceci pour vÃ©rifier l'URL raccourcie
        return reply(`*ğŸ›¡ï¸YOUR SHORTENED URL*\n\n${shortenedUrl}`);
    } catch (e) {
        console.error("Error shortening URL:", e);
        return reply("An error occurred while shortening the URL. Please try again.");
    }
});

const { cmd, commands } = require('../command');
const config = require('../config');
const prefix = config.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');
const { writeFileSync } = require('fs');
const path = require('path');

cmd({
  pattern: "broadcast",
  category: "group",
  desc: "Bot makes a broadcast in all groups",
  filename: __filename,
  use: "<text for broadcast.>"
}, async (conn, mek, m, { q, isGroup, isAdmins, reply }) => {
  try {
    if (!isGroup) return reply("âŒ This command can only be used in groups!");
    if (!isAdmins) return reply("âŒ You need to be an admin to broadcast in this group!");

    if (!q) return reply("âŒ Provide text to broadcast in all groups!");

    let allGroups = await conn.groupFetchAllParticipating();
    let groupIds = Object.keys(allGroups); // Extract group IDs

    reply(`ğŸ“¢ Sending Broadcast To ${groupIds.length} Groups...\nâ³ Estimated Time: ${groupIds.length * 1.5} seconds`);

    for (let groupId of groupIds) {
      try {
        await sleep(1500); // Avoid rate limits
        await conn.sendMessage(groupId, { text: q }); // Sends only the provided text
      } catch (err) {
        console.log(`âŒ Failed to send broadcast to ${groupId}:`, err);
      }
    }

    return reply(`âœ… Successfully sent broadcast to ${groupIds.length} groups!`);
    
  } catch (err) {
    await m.error(`ğŸš« Error: ${err}\n\nCommand: broadcast`, err);
  }
});

const { cmd } = require('../command');
const axios = require('axios');

cmd({
    pattern: "countryinfo",
    alias: ["cinfo", "country","cinfo2"],
    desc: "Get information about a country",
    category: "info",
    react: "ğŸŒ¹",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply, react }) => {
    try {
        if (!q) return reply("Please provide a country name.\nExample: `.countryinfo Pakistan`");

        const apiUrl = `https://api.siputzx.my.id/api/tools/countryInfo?name=${encodeURIComponent(q)}`;
        const { data } = await axios.get(apiUrl);

        if (!data.status || !data.data) {
            await react("âŒ");
            return reply(`No information found for *${q}*. Please check the country name.`);
        }

        const info = data.data;
        let neighborsText = info.neighbors.length > 0
            ? info.neighbors.map(n => `ğŸŒ *${n.name}*`).join(", ")
            : "No neighboring countries found.";

        const text = `ğŸŒ *Country Information: ${info.name}* ğŸŒ\n\n` +
                     `ğŸ› *Capital:* ${info.capital}\n` +
                     `ğŸ“ *Continent:* ${info.continent.name} ${info.continent.emoji}\n` +
                     `ğŸ“ *Phone Code:* ${info.phoneCode}\n` +
                     `ğŸ“ *Area:* ${info.area.squareKilometers} kmÂ² (${info.area.squareMiles} miÂ²)\n` +
                     `ğŸš— *Driving Side:* ${info.drivingSide}\n` +
                     `ğŸ’± *Currency:* ${info.currency}\n` +
                     `ğŸ”¤ *Languages:* ${info.languages.native.join(", ")}\n` +
                     `ğŸŒŸ *Famous For:* ${info.famousFor}\n` +
                     `ğŸŒ *ISO Codes:* ${info.isoCode.alpha2.toUpperCase()}, ${info.isoCode.alpha3.toUpperCase()}\n` +
                     `ğŸŒ *Internet TLD:* ${info.internetTLD}\n\n` +
                     `ğŸ”— *Neighbors:* ${neighborsText}`;

        await conn.sendMessage(from, {
            image: { url: info.flag },
            caption: text,
            contextInfo: { mentionedJid: [m.sender] }
        }, { quoted: mek });

        await react("âœ…"); // React after successful response
    } catch (e) {
        console.error("Error in countryinfo command:", e);
        await react("âŒ");
        reply("An error occurred while fetching country information.");
    }
});

const converter = require('../data/converter');
const stickerConverter = require('../data/sticker-converter');
const { cmd } = require('../command');

cmd({
    pattern: 'convert',
    alias: ['sticker2img', 'stoimg', 'stickertoimage', 's2i'],
    desc: 'Convert stickers to images',
    category: 'media',
    react: 'ğŸ–¼ï¸',
    filename: __filename
}, async (client, match, message, { from }) => {
    // Input validation
    if (!message.quoted) {
        return await client.sendMessage(from, {
            text: "âœ¨ *Sticker Converter*\n\nPlease reply to a sticker message\n\nExample: `.convert` (reply to sticker)"
        }, { quoted: message });
    }

    if (message.quoted.mtype !== 'stickerMessage') {
        return await client.sendMessage(from, {
            text: "âŒ Only sticker messages can be converted"
        }, { quoted: message });
    }

    // Send processing message
    await client.sendMessage(from, {
        text: "ğŸ”„ Converting sticker to image..."
    }, { quoted: message });

    try {
        const stickerBuffer = await message.quoted.download();
        const imageBuffer = await stickerConverter.convertStickerToImage(stickerBuffer);

        // Send result
        await client.sendMessage(from, {
            image: imageBuffer,
            caption: "> Powered By  sir bravin",
            mimetype: 'image/png'
        }, { quoted: message });

    } catch (error) {
        console.error('Conversion error:', error);
        await client.sendMessage(from, {
            text: "âŒ Please try with a different sticker."
        }, { quoted: message });
    }
});

cmd({
    pattern: 'tomp3',
    desc: 'Convert media to audio',
    category: 'audio',
    react: 'ğŸµ',
    filename: __filename
}, async (client, match, message, { from }) => {
    // Input validation
    if (!match.quoted) {
        return await client.sendMessage(from, {
            text: "*ğŸ”Š Please reply to a video/audio message*"
        }, { quoted: message });
    }

    if (!['videoMessage', 'audioMessage'].includes(match.quoted.mtype)) {
        return await client.sendMessage(from, {
            text: "âŒ Only video/audio messages can be converted"
        }, { quoted: message });
    }

    if (match.quoted.seconds > 300) {
        return await client.sendMessage(from, {
            text: "â±ï¸ Media too long (max 5 minutes)"
        }, { quoted: message });
    }

    // Send processing message and store it
    await client.sendMessage(from, {
        text: "ğŸ”„ Converting to audio..."
    }, { quoted: message });

    try {
        const buffer = await match.quoted.download();
        const ext = match.quoted.mtype === 'videoMessage' ? 'mp4' : 'm4a';
        const audio = await converter.toAudio(buffer, ext);

        // Send result
        await client.sendMessage(from, {
            audio: audio,
            mimetype: 'audio/mpeg'
        }, { quoted: message });

    } catch (e) {
        console.error('Conversion error:', e.message);
        await client.sendMessage(from, {
            text: "âŒ Failed to process audio"
        }, { quoted: message });
    }
});

cmd({
    pattern: 'toptt',
    desc: 'Convert media to voice message',
    category: 'audio',
    react: 'ğŸ™ï¸',
    filename: __filename
}, async (client, match, message, { from }) => {
    // Input validation
    if (!match.quoted) {
        return await client.sendMessage(from, {
            text: "*ğŸ—£ï¸ Please reply to a video/audio message*"
        }, { quoted: message });
    }

    if (!['videoMessage', 'audioMessage'].includes(match.quoted.mtype)) {
        return await client.sendMessage(from, {
            text: "âŒ Only video/audio messages can be converted"
        }, { quoted: message });
    }

    if (match.quoted.seconds > 60) {
        return await client.sendMessage(from, {
            text: "â±ï¸ Media too long for voice (max 1 minute)"
        }, { quoted: message });
    }

    // Send processing message
    await client.sendMessage(from, {
        text: "ğŸ”„ Converting to voice message..."
    }, { quoted: message });

    try {
        const buffer = await match.quoted.download();
        const ext = match.quoted.mtype === 'videoMessage' ? 'mp4' : 'm4a';
        const ptt = await converter.toPTT(buffer, ext);

        // Send result
        await client.sendMessage(from, {
            audio: ptt,
            mimetype: 'audio/ogg; codecs=opus',
            ptt: true
        }, { quoted: message });

    } catch (e) {
        console.error('PTT conversion error:', e.message);
        await client.sendMessage(from, {
            text: "âŒ Failed to create voice message"
        }, { quoted: message });
    }
});


const { cmd, commands } = require('../command');
const { fetchJson } = require('../lib/functions');

cmd({
    pattern: "fetch",
    alias: ["get", "api"],
    desc: "Fetch data from a provided URL or API",
    category: "main",
    react: "ğŸ›",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, args, reply }) => {
    try {
        const q = args.join(' ').trim(); // Extract the URL or API query
        if (!q) return reply('âŒ Please provide a valid URL or query.');

        if (!/^https?:\/\//.test(q)) return reply('âŒ URL must start with http:// or https://.');

        const data = await fetchJson(q); // Use your fetchJson utility function to get data
        const content = JSON.stringify(data, null, 2);

        await conn.sendMessage(from, {
            text: `ğŸ” *Fetched Data*:\n\`\`\`${content.slice(0, 2048)}\`\`\``,
            contextInfo: {
                mentionedJid: [m.sender],
                forwardingScore: 999,
                isForwarded: true,
                forwardingSourceMessage: 'Your Data Request',
            }
        }, { quoted: mek });
    } catch (e) {
        console.error("Error in fetch command:", e);
        reply(`âŒ An error occurred:\n${e.message}`);
    }
});

// Jawad TechX - KHAN MD 
// Dont Remove Credit From File 

const { cmd } = require("../command");

// Safety Configuration
const SAFETY = {
  MAX_JIDS: 20,
  BASE_DELAY: 2000,  // jawad on top ğŸ”
  EXTRA_DELAY: 4000,  // huh don't copy mine file 
};

cmd({
  pattern: "forward",
  alias: ["fwd"],
  desc: "Bulk forward media to groups",
  category: "owner",
  filename: __filename
}, async (client, message, match, { isOwner }) => {
  try {
    // Owner check
    if (!isOwner) return await message.reply("*ğŸ“› Owner Only Command/sir bravin*");
    
    // Quoted message check
    if (!message.quoted) return await message.reply("*ğŸ Please reply to a message*");

    // ===== [BULLETPROOF JID PROCESSING] ===== //
    let jidInput = "";
    
    // Handle all possible match formats
    if (typeof match === "string") {
      jidInput = match.trim();
    } else if (Array.isArray(match)) {
      jidInput = match.join(" ").trim();
    } else if (match && typeof match === "object") {
      jidInput = match.text || "";
    }
    
    // Extract JIDs (supports comma or space separated)
    const rawJids = jidInput.split(/[\s,]+/).filter(jid => jid.trim().length > 0);
    
    // Process JIDs (accepts with or without @g.us)
    const validJids = rawJids
      .map(jid => {
        // Remove existing @g.us if present
        const cleanJid = jid.replace(/@g\.us$/i, "");
        // Only keep if it's all numbers
        return /^\d+$/.test(cleanJid) ? `${cleanJid}@g.us` : null;
      })
      .filter(jid => jid !== null)
      .slice(0, SAFETY.MAX_JIDS);

    if (validJids.length === 0) {
      return await message.reply(
        "âŒ No valid group JIDs found\n" +
        "Examples:\n" +
        ".fwd 120363411055156472@g.us,120363333939099948@g.us\n" +
        ".fwd 120363411055156472 120363333939099948"
      );
    }

    // ===== [ENHANCED MEDIA HANDLING - ALL TYPES] ===== //
    let messageContent = {};
    const mtype = message.quoted.mtype;
    
    // For media messages (image, video, audio, sticker, document)
    if (["imageMessage", "videoMessage", "audioMessage", "stickerMessage", "documentMessage"].includes(mtype)) {
      const buffer = await message.quoted.download();
      
      switch (mtype) {
        case "imageMessage":
          messageContent = {
            image: buffer,
            caption: message.quoted.text || '',
            mimetype: message.quoted.mimetype || "image/jpeg"
          };
          break;
        case "videoMessage":
          messageContent = {
            video: buffer,
            caption: message.quoted.text || '',
            mimetype: message.quoted.mimetype || "video/mp4"
          };
          break;
        case "audioMessage":
          messageContent = {
            audio: buffer,
            mimetype: message.quoted.mimetype || "audio/mp4",
            ptt: message.quoted.ptt || false
          };
          break;
        case "stickerMessage":
          messageContent = {
            sticker: buffer,
            mimetype: message.quoted.mimetype || "image/webp"
          };
          break;
        case "documentMessage":
          messageContent = {
            document: buffer,
            mimetype: message.quoted.mimetype || "application/octet-stream",
            fileName: message.quoted.fileName || "document"
          };
          break;
      }
    } 
    // For text messages
    else if (mtype === "extendedTextMessage" || mtype === "conversation") {
      messageContent = {
        text: message.quoted.text
      };
    } 
    // For other message types (forwarding as-is)
    else {
      try {
        // Try to forward the message directly
        messageContent = message.quoted;
      } catch (e) {
        return await message.reply("âŒ Unsupported message type");
      }
    }

    // ===== [OPTIMIZED SENDING WITH PROGRESS] ===== //
    let successCount = 0;
    const failedJids = [];
    
    for (const [index, jid] of validJids.entries()) {
      try {
        await client.sendMessage(jid, messageContent);
        successCount++;
        
        // Progress update (every 10 groups instead of 5)
        if ((index + 1) % 10 === 0) {
          await message.reply(`ğŸ”„ Sent to ${index + 1}/${validJids.length} groups...`);
        }
        
        // Apply reduced delay
        const delayTime = (index + 1) % 10 === 0 ? SAFETY.EXTRA_DELAY : SAFETY.BASE_DELAY;
        await new Promise(resolve => setTimeout(resolve, delayTime));
        
      } catch (error) {
        failedJids.push(jid.replace('@g.us', ''));
        await new Promise(resolve => setTimeout(resolve, SAFETY.BASE_DELAY));
      }
    }

    // ===== [COMPREHENSIVE REPORT] ===== //
    let report = `âœ… *Forward Complete*\n\n` +
                 `ğŸ“¤ Success: ${successCount}/${validJids.length}\n` +
                 `ğŸ“¦ Content Type: ${mtype.replace('Message', '') || 'text'}\n`;
    
    if (failedJids.length > 0) {
      report += `\nâŒ Failed (${failedJids.length}): ${failedJids.slice(0, 5).join(', ')}`;
      if (failedJids.length > 5) report += ` +${failedJids.length - 5} more`;
    }
    
    if (rawJids.length > SAFETY.MAX_JIDS) {
      report += `\nâš ï¸ Note: Limited to first ${SAFETY.MAX_JIDS} JIDs`;
    }

    await message.reply(report);

  } catch (error) {
    console.error("Forward Error:", error);
    await message.reply(
      `ğŸ’¢ Error: ${error.message.substring(0, 100)}\n\n` +
      `Please try again or check:\n` +
      `1. JID formatting\n` +
      `2. Media type support\n` +
      `3. Bot permissions`
    );
  }
});

const { sleep } = require('../lib/functions');
const {cmd , commands} = require('../command')

cmd({
    pattern: "rcolor",
    desc: "Generate a random color with name and code.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        const colorNames = [
            "Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink", "Brown", "Black", "White", 
            "Gray", "Cyan", "Magenta", "Violet", "Indigo", "Teal", "Lavender", "Turquoise"
        ];
        
        const randomColorHex = "#" + Math.floor(Math.random()*16777215).toString(16);
        const randomColorName = colorNames[Math.floor(Math.random() * colorNames.length)];

        reply(`ğŸ¨ *Random Color:* \nName: ${randomColorName}\nCode: ${randomColorHex}`);
    } catch (e) {
        console.error("Error in .randomcolor command:", e);
        reply("âŒ An error occurred while generating the random color.");
    }
});

cmd({
    pattern: "binary",
    desc: "Convert text into binary format.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("âŒ Please provide the text to convert to binary.");

        const textToConvert = args.join(" ");
        const binaryText = textToConvert.split('').map(char => {
            return `00000000${char.charCodeAt(0).toString(2)}`.slice(-8);
        }).join(' ');

        reply(`ğŸ”‘ *Binary Representation:* \n${binaryText}`);
    } catch (e) {
        console.error("Error in .binary command:", e);
        reply("âŒ An error occurred while converting to binary.");
    }
});

cmd({
    pattern: "dbinary",
    desc: "Decode binary string into text.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("âŒ Please provide the binary string to decode.");

        const binaryString = args.join(" ");
        const textDecoded = binaryString.split(' ').map(bin => {
            return String.fromCharCode(parseInt(bin, 2));
        }).join('');

        reply(`ğŸ¦  *Decoded Text:* \n${textDecoded}`);
    } catch (e) {
        console.error("Error in .binarydecode command:", e);
        reply("âŒ An error occurred while decoding the binary string.");
    }
});


cmd({
    pattern: "base64",
    desc: "Encode text into Base64 format.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure the user provided some text
        if (!args.length) return reply("âŒ Please provide the text to encode into Base64.");

        const textToEncode = args.join(" ");
        
        // Encode the text into Base64
        const encodedText = Buffer.from(textToEncode).toString('base64');
        
        // Send the encoded Base64 text
        reply(`ğŸ”‘ *Encoded Base64 Text:* \n${encodedText}`);
    } catch (e) {
        console.error("Error in .base64 command:", e);
        reply("âŒ An error occurred while encoding the text into Base64.");
    }
});

cmd({
    pattern: "unbase64",
    desc: "Decode Base64 encoded text.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure the user provided Base64 text
        if (!args.length) return reply("âŒ Please provide the Base64 encoded text to decode.");

        const base64Text = args.join(" ");
        
        // Decode the Base64 text
        const decodedText = Buffer.from(base64Text, 'base64').toString('utf-8');
        
        // Send the decoded text
        reply(`ğŸ”“ *Decoded Text:* \n${decodedText}`);
    } catch (e) {
        console.error("Error in .unbase64 command:", e);
        reply("âŒ An error occurred while decoding the Base64 text.");
    }
});

cmd({
    pattern: "urlencode",
    desc: "Encode text into URL encoding.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("âŒ Please provide the text to encode into URL encoding.");

        const textToEncode = args.join(" ");
        const encodedText = encodeURIComponent(textToEncode);

        reply(`ğŸ”‘ *Encoded URL Text:* \n${encodedText}`);
    } catch (e) {
        console.error("Error in .urlencode command:", e);
        reply("âŒ An error occurred while encoding the text.");
    }
});

cmd({
    pattern: "urldecode",
    desc: "Decode URL encoded text.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("âŒ Please provide the URL encoded text to decode.");

        const encodedText = args.join(" ");
        const decodedText = decodeURIComponent(encodedText);

        reply(`ğŸ”“ *Decoded Text:* \n${decodedText}`);
    } catch (e) {
        console.error("Error in .urldecode command:", e);
        reply("âŒ An error occurred while decoding the URL encoded text.");
    }
});

cmd({
    pattern: "roll",
    desc: "Roll a dice (1-6).",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Roll a dice (generate a random number between 1 and 6)
        const result = Math.floor(Math.random() * 6) + 1;
        
        // Send the result
        reply(`ğŸ² You rolled: *${result}*`);
    } catch (e) {
        console.error("Error in .roll command:", e);
        reply("âŒ An error occurred while rolling the dice.");
    }
}); 


cmd({
    pattern: "coinflip",
    desc: "Flip a coin and get Heads or Tails.",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Simulate coin flip (randomly choose Heads or Tails)
        const result = Math.random() < 0.5 ? "Heads" : "Tails";
        
        // Send the result
        reply(`ğŸª™ Coin Flip Result: *${result}*`);
    } catch (e) {
        console.error("Error in .coinflip command:", e);
        reply("âŒ An error occurred while flipping the coin.");
    }
});

cmd({
    pattern: "flip",
    desc: "Flip the text you provide.",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure text is provided
        if (!args.length) return reply("âŒ Please provide the text to flip.");

        // Flip the text
        const flippedText = args.join(" ").split('').reverse().join('');
        
        // Send the flipped text
        reply(`ğŸ”„ Flipped Text: *${flippedText}*`);
    } catch (e) {
        console.error("Error in .flip command:", e);
        reply("âŒ An error occurred while flipping the text.");
    }
});

cmd({
    pattern: "pick",
    desc: "Pick between two choices.",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure two options are provided
        if (args.length < 2) return reply("âŒ Please provide two choices to pick from. Example: `.pick Ice Cream, Pizza`");

        // Pick a random option
        const option = args.join(" ").split(',')[Math.floor(Math.random() * 2)].trim();
        
        // Send the result
        reply(`ğŸ‰ Bot picks: *${option}*`);
    } catch (e) {
        console.error("Error in .pick command:", e);
        reply("âŒ An error occurred while processing your request.");
    }
});

cmd({
    pattern: "timenow",
    desc: "Check the current local time.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Get current date and time
        const now = new Date();
        
        // Get local time in Pakistan timezone (Asia/Karachi)
        const localTime = now.toLocaleTimeString("en-US", { 
            hour: "2-digit", 
            minute: "2-digit", 
            second: "2-digit", 
            hour12: true,
            timeZone: "Asia/Karachi" // Setting Pakistan's time zone explicitly
        });
        
        // Send the local time as reply
        reply(`ğŸ•’ Current Local Time in Pakistan: ${localTime}`);
    } catch (e) {
        console.error("Error in .timenow command:", e);
        reply("âŒ An error occurred. Please try again later.");
    }
});

cmd({
    pattern: "date",
    desc: "Check the current date.",
    category: "utility",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Get current date
        const now = new Date();
        
        // Get the formatted date (e.g., "Monday, January 15, 2025")
        const currentDate = now.toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric"
        });
        
        // Send the current date as reply
        reply(`ğŸ“… Current Date: ${currentDate}`);
    } catch (e) {
        console.error("Error in .date command:", e);
        reply("âŒ An error occurred. Please try again later.");
    }
});

cmd({
    pattern: "shapar",
    desc: "Send shapar ASCII art with mentions.",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, reply }) => {
    try {
        // Ensure the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Extract the mentioned user
        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) {
            return reply("Please mention a user to send the ASCII art to.");
        }

        // Shapar ASCII Art
        const asciiArt = `
          _______
       .-'       '-.
      /           /|
     /           / |
    /___________/  |
    |   _______ |  |
    |  |  \\ \\  ||  |
    |  |   \\ \\ ||  |
    |  |____\\ \\||  |
    |  '._  _.'||  |
    |    .' '.  ||  |
    |   '.___.' ||  |
    |___________||  |
    '------------'  |
     \\_____________\\|
`;

        // Message to send
        const message = `ğŸ˜‚ @${mentionedUser.split("@")[0]}!\nğŸ˜‚ that for you:\n\n${asciiArt}`;

        // Send the message with mentions
        await conn.sendMessage(from, {
            text: message,
            mentions: [mentionedUser],
        }, { quoted: m });

    } catch (e) {
        console.error("Error in .shapar command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});

cmd({
    pattern: "rate",
    desc: "Rate someone out of 10.",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, reply }) => {
    try {
        if (!isGroup) return reply("This command can only be used in groups.");

        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) return reply("Please mention someone to rate.");

        const randomRating = Math.floor(Math.random() * 10) + 1;
        const message = `@${mentionedUser.split("@")[0]} is rated ${randomRating}/10.`;

        await conn.sendMessage(from, { text: message, mentions: [mentionedUser] }, { quoted: m });
    } catch (e) {
        console.error("Error in .rate command:", e);
        reply("An error occurred. Please try again.");
    }
});

cmd({
    pattern: "countx",
    desc: "Start a reverse countdown from the specified number to 1.",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, { args, reply, senderNumber }) => {
    try {
        // Get the bot owner's number dynamically from conn.user.id
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("â Only the bot owner can use this command.");
        }

        // Ensure arguments are provided
        if (!args[0]) {
            return reply("âœ³ï¸ Use this command like:\n *Example:* .countx 10");
        }

        const count = parseInt(args[0].trim());

        // Validate the input
        if (isNaN(count) || count <= 0 || count > 50) {
            return reply("â Please specify a valid number between 1 and 50.");
        }

        reply(`â³ Starting reverse countdown from ${count}...`);

        for (let i = count; i >= 1; i--) {
            await conn.sendMessage(m.chat, { text: `${i}` }, { quoted: mek });
            await sleep(1000); // 1-second delay between messages
        }

        reply(`âœ… Countdown completed.`);
    } catch (e) {
        console.error(e);
        reply("â An error occurred while processing your request.");
    }
});

cmd({
    pattern: "count",
    desc: "Start a countdown from 1 to the specified number.",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, { args, reply, senderNumber }) => {
    try {
        // Get the bot owner's number dynamically from conn.user.id
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("â Only the bot owner can use this command.");
        }

        // Ensure arguments are provided
        if (!args[0]) {
            return reply("âœ³ï¸ Use this command like:\n *Example:* .count 10");
        }

        const count = parseInt(args[0].trim());

        // Validate the input
        if (isNaN(count) || count <= 0 || count > 50) {
            return reply("â Please specify a valid number between 1 and 50.");
        }

        reply(`â³ Starting countdown to ${count}...`);

        for (let i = 1; i <= count; i++) {
            await conn.sendMessage(m.chat, { text: `${i}` }, { quoted: mek });
            await sleep(1000); // 1-second delay between messages
        }

        reply(`âœ… Countdown completed.`);
    } catch (e) {
        console.error(e);
        reply("â An error occurred while processing your request.");
    }
});


cmd({
    pattern: "calculate",
    alias: ["calc"],
    desc: "Evaluate a mathematical expression.",
    category: "utilities",
    filename: __filename
},
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure arguments are provided
        if (!args[0]) {
            return reply("âœ³ï¸ Use this command like:\n *Example:* .calculate 5+3*2");
        }

        const expression = args.join(" ").trim();

        // Validate the input to prevent unsafe operations
        if (!/^[0-9+\-*/().\s]+$/.test(expression)) {
            return reply("â Invalid expression. Only numbers and +, -, *, /, ( ) are allowed.");
        }

        // Evaluate the mathematical expression
        let result;
        try {
            result = eval(expression);
        } catch (e) {
            return reply("â Error in calculation. Please check your expression.");
        }

        // Reply with the result
        reply(`âœ… Result of "${expression}" is: ${result}`);
    } catch (e) {
        console.error(e);
        reply("â An error occurred while processing your request.");
    }
});

const { cmd } = require("../command");
const axios = require("axios");

cmd({
    pattern: "tempnum",
    alias: ["fakenum", "tempnumber"],
    desc: "Get temporary numbers & OTP instructions",
    category: "tools",
    react: "ğŸ“±",
    use: "<country-code>"
},
async (conn, mek, m, { from, args, reply }) => {
    try {
        // Mandatory country code check
        if (!args || args.length < 1) {
            return reply(`âŒ *Usage:* .tempnum <country-code>\nExample: .tempnum us\n\nğŸ“¦ Use .otpbox <number>* to check OTPs`);
        }

        const countryCode = args[0].toLowerCase();
        
        // API call with validation
        const { data } = await axios.get(
            `https://api.vreden.my.id/api/tools/fakenumber/listnumber?id=${countryCode}`,
            { 
                timeout: 10000,
                validateStatus: status => status === 200
            }
        );

        // Fixed syntax error here - added missing parenthesis
        if (!data?.result || !Array.isArray(data.result)) {
            console.error("Invalid API structure:", data);
            return reply(`âš  Invalid API response format\nTry .tempnum us`);
        }

        if (data.result.length === 0) {
            return reply(`ğŸ“­ No numbers available for *${countryCode.toUpperCase()}*\nTry another country code!\n\nUse .otpbox <number> after selection`);
        }

        // Process numbers
        const numbers = data.result.slice(0, 25);
        const numberList = numbers.map((num, i) => 
            `${String(i+1).padStart(2, ' ')}. ${num.number}`
        ).join("\n");

        // Final message with OTP instructions
        await reply(
            `â•­â”€â”€ã€Œ ğŸ“± TEMPORARY NUMBERS ã€\n` +
            `â”‚\n` +
            `â”‚ Country: ${countryCode.toUpperCase()}\n` +
            `â”‚ Numbers Found: ${numbers.length}\n` +
            `â”‚\n` +
            `${numberList}\n\n` +
            `â•°â”€â”€ã€Œ ğŸ“¦ USE: .otpbox <number> ã€\n` +
            `_Example: .otpbox +1234567890_`
        );

    } catch (err) {
        console.error("API Error:", err);
        const errorMessage = err.code === "ECONNABORTED" ? 
            `â³ *Timeout*: API took too long\nTry smaller country codes like 'us', 'gb'` :
            `âš  *Error*: ${err.message}\nUse format: .tempnum <country-code>`;
            
        reply(`${errorMessage}\n\nğŸ”‘ Remember: ${prefix}otpinbox <number>`);
    }
});

cmd({
    pattern: "templist",
    alias: ["tempnumberlist", "tempnlist", "listnumbers"],
    desc: "Show list of countries with temp numbers",
    category: "tools",
    react: "ğŸŒ",
    filename: __filename,
    use: ".templist"
},
async (conn, m, { reply }) => {
    try {
        const { data } = await axios.get("https://api.vreden.my.id/api/tools/fakenumber/country");

        if (!data || !data.result) return reply("âŒ Couldn't fetch country list.");

        const countries = data.result.map((c, i) => `*${i + 1}.* ${c.title} \`(${c.id})\``).join("\n");

        await reply(`ğŸŒ *Total Available Countries:* ${data.result.length}\n\n${countries}`);
    } catch (e) {
        console.error("TEMP LIST ERROR:", e);
        reply("âŒ Failed to fetch temporary number country list.");
    }
});

cmd({
    pattern: "otpbox",
    alias: ["checkotp", "getotp"],
    desc: "Check OTP messages for temporary number",
    category: "tools",
    react: "ğŸ§©",
    use: "<full-number>"
},
async (conn, mek, m, { from, args, reply }) => {
    try {
        // Validate input
        if (!args[0] || !args[0].startsWith("+")) {
            return reply(`âŒ *Usage:* .otpbox <full-number>\nExample: .otpbox +9231034481xx`);
        }

        const phoneNumber = args[0].trim();
        
        // Fetch OTP messages
        const { data } = await axios.get(
            `https://api.vreden.my.id/api/tools/fakenumber/message?nomor=${encodeURIComponent(phoneNumber)}`,
            { 
                timeout: 10000,
                validateStatus: status => status === 200
            }
        );

        // Validate response
        if (!data?.result || !Array.isArray(data.result)) {
            return reply("âš  No OTP messages found for this number");
        }

        // Format OTP messages
        const otpMessages = data.result.map(msg => {
            // Extract OTP code (matches common OTP patterns)
            const otpMatch = msg.content.match(/\b\d{4,8}\b/g);
            const otpCode = otpMatch ? otpMatch[0] : "Not found";
            
            return `â”Œ *From:* ${msg.from || "Unknown"}
â”‚ *Code:* ${otpCode}
â”‚ *Time:* ${msg.time_wib || msg.timestamp}
â”” *Message:* ${msg.content.substring(0, 50)}${msg.content.length > 50 ? "..." : ""}`;
        }).join("\n\n");

        await reply(
            `â•­â”€â”€ã€Œ ğŸ”‘ OTP MESSAGES ã€\n` +
            `â”‚ Number: ${phoneNumber}\n` +
            `â”‚ Messages Found: ${data.result.length}\n` +
            `â”‚\n` +
            `${otpMessages}\n` +
            `â•°â”€â”€ã€Œ ğŸ“Œ Use .tempnum to get numbers ã€`
        );

    } catch (err) {
        console.error("OTP Check Error:", err);
        const errorMsg = err.code === "ECONNABORTED" ?
            "âŒ› OTP check timed out. Try again later" :
            `âš  Error: ${err.response?.data?.error || err.message}`;
        
        reply(`${errorMsg}\n\nUsage: .otpbox +9231034481xx`);
    }
});

const { cmd } = require('../command');
const PDFDocument = require('pdfkit');
const { Buffer } = require('buffer');

cmd({
    pattern: "topdf",
    alias: ["pdf","topdf"],use: '.topdf',
    desc: "Convert provided text to a PDF file.",
    react: "ğŸ“„",
    category: "utilities",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q) return reply("Please provide the text you want to convert to PDF. *Eg* `.topdf` *Pakistan ZindaBad ğŸ‡µğŸ‡°*");

        // Create a new PDF document
        const doc = new PDFDocument();
        let buffers = [];
        doc.on('data', buffers.push.bind(buffers));
        doc.on('end', async () => {
            const pdfData = Buffer.concat(buffers);

            // Send the PDF file
            await conn.sendMessage(from, {
                document: pdfData,
                mimetype: 'application/pdf',
                fileName: 'sir bravin.pdf',
                caption: `
*ğŸ“„ PDF created successully!*

> Â© Created By sir bravin ğŸ–¥ï¸`
            }, { quoted: mek });
        });

        // Add text to the PDF
        doc.text(q);

        // Finalize the PDF and end the stream
        doc.end();

    } catch (e) {
        console.error(e);
        reply(`Error: ${e.message}`);
    }
});
                      

const { cmd } = require('../command');
const { getBuffer, fetchJson } = require('../lib/functions');

cmd({
    pattern: "person",
    react: "ğŸ™…",
    alias: ["userinfo", "profile"],
    desc: "Get complete user profile information",
    category: "utility",
    use: '.person [@tag or reply]',
    filename: __filename
},
async (conn, mek, m, { from, sender, isGroup, reply, quoted, participants }) => {
    try {
        // 1. DETERMINE TARGET USER
        let userJid = quoted?.sender || 
                     mek.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0] || 
                     sender;

        // 2. VERIFY USER EXISTS
        const [user] = await conn.onWhatsApp(userJid).catch(() => []);
        if (!user?.exists) return reply("âŒ User not found on WhatsApp");

        // 3. GET PROFILE PICTURE
        let ppUrl;
        try {
            ppUrl = await conn.profilePictureUrl(userJid, 'image');
        } catch {
            ppUrl = 'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png';
        }

        // 4. GET NAME (MULTI-SOURCE FALLBACK)
        let userName = userJid.split('@')[0];
        try {
            // Try group participant info first
            if (isGroup) {
                const member = participants.find(p => p.id === userJid);
                if (member?.notify) userName = member.notify;
            }
            
            // Try contact DB
            if (userName === userJid.split('@')[0] && conn.contactDB) {
                const contact = await conn.contactDB.get(userJid).catch(() => null);
                if (contact?.name) userName = contact.name;
            }
            
            // Try presence as final fallback
            if (userName === userJid.split('@')[0]) {
                const presence = await conn.presenceSubscribe(userJid).catch(() => null);
                if (presence?.pushname) userName = presence.pushname;
            }
        } catch (e) {
            console.log("Name fetch error:", e);
        }

        // 5. GET BIO/ABOUT
        let bio = {};
        try {
            // Try personal status
            const statusData = await conn.fetchStatus(userJid).catch(() => null);
            if (statusData?.status) {
                bio = {
                    text: statusData.status,
                    type: "Personal",
                    updated: statusData.setAt ? new Date(statusData.setAt * 1000) : null
                };
            } else {
                // Try business profile
                const businessProfile = await conn.getBusinessProfile(userJid).catch(() => null);
                if (businessProfile?.description) {
                    bio = {
                        text: businessProfile.description,
                        type: "Business",
                        updated: null
                    };
                }
            }
        } catch (e) {
            console.log("Bio fetch error:", e);
        }

        // 6. GET GROUP ROLE
        let groupRole = "";
        if (isGroup) {
            const participant = participants.find(p => p.id === userJid);
            groupRole = participant?.admin ? "ğŸ‘‘ Admin" : "ğŸ‘¥ Member";
        }

        // 7. FORMAT OUTPUT
        const formattedBio = bio.text ? 
            `${bio.text}\nâ””â”€ ğŸ“Œ ${bio.type} Bio${bio.updated ? ` | ğŸ•’ ${bio.updated.toLocaleString()}` : ''}` : 
            "No bio available";

        const userInfo = `
*GC MEMBER INFORMATION ğŸ§Š*

ğŸ“› *Name:* ${userName}
ğŸ”¢ *Number:* ${userJid.replace(/@.+/, '')}
ğŸ“Œ *Account Type:* ${user.isBusiness ? "ğŸ’¼ Business" : user.isEnterprise ? "ğŸ¢ Enterprise" : "ğŸ‘¤ Personal"}

*ğŸ“ About:*
${formattedBio}

*âš™ï¸ Account Info:*
âœ… Registered: ${user.isUser ? "Yes" : "No"}
ğŸ›¡ï¸ Verified: ${user.verifiedName ? "âœ… Verified" : "âŒ Not verified"}
${isGroup ? `ğŸ‘¥ *Group Role:* ${groupRole}` : ''}
`.trim();

        // 8. SEND RESULT
        await conn.sendMessage(from, {
            image: { url: ppUrl },
            caption: userInfo,
            mentions: [userJid]
        }, { quoted: mek });

    } catch (e) {
        console.error("Person command error:", e);
        reply(`âŒ Error: ${e.message || "Failed to fetch profile"}`);
    }
});


const { cmd } = require("../command");
const config = require("../config");

cmd({
    pattern: "report",
    alias: ["ask", "bug", "request"],
    desc: "Report a bug or request a feature",
    category: "utility",
    filename: __filename
}, async (conn, mek, m, {
    from, body, command, args, senderNumber, reply
}) => {
    try {
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }
        
        if (!args.length) {
            return reply(`Example: ${config.PREFIX}report Play command is not working`);
        }

        const reportedMessages = {};
        const devNumber = "+254717263689"; // Bot owner's number
        const messageId = m.key.id;

        if (reportedMessages[messageId]) {
            return reply("This report has already been forwarded to the owner. Please wait for a response.");
        }
        reportedMessages[messageId] = true;

        const reportText = `*| REQUEST/BUG |*\n\n*User*: @${m.sender.split("@")[0]}\n*Request/Bug*: ${args.join(" ")}`;
        const confirmationText = `Hi ${m.pushName}, your request has been forwarded to the owner. Please wait...`;

        await conn.sendMessage(`${devNumber}@s.whatsapp.net`, {
            text: reportText,
            mentions: [m.sender]
        }, { quoted: m });

        reply(confirmationText);
    } catch (error) {
        console.error(error);
        reply("An error occurred while processing your report.");
    }
});

const axios = require("axios");
const fetch = require("node-fetch");
const { sleep } = require('../lib/functions');
const { cmd, commands } = require("../command");

cmd({
  pattern: "joke",
  desc: "ğŸ¤£ Get a random joke",
  react: "ğŸ¤£",
  category: "fun",
  filename: __filename
}, async (conn, m, store, { reply }) => {
  try {
    const response = await axios.get("https://official-joke-api.appspot.com/random_joke");
    const joke = response.data;

    if (!joke || !joke.setup || !joke.punchline) {
      return reply("âŒ Failed to fetch a joke. Please try again.");
    }

    const jokeMessage = `ğŸ¤£ *Here's a random joke for you!* ğŸ¤£\n\n*${joke.setup}*\n\n${joke.punchline} ğŸ˜†\n\n> *Â© Powered by sir bravin*`;

    return reply(jokeMessage);
  } catch (error) {
    console.error("âŒ Error in joke command:", error);
    return reply("âš ï¸ An error occurred while fetching the joke. Please try again.");
  }
});

// flirt

cmd({
    pattern: "flirt",
    alias: ["masom", "line"],
    desc: "Get a random flirt or pickup line.",
    react: "ğŸ’˜",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // Define API key and URL
        const shizokeys = 'shizo';
        const apiUrl = `https://shizoapi.onrender.com/api/texts/flirt?apikey=${shizokeys}`;

        // Fetch data from the API
        const res = await fetch(apiUrl);
        if (!res.ok) {
            throw new Error(`API error: ${await res.text()}`);
        }
        
        const json = await res.json();
        if (!json.result) {
            throw new Error("Invalid response from API.");
        }

        // Extract and send the flirt message
        const flirtMessage = `${json.result}`;
        await conn.sendMessage(from, {
            text: flirtMessage,
            mentions: [m.sender],
        }, { quoted: m });

    } catch (error) {
        console.error("Error in flirt command:", error);
        reply("Sorry, something went wrong while fetching the flirt line. Please try again later.");
    }
});

//truth

cmd({
    pattern: "truth",
    alias: ["truthquestion"],
    desc: "Get a random truth question from the API.",
    react: "â“",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        const shizokeys = 'shizo';
        const res = await fetch(`https://shizoapi.onrender.com/api/texts/truth?apikey=${shizokeys}`);
        
        if (!res.ok) {
            console.error(`API request failed with status ${res.status}`);
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        if (!json.result) {
            console.error("Invalid API response: No 'result' field found.");
            throw new Error("Invalid API response: No 'result' field found.");
        }

        const truthText = `${json.result}`;
        await conn.sendMessage(from, { 
            text: truthText, 
            mentions: [m.sender] 
        }, { quoted: m });

    } catch (error) {
        console.error("Error in truth command:", error);
        reply("Sorry, something went wrong while fetching the truth question. Please try again later.");
    }
});

// dare

cmd({
    pattern: "dare",
    alias: ["truthordare"],
    desc: "Get a random dare from the API.",
    react: "ğŸ¯",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // API Key
        const shizokeys = 'shizo';

        // Fetch dare text from the API
        const res = await fetch(`https://shizoapi.onrender.com/api/texts/dare?apikey=${shizokeys}`);
        
        if (!res.ok) {
            console.error(`API request failed with status ${res.status}`);
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        if (!json.result) {
            console.error("Invalid API response: No 'result' field found.");
            throw new Error("Invalid API response: No 'result' field found.");
        }

        // Format the dare message
        const dareText = `${json.result}`;

        // Send the dare to the chat
        await conn.sendMessage(from, { 
            text: dareText, 
            mentions: [m.sender] 
        }, { quoted: m });

    } catch (error) {
        console.error("Error in dare command:", error);
        reply("Sorry, something went wrong while fetching the dare. Please try again later.");
    }
});

cmd({
  pattern: "fact",
  desc: "ğŸ§  Get a random fun fact",
  react: "ğŸ§ ",
  category: "fun",
  filename: __filename
}, async (conn, m, store, { reply }) => {
  try {
    const response = await axios.get("https://uselessfacts.jsph.pl/random.json?language=en");
    const fact = response.data.text;

    if (!fact) {
      return reply("âŒ Failed to fetch a fun fact. Please try again.");
    }

    const factMessage = `ğŸ§  *Random Fun Fact* ğŸ§ \n\n${fact}\n\nIsn't that interesting? ğŸ˜„\n\n> *Â© Powered by sir bravin*`;

    return reply(factMessage);
  } catch (error) {
    console.error("âŒ Error in fact command:", error);
    return reply("âš ï¸ An error occurred while fetching a fun fact. Please try again later.");
  }
});

cmd({
    pattern: "pickupline",
    alias: ["pickup"],
    desc: "Get a random pickup line from the API.",
    react: "ğŸ’¬",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // Fetch pickup line from the API
        const res = await fetch('https://api.popcat.xyz/pickuplines');
        
        if (!res.ok) {
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        // Log the API response (for debugging purposes)
        console.log('JSON response:', json);

        // Format the pickup line message
        const pickupLine = `*Here's a pickup line for you:*\n\n"${json.pickupline}"\n\n> *Â© Powered By sir bravin*`;

        // Send the pickup line to the chat
        await conn.sendMessage(from, { text: pickupLine }, { quoted: m });

    } catch (error) {
        console.error("Error in pickupline command:", error);
        reply("Sorry, something went wrong while fetching the pickup line. Please try again later.");
    }
});

// char

cmd({
    pattern: "character",
    alias: ["char"],
    desc: "Check the character of a mentioned user.",
    react: "ğŸ”¥",
    category: "fun",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, text, reply }) => {
    try {
        // Ensure the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Extract the mentioned user
        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) {
            return reply("Please mention a user whose character you want to check.");
        }

        // Define character traits
        const userChar = [
            "Sigma",
            "Generous",
            "Grumpy",
            "Overconfident",
            "Obedient",
            "Good",
            "Simp",
            "Kind",
            "Patient",
            "Pervert",
            "Cool",
            "Helpful",
            "Brilliant",
            "Sexy",
            "Hot",
            "Gorgeous",
            "Cute",
        ];

        // Randomly select a character trait
        const userCharacterSelection =
            userChar[Math.floor(Math.random() * userChar.length)];

        // Message to send
        const message = `Character of @${mentionedUser.split("@")[0]} is *${userCharacterSelection}* ğŸ”¥âš¡`;

        // Send the message with mentions
        await conn.sendMessage(from, {
            text: message,
            mentions: [mentionedUser],
        }, { quoted: m });

    } catch (e) {
        console.error("Error in character command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});

cmd({
  pattern: "repeat",
  alias: ["rp", "rpm"],
  desc: "Repeat a message a specified number of times.",
  category: "fun",
  filename: __filename
}, async (conn, m, store, { args, reply }) => {
  try {
    if (!args[0]) {
      return reply("âœ³ï¸ Use this command like:\n*Example:* .repeat 10,I love you");
    }

    const [countStr, ...messageParts] = args.join(" ").split(",");
    const count = parseInt(countStr.trim());
    const message = messageParts.join(",").trim();

    if (isNaN(count) || count <= 0 || count > 300) {
      return reply("â Please specify a valid number between 1 and 300.");
    }

    if (!message) {
      return reply("â Please provide a message to repeat.");
    }

    const repeatedMessage = Array(count).fill(message).join("\n");

    reply(`ğŸ”„ Repeated ${count} times:\n\n${repeatedMessage}`);
  } catch (error) {
    console.error("âŒ Error in repeat command:", error);
    reply("â An error occurred while processing your request.");
  }
});

cmd({
  pattern: "send",
  desc: "Send a message multiple times, one by one.",
  category: "fun",
  filename: __filename
}, async (conn, m, store, { args, reply, senderNumber }) => {
  try {
    const botOwner = conn.user.id.split(":")[0]; // Get bot owner's number

    if (senderNumber !== botOwner) {
      return reply("â Only the bot owner can use this command.");
    }

    if (!args[0]) {
      return reply("âœ³ï¸ Use this command like:\n *Example:* .send 10,I love you");
    }

    const [countStr, ...messageParts] = args.join(" ").split(",");
    const count = parseInt(countStr.trim());
    const message = messageParts.join(",").trim();

    if (isNaN(count) || count <= 0 || count > 100) {
      return reply("â Please specify a valid number between 1 and 100.");
    }

    if (!message) {
      return reply("â Please provide a message to send.");
    }

    reply(`â³ Sending "${message}" ${count} times. This may take a while...`);

    for (let i = 0; i < count; i++) {
      await conn.sendMessage(m.from, { text: message }, { quoted: m });
      await sleep(1000); // 1-second delay
    }

    reply(`âœ… Successfully sent the message ${count} times.`);
  } catch (error) {
    console.error("âŒ Error in ask command:", error);
    reply("â An error occurred while processing your request.");
  }
});

cmd({
  pattern: "readmore",
  alias: ["rm", "rmore", "readm"],
  desc: "Generate a Read More message.",
  category: "convert",
  use: ".readmore <text>",
  react: "ğŸ“",
  filename: __filename
}, async (conn, m, store, { args, reply }) => {
  try {
    const inputText = args.join(" ") || "No text provided.";
    const readMore = String.fromCharCode(8206).repeat(4000); // Creates a large hidden gap
    const message = `${inputText} ${readMore} Continue Reading...`;

    await conn.sendMessage(m.from, { text: message }, { quoted: m });
  } catch (error) {
    console.error("âŒ Error in readmore command:", error);
    reply("âŒ An error occurred: " + error.message);
  }
});

// coded by jawadtech x

const path = require("path");
const { fetchGif, fetchImage, gifToSticker } = require('../lib/sticker-utils');
const { tmpdir } = require("os");
const fetch = require("node-fetch");
const Crypto = require("crypto");
const ffmpegPath = require("@ffmpeg-installer/ffmpeg").path;
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson } = require("../lib/functions");
const ffmpeg = require("fluent-ffmpeg");
const fs = require("fs");
const { cmd } = require('../command');
const { videoToWebp } = require('../lib/video-utils');
const { Sticker, createSticker, StickerTypes } = require("wa-sticker-formatter");
const config = require("../config");

cmd(
  {
    pattern: 'vsticker',
    alias: ['gsticker', 'g2s', 'gs', 'v2s', 'vs',],
    desc: 'Convert GIF/Video to a sticker.',
    category: 'sticker',
    use: '<reply media or URL>',
    filename: __filename,
  },
  async (conn, mek, m, { quoted, args, reply }) => {
    try {
      if (!mek.quoted) return reply('*Reply to a video or GIF to convert it to a sticker!*');

      const mime = mek.quoted.mtype;
      if (!['videoMessage', 'imageMessage'].includes(mime)) {
        return reply('*Please reply to a valid video or GIF.*');
      }

      // Download the media file
      const media = await mek.quoted.download();

      // Convert the video to a WebP buffer
      const webpBuffer = await videoToWebp(media);

      // Generate sticker metadata
      const sticker = new Sticker(webpBuffer, {
        pack: config.STICKER_NAME || 'My Pack',
        author: '', // Leave blank or customize
        type: StickerTypes.FULL, // FULL for regular stickers
        categories: ['ğŸ¤©', 'ğŸ‰'], // Emoji categories
        id: '12345', // Optional ID
        quality: 75, // Set quality for optimization
        background: 'transparent', // Transparent background
      });

      // Convert sticker to buffer and send
      const stickerBuffer = await sticker.toBuffer();
      return conn.sendMessage(mek.chat, { sticker: stickerBuffer }, { quoted: mek });
    } catch (error) {
      console.error(error);
      reply(`âŒ An error occurred: ${error.message}`);
    }
  }
);    


cmd({
    pattern: "attp",
    desc: "Convert text to a GIF sticker.",
    react: "ğŸ’…",
    category: "convert",
    use: ".attp HI",
    filename: __filename,
}, async (conn, mek, m, { args, reply }) => {
    try {
        if (!args[0]) return reply("*Please provide text!*");

        const gifBuffer = await fetchGif(`https://api-fix.onrender.com/api/maker/attp?text=${encodeURIComponent(args[0])}`);
        const stickerBuffer = await gifToSticker(gifBuffer);

        await conn.sendMessage(m.chat, { sticker: stickerBuffer }, { quoted: mek });
    } catch (error) {
        reply(`âŒ ${error.message}`);
    }
});


const axios = require('axios');
const { cmd } = require('../command');

cmd({
    pattern: "tempmail",
    alias: ["genmail"],
    desc: "Generate a new temporary email address",
    category: "utility",
    react: "ğŸ“§",
    filename: __filename
},
async (conn, mek, m, { from, reply, prefix }) => {
    try {
        const response = await axios.get('https://apis.davidcyriltech.my.id/temp-mail');
        const { email, session_id, expires_at } = response.data;

        // Format the expiration time and date
        const expiresDate = new Date(expires_at);
        const timeString = expiresDate.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
        const dateString = expiresDate.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            year: 'numeric'
        });

        // Create the complete message
        const message = `
ğŸ“§ *TEMPORARY EMAIL GENERATED*

âœ‰ï¸ *Email Address:*
${email}

â³ *Expires:*
${timeString} â€¢ ${dateString}

ğŸ”‘ *Session ID:*
\`\`\`${session_id}\`\`\`

ğŸ“¥ *Check Inbox:*
.inbox ${session_id}

_Email will expire after 24 hours_
`;

        await conn.sendMessage(
            from,
            { 
                text: message,
                contextInfo: {
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363366284524544@newsletter',
                        newsletterName: 'TempMail Service',
                        serverMessageId: 101
                    }
                }
            },
            { quoted: mek }
        );

    } catch (e) {
        console.error('TempMail error:', e);
        reply(`âŒ Error: ${e.message}`);
    }
});
cmd({
    pattern: "checkmail",
    alias: ["inbox", "tmail", "mailinbox"],
    desc: "Check your temporary email inbox",
    category: "utility",
    react: "ğŸ“¬",
    filename: __filename
},
async (conn, mek, m, { from, reply, args }) => {
    try {
        const sessionId = args[0];
        if (!sessionId) return reply('ğŸ”‘ Please provide your session ID\nExample: .checkmail YOUR_SESSION_ID');

        const inboxUrl = `https://apis.davidcyriltech.my.id/temp-mail/inbox?id=${encodeURIComponent(sessionId)}`;
        const response = await axios.get(inboxUrl);

        if (!response.data.success) {
            return reply('âŒ Invalid session ID or expired email');
        }

        const { inbox_count, messages } = response.data;

        if (inbox_count === 0) {
            return reply('ğŸ“­ Your inbox is empty');
        }

        let messageList = `ğŸ“¬ *You have ${inbox_count} message(s)*\n\n`;
        messages.forEach((msg, index) => {
            messageList += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                          `ğŸ“Œ *Message ${index + 1}*\n` +
                          `ğŸ‘¤ *From:* ${msg.from}\n` +
                          `ğŸ“ *Subject:* ${msg.subject}\n` +
                          `â° *Date:* ${new Date(msg.date).toLocaleString()}\n\n` +
                          `ğŸ“„ *Content:*\n${msg.body}\n\n`;
        });

        await reply(messageList);

    } catch (e) {
        console.error('CheckMail error:', e);
        reply(`âŒ Error checking inbox: ${e.response?.data?.message || e.message}`);
    }
});

const axios = require("axios");
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const path = require("path");
const { cmd, commands } = require("../command");

cmd({
  'pattern': "tourl",
  'alias': ["imgtourl", "imgurl", "url", "geturl", "upload"],
  'react': 'ğŸ–‡',
  'desc': "Convert media to Catbox URL",
  'category': "utility",
  'use': ".tourl [reply to media]",
  'filename': __filename
}, async (client, message, args, { reply }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType) {
      throw "Please reply to an image, video, or audio file";
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const tempFilePath = path.join(os.tmpdir(), `catbox_upload_${Date.now()}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else if (mimeType.includes('video')) extension = '.mp4';
    else if (mimeType.includes('audio')) extension = '.mp3';
    
    const fileName = `file${extension}`;

    // Prepare form data for Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), fileName);
    form.append('reqtype', 'fileupload');

    // Upload to Catbox
    const response = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    if (!response.data) {
      throw "Error uploading to Catbox";
    }

    const mediaUrl = response.data;
    fs.unlinkSync(tempFilePath);

    // Determine media type for response
    let mediaType = 'File';
    if (mimeType.includes('image')) mediaType = 'Image';
    else if (mimeType.includes('video')) mediaType = 'Video';
    else if (mimeType.includes('audio')) mediaType = 'Audio';

    // Send response
    await reply(
      `*${mediaType} Uploaded Successfully*\n\n` +
      `*Size:* ${formatBytes(mediaBuffer.length)}\n` +
      `*URL:* ${mediaUrl}\n\n` +
      `> Â© Uploaded by sir bravin ğŸ’œ`
    );

  } catch (error) {
    console.error(error);
    await reply(`Error: ${error.message || error}`);
  }
});

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

const fs = require('fs');
const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')



//vcf//

cmd({
    pattern: 'savecontact',
    alias: ["vcf","scontact","savecontacts"],
    desc: 'gc vcard',
    category: 'tools',
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isGroup) return reply("This command is for groups only.");
        if (!isOwner) return reply("*_This command is for the owner only_*");

        let card = quoted || m; // Handle if quoted message exists
        let cmiggc = groupMetadata;
        const { participants } = groupMetadata;
        
        let orgiggc = participants.map(a => a.id);
        let vcard = '';
        let noPort = 0;
        
        for (let a of cmiggc.participants) {
            vcard += `BEGIN:VCARD\nVERSION:3.0\nFN:[${noPort++}] +${a.id.split("@")[0]}\nTEL;type=CELL;type=VOICE;waid=${a.id.split("@")[0]}:+${a.id.split("@")[0]}\nEND:VCARD\n`;
        }

        let nmfilect = './contacts.vcf';
        reply('Saving ' + cmiggc.participants.length + ' participants contact');

        fs.writeFileSync(nmfilect, vcard.trim());
        await sleep(2000);

        await conn.sendMessage(from, {
            document: fs.readFileSync(nmfilect), 
            mimetype: 'text/vcard', 
            fileName: 'sir bravin.vcf', 
            caption: `\nDone saving.\nGroup Name: *${cmiggc.subject}*\nContacts: *${cmiggc.participants.length}*\n> á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê sir bravin`}, { quoted: mek });

        fs.unlinkSync(nmfilect); // Cleanup the file after sending
    } catch (err) {
        reply(err.toString());
    }
});



const { cmd } = require('../command');
const axios = require('axios');

cmd({
    pattern: "aivoice",
    alias: ["vai", "voicex", "voiceai"],
    desc: "Text to speech with different AI voices",
    category: "main",
    react: "ğŸ¥º",
    filename: __filename
},
async (conn, mek, m, { 
    from, 
    quoted, 
    body, 
    isCmd, 
    command, 
    args, 
    q, 
    isGroup, 
    sender, 
    senderNumber, 
    botNumber2, 
    botNumber, 
    pushname, 
    isMe, 
    isOwner, 
    groupMetadata, 
    groupName, 
    participants, 
    groupAdmins, 
    isBotAdmins, 
    isAdmins, 
    reply 
}) => {
    try {
        // Check if args[0] exists (user provided text)
        if (!args[0]) {
            return reply("Please provide text after the command.\nExample: .aivoice hello");
        }

        // Get the full input text
        const inputText = args.join(' ');

        // Send initial reaction
        await conn.sendMessage(from, {  
            react: { text: 'â³', key: m.key }  
        });

        // Voice model menu
        const voiceModels = [
            { number: "1", name: "Hatsune Miku", model: "miku" },
            { number: "2", name: "Nahida (Exclusive)", model: "nahida" },
            { number: "3", name: "Nami", model: "nami" },
            { number: "4", name: "Ana (Female)", model: "ana" },
            { number: "5", name: "Optimus Prime", model: "optimus_prime" },
            { number: "6", name: "Goku", model: "goku" },
            { number: "7", name: "Taylor Swift", model: "taylor_swift" },
            { number: "8", name: "Elon Musk", model: "elon_musk" },
            { number: "9", name: "Mickey Mouse", model: "mickey_mouse" },
            { number: "10", name: "Kendrick Lamar", model: "kendrick_lamar" },
            { number: "11", name: "Angela Adkinsh", model: "angela_adkinsh" },
            { number: "12", name: "Eminem", model: "eminem" }
        ];

        // Create menu text
        let menuText = "â•­â”â”â”ã€” *CRISS AI VOICE MODELS* ã€•â”â”â”âŠ·\n";
        voiceModels.forEach(model => {
            menuText += `â”ƒâ–¸ ${model.number}. ${model.name}\n`;
        });
        menuText += "â•°â”â”â”âª¼\n\n";
        menuText += `ğŸ“Œ *Reply with the number to select voice model for:*\n"${inputText}"`;

        // Send menu message with image
        const sentMsg = await conn.sendMessage(from, {  
            image: { url: "https://files.catbox.moe/37xk9g.jpg" },
            caption: menuText
        }, { quoted: m });

        const messageID = sentMsg.key.id;
        let handlerActive = true;

        // Set timeout to remove handler after 2 minutes
        const handlerTimeout = setTimeout(() => {
            handlerActive = false;
            conn.ev.off("messages.upsert", messageHandler);
            reply("âŒ› Voice selection timed out. Please try the command again.");
        }, 120000);

        // Message handler function
        const messageHandler = async (msgData) => {  
            if (!handlerActive) return;
            
            const receivedMsg = msgData.messages[0];  
            if (!receivedMsg || !receivedMsg.message) return;  

            const receivedText = receivedMsg.message.conversation || 
                              receivedMsg.message.extendedTextMessage?.text || 
                              receivedMsg.message.buttonsResponseMessage?.selectedButtonId;  
            const senderID = receivedMsg.key.remoteJid;  
            const isReplyToBot = receivedMsg.message.extendedTextMessage?.contextInfo?.stanzaId === messageID;  

            if (isReplyToBot && senderID === from) {  
                clearTimeout(handlerTimeout);
                conn.ev.off("messages.upsert", messageHandler);
                handlerActive = false;

                await conn.sendMessage(senderID, {  
                    react: { text: 'â¬‡ï¸', key: receivedMsg.key }  
                });  

                const selectedNumber = receivedText.trim();
                const selectedModel = voiceModels.find(model => model.number === selectedNumber);

                if (!selectedModel) {
                    return reply("âŒ Invalid option! Please reply with a number from the menu.");
                }

                try {
                    // Show processing message
                    await conn.sendMessage(from, {  
                        text: `ğŸ”Š Generating audio with ${selectedModel.name} voice...`  
                    }, { quoted: receivedMsg });

                    // Call the API
                    const apiUrl = `https://api.agatz.xyz/api/voiceover?text=${encodeURIComponent(inputText)}&model=${selectedModel.model}`;
                    const response = await axios.get(apiUrl, {
                        timeout: 30000 // 30 seconds timeout
                    });
                    
                    const data = response.data;

                    if (data.status === 200) {
                        await conn.sendMessage(from, {  
                            audio: { url: data.data.oss_url },  
                            mimetype: "audio/mpeg"
                            // Removed ptt: true to send as regular audio
                        }, { quoted: receivedMsg });
                    } else {
                        reply("âŒ Error generating audio. Please try again.");
                    }
                } catch (error) {
                    console.error("API Error:", error);
                    reply("âŒ Error processing your request. Please try again.");
                }
            }  
        };

        // Register the handler
        conn.ev.on("messages.upsert", messageHandler);

    } catch (error) {
        console.error("Command Error:", error);
        reply("âŒ An error occurred. Please try again.");
    }
});

const { cmd, commands } = require("../command");
const { fetchJson } = require("../lib/functions");
const { translate } = require("@vitalets/google-translate-api");

cmd({
  pattern: "wikipedia",
  alias: ["wiki"],
  react: "ğŸ’",
  desc: "Fetch Wikipedia information and translate to English.",
  category: "information",
  filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }) => {
  try {
    if (!q) {
      return reply("Please provide a search query for Wikipedia.");
    }

    await reply("Searching Wikipedia...");

    const response = await fetchJson(`https://api.siputzx.my.id/api/s/wikipedia?query=${encodeURIComponent(q)}`);

    if (!response.status || !response.data) {
      return reply("No results found for your query.");
    }

    const { wiki, thumb } = response.data;

    // Translate the Wikipedia text to English
    const translated = await translate(wiki, { to: "en" });

    let message = `ğŸ“– *Wikipedia Result*\n\nğŸ“ *Query:* ${q}\n\n${translated.text}`;

    if (thumb) {
      await conn.sendMessage(m.chat, {
        image: { url: thumb },
        caption: message
      });
    } else {
      await reply(message);
    }

  } catch (error) {
    console.error(error);
    reply("An error occurred: " + error.message);
  }
});

const { cmd } = require('../command');
const axios = require('axios');

cmd({
    pattern: "wstalk",
    alias: ["channelstalk", "chinfo"],
    desc: "Get WhatsApp channel information",
    category: "utility",
    react: "ğŸ”",
    filename: __filename
},
async (conn, mek, m, { from, reply, args }) => {
    try {
        // Check if URL is provided
        if (!args) return reply("âŒ Please provide a WhatsApp channel URL\nExample: .wstalk https://whatsapp.com/channel/0029Vb0HIV2G3R3s2II4181g");

        // Extract channel ID from URL
        const channelId = args.match(/channel\/([0-9A-Za-z]+)/i)?.[1];
        if (!channelId) return reply("âŒ Invalid WhatsApp channel URL");

        // API endpoint
        const apiUrl = `https://itzpire.com/stalk/whatsapp-channel?url=https://whatsapp.com/channel/${channelId}`;

        // Fetch channel info
        const response = await axios.get(apiUrl);
        const data = response.data.data;

        // Format the information
        const channelInfo = `â•­â”â”ã€” *CHANNEL INFO* ã€•â”â”â”ˆâŠ·
â”ƒâ—ˆâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Â·à¹
â”ƒâ—ˆâ”ƒâ€¢ *ğŸ“¢ Title*: ${data.title}
â”ƒâ—ˆâ”ƒâ€¢ *ğŸ‘¥ Followers*: ${data.followers}
â”ƒâ—ˆâ”ƒâ€¢ *ğŸ“ Description*: ${data.description.replace(/\n/g, '\nâ”ƒâ—ˆâ”ƒâ€¢ ')}
â”ƒâ—ˆâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ˆâŠ·
> Â© á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê sir bravin`;

        // Send message with channel image
        await conn.sendMessage(from, {
            image: { url: data.img },
            caption: channelInfo,
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true
            }
        }, { quoted: mek });

    } catch (e) {
        console.error("Error in wstalk command:", e);
        reply(`âŒ Error: ${e.response?.data?.message || e.message}`);
    }
});

const { cmd } = require('../command');
const fetch = require('node-fetch');

cmd({
    pattern: "tiktok2",
    alias: ["tt2", "tiktokdl2", "ttdown2", "tiktokvid2", "ttdl"],
    desc: "Download TikTok videos using a link.",
    category: "downloader",
    filename: __filename
},
async (conn, mek, m, { from, args, quoted, reply }) => {
    try {
        // Validate input
        if (!args[0]) {
            return reply(`â¤ï¸â€ğŸ©¹ Use this command like:\n *${command} <TikTok link>*`);
        }

        reply("â³ Fetching video details... Please wait.");

        const res = await fetch(`https://darkcore-api.onrender.com/api/tiktok?url=${encodeURIComponent(args[0])}`);
        if (!res.ok) {
            return reply("â Unable to fetch data. Please try again later.");
        }

        const data = await res.json();
        if (!data.success) {
            return reply("â Failed to fetch video. Please check the link and try again.");
        }

        const { author, titulo, thumbanail, mp4, mp3 } = data.result;

        // Send the initial options with a thumbnail
        const caption = `ğŸ“– *Title:* ${titulo}\nğŸ‘¤ *Author:* ${author}\n\nğŸ“¥ *Reply with:*\n1ï¸âƒ£ for *Video*\n2ï¸âƒ£ for *Audio*`;
        const menuMsg = await conn.sendMessage(from, {
            image: { url: thumbanail },
            caption
        }, { quoted: mek });

        // Wait for the user to reply with the option
        conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const userReply = msg.message.extendedTextMessage.text.trim();

            // Ensure the user reply references the correct message
            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === menuMsg.key.id) {
                if (userReply === '1') {
                    // Send video
                    await conn.sendMessage(from, {
                        video: { url: mp4 },
                        caption: "ğŸ¥ *Here is your TikTok video!*"
                    }, { quoted: mek });
                } else if (userReply === '2') {
                    // Send audio
                    await conn.sendMessage(from, {
                        audio: { url: mp3 },
                        mimetype: 'audio/mpeg',
                        caption: "ğŸµ *Here is the extracted audio!*"
                    }, { quoted: mek });
                } else {
                    reply("â Invalid option. Please reply with `1` for video or `2` for audio.");
                }
            }
        });

    } catch (error) {
        console.error(error);
        reply("â An error occurred while processing your request. Please try again later.");
    }
});



const { cmd } = require("../command");
const googleTTS = require('google-tts-api'); 

cmd({
  pattern: "tts2",
  desc: "Convert text to speech with different voices.",
  category: "fun",
  react: "ğŸ˜…",
  filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
  try {
    // Ensure there is text
    if (!q) {
      return reply("Please provide text for conversion! Usage: `.tts <text>`");
    }

    // Select voice language based on user input or default to a male voice
    let voiceLanguage = 'en-US'; // Default language is American English with a male voice
    let selectedVoice = 'male';  // Default voice type (we assume it's male by default)

    // Check if user wants a different language or voice
    if (args[0] === "male") {
      voiceLanguage = 'en-US'; // Use American male voice
    } else if (args[0] === "female") {
      voiceLanguage = 'en-GB'; // Use British female voice
      selectedVoice = 'female';
    } else if (args[0] === "loud") {
      voiceLanguage = 'en-US'; // Default male voice, but let's interpret "loud" as normal speech speed.
    } else if (args[0] === "deep") {
      voiceLanguage = 'en-US'; // Deep male voice (still has limitations with `google-tts-api`)
    } else {
      voiceLanguage = 'en-US'; // Default fallback
    }

    // Generate the URL for the TTS audio
    const url = googleTTS.getAudioUrl(q, {
      lang: voiceLanguage,  // Choose language based on selected voice
      slow: false,  // Normal speed for the speech
      host: 'https://translate.google.com'
    });

    // Send the audio message to the user
    await conn.sendMessage(from, { 
      audio: { url: url }, 
      mimetype: 'audio/mpeg', 
      ptt: true 
    }, { quoted: mek });

  } catch (error) {
    console.error(error);
    reply(`Error: ${error.message}`);
  }
});


cmd({
  pattern: "tts3",
  desc: "Convert text to speech with different voices.",
  category: "fun",
  react: "ğŸ˜…",
  filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
  try {
    // Ensure there is text
    if (!q) {
      return reply("Please provide text for conversion! Usage: `.tts2 <text>`");
    }

    // Set default language
    let voiceLanguage = 'en-US'; // Default language is American English

    // Check if user specifies Urdu language
    if (args[0] === "ur" || args[0] === "urdu") {
      voiceLanguage = 'ur'; // Set language to Urdu
    }

    // Generate the URL for the TTS audio
    const url = googleTTS.getAudioUrl(q, {
      lang: voiceLanguage,  // Choose language based on input
      slow: false,  // Normal speed for the speech
      host: 'https://translate.google.com'
    });

    // Send the audio message to the user
    await conn.sendMessage(from, { 
      audio: { url: url }, 
      mimetype: 'audio/mpeg', 
      ptt: true 
    }, { quoted: mek });

  } catch (error) {
    console.error(error);
    reply(`Error: ${error.message}`);
  }
});

const axios = require("axios");
const { cmd } = require("../command");

cmd({
  pattern: "tiktokstalk",
  alias: ["tstalk", "ttstalk"],
  react: "ğŸ“±",
  desc: "Fetch TikTok user profile details.",
  category: "sir bravin search",
  filename: __filename
}, async (conn, m, store, { from, args, q, reply }) => {
  try {
    if (!q) {
      return reply("â Please provide a TikTok username.\n\n*Example:* .tiktokstalk mrbeast");
    }

    const apiUrl = `https://api.siputzx.my.id/api/stalk/tiktok?username=${encodeURIComponent(q)}`;
    const { data } = await axios.get(apiUrl);

    if (!data.status) {
      return reply("âŒ User not found. Please check the username and try again.");
    }

    const user = data.data.user;
    const stats = data.data.stats;

    const profileInfo = `ğŸ­ *TikTok Profile Stalker* ğŸ­

ğŸ‘¤ *Username:* @${user.uniqueId}
ğŸ“› *Nickname:* ${user.nickname}
âœ… *Verified:* ${user.verified ? "Yes âœ…" : "No âŒ"}
ğŸ“ *Region:* ${user.region}
ğŸ“ *Bio:* ${user.signature || "No bio available."}
ğŸ”— *Bio Link:* ${user.bioLink?.link || "No link available."}

ğŸ“Š *Statistics:*
ğŸ‘¥ *Followers:* ${stats.followerCount.toLocaleString()}
ğŸ‘¤ *Following:* ${stats.followingCount.toLocaleString()}
â¤ï¸ *Likes:* ${stats.heartCount.toLocaleString()}
ğŸ¥ *Videos:* ${stats.videoCount.toLocaleString()}

ğŸ“… *Account Created:* ${new Date(user.createTime * 1000).toLocaleDateString()}
ğŸ”’ *Private Account:* ${user.privateAccount ? "Yes ğŸ”’" : "No ğŸŒ"}

ğŸ”— *Profile URL:* https://www.tiktok.com/@${user.uniqueId}
`;

    const profileImage = { image: { url: user.avatarLarger }, caption: profileInfo };

    await conn.sendMessage(from, profileImage, { quoted: m });
  } catch (error) {
    console.error("âŒ Error in TikTok stalk command:", error);
    reply("âš ï¸ An error occurred while fetching TikTok profile data.");
  }
});


const axios = require('axios');
const config = require('../config')
const {cmd , commands} = require('../command')
const googleTTS = require('google-tts-api')

cmd({
    pattern: "trt",
    alias: ["translate"],
    desc: "ğŸŒ Translate text between languages",
    react: "âš¡",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const args = q.split(' ');
        if (args.length < 2) return reply("â— Please provide a language code and text. Usage: .translate [language code] [text]");

        const targetLang = args[0];
        const textToTranslate = args.slice(1).join(' ');

        const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=en|${targetLang}`;

        const response = await axios.get(url);
        const translation = response.data.responseData.translatedText;

        const translationMessage = `> *sir bravin-translation*

> ğŸ”¤ *Original*: ${textToTranslate}

> ğŸ”  *Translated*: ${translation}

> ğŸŒ *Language*: ${targetLang.toUpperCase()}`;

        return reply(translationMessage);
    } catch (e) {
        console.log(e);
        return reply("âš ï¸ An error occurred data while translating the your text. Please try again laterğŸ¤•");
    }
});

//____________________________TTS___________________________
cmd({
    pattern: "tts",
    desc: "download songs",
    category: "download",
    react: "ğŸ‘§",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if(!q) return reply("Need some text.")
    const url = googleTTS.getAudioUrl(q, {
  lang: 'hi-IN',
  slow: false,
  host: 'https://translate.google.com',
})
await conn.sendMessage(from, { audio: { url: url }, mimetype: 'audio/mpeg', ptt: true }, { quoted: mek })
    }catch(a){
reply(`${a}`)
}
})

const { cmd } = require('../command');
const axios = require('axios');

cmd({
  pattern: "xstalk",
  alias: ["twitterstalk", "twtstalk"],
  desc: "Get details about a Twitter/X user.",
  react: "ğŸ”",
  category: "search",
  filename: __filename
}, async (conn, m, store, { from, quoted, q, reply }) => {
  try {
    if (!q) {
      return reply("âŒ Please provide a valid Twitter/X username.");
    }

    await conn.sendMessage(from, {
      react: { text: "â³", key: m.key }
    });

    const apiUrl = `https://delirius-apiofc.vercel.app/tools/xstalk?username=${encodeURIComponent(q)}`;
    const { data } = await axios.get(apiUrl);

    if (!data || !data.status || !data.data) {
      return reply("âš ï¸ Failed to fetch Twitter/X user details. Ensure the username is correct.");
    }

    const user = data.data;
    const verifiedBadge = user.verified ? "âœ…" : "âŒ";

    const caption = `â•­â”â”â”ã€” *TWITTER/X STALKER* ã€•â”â”â”âŠ·\n`
      + `â”ƒğŸ‘¤ *Name:* ${user.name}\n`
      + `â”ƒğŸ”¹ *Username:* @${user.username}\n`
      + `â”ƒâœ”ï¸ *Verified:* ${verifiedBadge}\n`
      + `â”ƒğŸ‘¥ *Followers:* ${user.followers_count}\n`
      + `â”ƒğŸ‘¤ *Following:* ${user.following_count}\n`
      + `â”ƒğŸ“ *Tweets:* ${user.tweets_count}\n`
      + `â”ƒğŸ“… *Joined:* ${user.created}\n`
      + `â”ƒğŸ”— *Profile:* [Click Here](${user.url})\n`
      + `â•°â”â”â”âª¼\n\n`
      + `ğŸ”¹ *Powered BY sir bravin*`;

    await conn.sendMessage(from, {
      image: { url: user.avatar },
      caption: caption
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error);
    reply("âŒ An error occurred while processing your request. Please try again.");
  }
});

const { cmd } = require('../command');
const { runtime } = require('../lib/functions');
const config = require('../config');

cmd({
    pattern: "uptime",
    alias: ["runtime", "up"],
    desc: "Show bot uptime with stylish formats",
    category: "main",
    react: "â±ï¸",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const uptime = runtime(process.uptime());
        const startTime = new Date(Date.now() - process.uptime() * 1000);
        
        // Style 1: Classic Box
        const style1 = `â•­â”€â”€â”€ã€ UPTIME ã€â”€â”€â”€â³¹
â”‚
â”‚ â±ï¸ ${uptime}
â”‚
â”‚ ğŸš€ Started: ${startTime.toLocaleString()}
â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â³¹
${config.DESCRIPTION}`;

        // Style 2: Minimalist
        const style2 = `â€¢â€”â€”[ UPTIME ]â€”â€”â€¢
  â”‚
  â”œâ”€ â³ ${uptime}
  â”œâ”€ ğŸ•’ Since: ${startTime.toLocaleTimeString()}
  â”‚
  â€¢â€”â€”[ ${config.BOT_NAME} ]â€”â€”â€¢`;

        // Style 3: Fancy Borders
        const style3 = `â–„â–€â–„â–€â–„ BOT UPTIME â–„â–€â–„â–€â–„

  â™¢ Running: ${uptime}
  â™¢ Since: ${startTime.toLocaleDateString()}
  
  ${config.DESCRIPTION}`;

        // Style 4: Code Style
        const style4 = `â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âš¡ UPTIME STATUS âš¡  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Time: ${uptime}
â”‚ â€¢ Started: ${startTime.toLocaleString()}
â”‚ â€¢ Version: 4.0.0
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`;

        // Style 5: Modern Blocks
        const style5 = `â–°â–°â–°â–°â–° UPTIME â–°â–°â–°â–°â–°

  â³ ${uptime}
  ğŸ•°ï¸ ${startTime.toLocaleString()}
  
  ${config.DESCRIPTION}`;

        // Style 6: Retro Terminal
        const style6 = `â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   ${config.BOT_NAME} UPTIME    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ > RUNTIME: ${uptime}
â•‘ > SINCE: ${startTime.toLocaleString()}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;

        // Style 7: Elegant
        const style7 = `â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â±ï¸  UPTIME  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â”‚ ${uptime}
â”‚
â”‚ Since ${startTime.toLocaleDateString()}
â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ${config.BOT_NAME}  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`;

        // Style 8: Social Media Style
        const style8 = `â±ï¸ *Uptime Report* â±ï¸

ğŸŸ¢ Online for: ${uptime}
ğŸ“… Since: ${startTime.toLocaleString()}

${config.DESCRIPTION}`;

        // Style 9: Fancy List
        const style9 = `â•”â™«â•â±ï¸â•â™«â•â•â•â•â•â•â•â•â•â•â•—
   ${config.BOT_NAME} UPTIME
â•šâ™«â•â±ï¸â•â™«â•â•â•â•â•â•â•â•â•â•â•

â€¢ãƒ»ã‚œã‚œãƒ»* âœ§  *ãƒ»ã‚œã‚œãƒ»â€¢
 âœ§ ${uptime}
 âœ§ Since ${startTime.toLocaleDateString()}
â€¢ãƒ»ã‚œã‚œãƒ»* âœ§  *ãƒ»ã‚œã‚œãƒ»â€¢`;

        // Style 10: Professional
        const style10 = `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ  UPTIME ANALYSIS  â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

â—ˆ Duration: ${uptime}
â—ˆ Start Time: ${startTime.toLocaleString()}
â—ˆ Stability: 100%
â—ˆ Version:  4.0.0

${config.DESCRIPTION}`;

        const styles = [style1, style2, style3, style4, style5, style6, style7, style8, style9, style10];
        const selectedStyle = styles[Math.floor(Math.random() * styles.length)];

        await conn.sendMessage(from, { 
            text: selectedStyle,
            contextInfo: {
                mentionedJid: [m.sender],
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363366284524544@newsletter',
                    newsletterName: config.OWNER_NAME || 'sir bravin SUPPORT',
                    serverMessageId: 143
                }
            }
        }, { quoted: mek });

    } catch (e) {
        console.error("Uptime Error:", e);
        reply(`âŒ Error: ${e.message}`);
    }
});

const axios = require('axios');
const config = require('../config');
const { cmd, commands } = require('../command');
cmd({
    pattern: "weather",
    desc: "ğŸŒ¤ Get weather information for a location",
    react: "ğŸŒ¤",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("â— Please provide a city name. Usage: .weather [city name]");
        const apiKey = '2d61a72574c11c4f36173b627f8cb177'; 
        const city = q;
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;
        const response = await axios.get(url);
        const data = response.data;
        const weather = `
> ğŸŒ *Weather Information for ${data.name}, ${data.sys.country}* ğŸŒ
> ğŸŒ¡ï¸ *Temperature*: ${data.main.temp}Â°C
> ğŸŒ¡ï¸ *Feels Like*: ${data.main.feels_like}Â°C
> ğŸŒ¡ï¸ *Min Temp*: ${data.main.temp_min}Â°C
> ğŸŒ¡ï¸ *Max Temp*: ${data.main.temp_max}Â°C
> ğŸ’§ *Humidity*: ${data.main.humidity}%
> â˜ï¸ *Weather*: ${data.weather[0].main}
> ğŸŒ«ï¸ *Description*: ${data.weather[0].description}
> ğŸ’¨ *Wind Speed*: ${data.wind.speed} m/s
> ğŸ”½ *Pressure*: ${data.main.pressure} hPa

> *Â© Powdered By sir bravin 
`;
        return reply(weather);
    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            return reply("ğŸš« City not found. Please check the spelling and try again.");
        }
        return reply("âš ï¸ An error occurred while fetching the weather information. Please try again later.");
    }
});
                 

const config = require('../config');
const { cmd } = require('../command');
const DY_SCRAP = require('@dark-yasiya/scrap');
const dy_scrap = new DY_SCRAP();

function replaceYouTubeID(url) {
    const regex = /(?:youtube\.com\/(?:.*v=|.*\/)|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/;
    const match = url.match(regex);
    return match ? match[1] : null;
}

cmd({
    pattern: "play3",
    alias: ["sir bravin mp3", "ytmp3"],
    react: "ğŸµ",
    desc: "Download Ytmp3",
    category: "download",
    use: ".song <Text or YT URL>",
    filename: __filename
}, async (conn, m, mek, { from, q, reply }) => {
    try {
        if (!q) return await reply("âŒ Please provide a Query or Youtube URL!");

        let id = q.startsWith("https://") ? replaceYouTubeID(q) : null;

        if (!id) {
            const searchResults = await dy_scrap.ytsearch(q);
            if (!searchResults?.results?.length) return await reply("âŒ No results found!");
            id = searchResults.results[0].videoId;
        }

        const data = await dy_scrap.ytsearch(`https://youtube.com/watch?v=${id}`);
        if (!data?.results?.length) return await reply("âŒ Failed to fetch video!");

        const { url, title, image, timestamp, ago, views, author } = data.results[0];

        let info = `ğŸ„ *ğš‚ğ™¾ğ™½ğ™¶ ğ™³ğ™¾ğš†ğ™½ğ™»ğ™¾ğ™°ğ™³ğ™´ğš* ğŸ„\n\n` +
            `ğŸµ *Title:* ${title || "Unknown"}\n` +
            `â³ *Duration:* ${timestamp || "Unknown"}\n` +
            `ğŸ‘€ *Views:* ${views || "Unknown"}\n` +
            `ğŸŒ *Release Ago:* ${ago || "Unknown"}\n` +
            `ğŸ‘¤ *Author:* ${author?.name || "Unknown"}\n` +
            `ğŸ–‡ *Url:* ${url || "Unknown"}\n\n` +
            `ğŸ”½ *Reply with your choice:*\n` +
            `1.1 *Audio Type* ğŸµ\n` +
            `1.2 *Document Type* ğŸ“\n\n` +
            `${config.FOOTER || "ğ“†©CRISS AIğ“†ª"}`;

        const sentMsg = await conn.sendMessage(from, { image: { url: image }, caption: info }, { quoted: mek });
        const messageID = sentMsg.key.id;
        await conn.sendMessage(from, { react: { text: 'ğŸ¶', key: sentMsg.key } });

        // Listen for user reply only once!
        conn.ev.on('messages.upsert', async (messageUpdate) => { 
            try {
                const mekInfo = messageUpdate?.messages[0];
                if (!mekInfo?.message) return;

                const messageType = mekInfo?.message?.conversation || mekInfo?.message?.extendedTextMessage?.text;
                const isReplyToSentMsg = mekInfo?.message?.extendedTextMessage?.contextInfo?.stanzaId === messageID;

                if (!isReplyToSentMsg) return;

                let userReply = messageType.trim();
                let msg;
                let type;
                let response;
                
                if (userReply === "1.1") {
                    msg = await conn.sendMessage(from, { text: "â³ Processing..." }, { quoted: mek });
                    response = await dy_scrap.ytmp3(`https://youtube.com/watch?v=${id}`);
                    let downloadUrl = response?.result?.download?.url;
                    if (!downloadUrl) return await reply("âŒ Download link not found!");
                    type = { audio: { url: downloadUrl }, mimetype: "audio/mpeg" };
                    
                } else if (userReply === "1.2") {
                    msg = await conn.sendMessage(from, { text: "â³ Processing..." }, { quoted: mek });
                    const response = await dy_scrap.ytmp3(`https://youtube.com/watch?v=${id}`);
                    let downloadUrl = response?.result?.download?.url;
                    if (!downloadUrl) return await reply("âŒ Download link not found!");
                    type = { document: { url: downloadUrl }, fileName: `${title}.mp3`, mimetype: "audio/mpeg", caption: title };
                    
                } else { 
                    return await reply("âŒ Invalid choice! Reply with 1.1 or 1.2.");
                }

                await conn.sendMessage(from, type, { quoted: mek });
                await conn.sendMessage(from, { text: 'âœ… Media Upload Successful âœ…', edit: msg.key });

            } catch (error) {
                console.error(error);
                await reply(`âŒ *An error occurred while processing:* ${error.message || "Error!"}`);
            }
        });

    } catch (error) {
        console.error(error);
        await conn.sendMessage(from, { react: { text: 'âŒ', key: mek.key } });
        await reply(`âŒ *An error occurred:* ${error.message || "Error!"}`);
    }
});
                               

const config = require('../config');
const { cmd } = require('../command');
const { ytsearch } = require('@dark-yasiya/yt-dl.js');

// MP4 video download

cmd({ 
    pattern: "mp4", 
    alias: ["video"], 
    react: "ğŸ¥", 
    desc: "Download YouTube video", 
    category: "main", 
    use: '.mp4 < Yt url or Name >', 
    filename: __filename 
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => { 
    try { 
        if (!q) return await reply("Please provide a YouTube URL or video name.");
        
        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("No results found!");
        
        let yts = yt.results[0];  
        let apiUrl = `https://apis.davidcyriltech.my.id/download/ytmp4?url=${encodeURIComponent(yts.url)}`;
        
        let response = await fetch(apiUrl);
        let data = await response.json();
        
        if (data.status !== 200 || !data.success || !data.result.download_url) {
            return reply("Failed to fetch the video. Please try again later.");
        }

        let ytmsg = `ğŸ“¹ *Video Downloader*
ğŸ¬ *Title:* ${yts.title}
â³ *Duration:* ${yts.timestamp}
ğŸ‘€ *Views:* ${yts.views}
ğŸ‘¤ *Author:* ${yts.author.name}
ğŸ”— *Link:* ${yts.url}
> Powered By sir bravin`;

        // Send video directly with caption
        await conn.sendMessage(
            from, 
            { 
                video: { url: data.result.download_url }, 
                caption: ytmsg,
                mimetype: "video/mp4"
            }, 
            { quoted: mek }
        );

    } catch (e) {
        console.log(e);
        reply("An error occurred. Please try again later.");
    }
});

// MP3 song download 

cmd({ 
    pattern: "song", 
    alias: ["play", "mp3"], 
    react: "ğŸ¶", 
    desc: "Download YouTube song", 
    category: "main", 
    use: '.song <query>', 
    filename: __filename 
}, async (conn, mek, m, { from, sender, reply, q }) => { 
    try {
        if (!q) return reply("Please provide a song name or YouTube link.");

        const yt = await ytsearch(q);
        if (!yt.results.length) return reply("No results found!");

        const song = yt.results[0];
        const apiUrl = `https://apis.davidcyriltech.my.id/youtube/mp3?url=${encodeURIComponent(song.url)}`;
        
        const res = await fetch(apiUrl);
        const data = await res.json();

        if (!data?.result?.downloadUrl) return reply("Download failed. Try again later.");

    await conn.sendMessage(from, {
    audio: { url: data.result.downloadUrl },
    mimetype: "audio/mpeg",
    fileName: `${song.title}.mp3`,
    contextInfo: {
        externalAdReply: {
            title: song.title.length > 25 ? `${song.title.substring(0, 22)}...` : song.title,
            body: "Follow our WhatsApp Channel",
            mediaType: 1,
            thumbnailUrl: song.thumbnail.replace('default.jpg', 'hqdefault.jpg'),
            sourceUrl: 'https://whatsapp.com/channel/0029VawCel7GOj9ktLjkxQ3g',
            mediaUrl: 'https://whatsapp.com/channel/0029VawCel7GOj9ktLjkxQ3g',
            showAdAttribution: true,
            renderLargerThumbnail: true
        }
    }
}, { quoted: mek });

    } catch (error) {
        console.error(error);
        reply("An error occurred. Please try again.");
    }
});

const config = require('../config');
const { cmd } = require('../command');
const yts = require('yt-search');

cmd({
    pattern: "yt2",
    alias: ["play2", "music"],
    react: "ğŸµ",
    desc: "Audio downloaded from YouTube",
    category: "download",
    use: ".song <query or url>",
    filename: __filename
}, async (conn, m, mek, { from, q, reply }) => {
    try {
        if (!q) return await reply("âŒ Please provide a song name or YouTube URL!");

        let videoUrl, title;
        
        // Check if it's a URL
        if (q.match(/(youtube\.com|youtu\.be)/)) {
            videoUrl = q;
            const videoInfo = await yts({ videoId: q.split(/[=/]/).pop() });
            title = videoInfo.title;
        } else {
            // Search YouTube
            const search = await yts(q);
            if (!search.videos.length) return await reply("âŒ No results found!");
            videoUrl = search.videos[0].url;
            title = search.videos[0].title;
        }

        await reply("â³ Downloading audio...");

        // Use API to get audio
        const apiUrl = `https://api.davidcyriltech.my.id/download/ytmp3?url=${encodeURIComponent(videoUrl)}`;
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (!data.success) return await reply("âŒ Failed to download audio!");

        await conn.sendMessage(from, {
            audio: { url: data.result.download_url },
            mimetype: 'audio/mpeg',
            ptt: false
        }, { quoted: mek });

        await reply(`âœ… *${title}* downloaded successfully!`);

    } catch (error) {
        console.error(error);
        await reply(`âŒ Error: ${error.message}`);
    }
});


const config = require('../config');
const { cmd } = require('../command');
const yts = require('yt-search');

cmd({
    pattern: "video2",
    alias: ["sir bravin mp4", "song"],
    react: "ğŸ¥",
    desc: "Download video from YouTube",
    category: "download",
    use: ".video <query or url>",
    filename: __filename
}, async (conn, m, mek, { from, q, reply }) => {
    try {
        if (!q) return await reply("âŒ Please provide a video name or YouTube URL!");

        let videoUrl, title;
        
        // Check if it's a URL
        if (q.match(/(youtube\.com|youtu\.be)/)) {
            videoUrl = q;
            const videoInfo = await yts({ videoId: q.split(/[=/]/).pop() });
            title = videoInfo.title;
        } else {
            // Search YouTube
            const search = await yts(q);
            if (!search.videos.length) return await reply("âŒ No results found!");
            videoUrl = search.videos[0].url;
            title = search.videos[0].title;
        }

        await reply("â³ Downloading video...");

        // Use API to get video
        const apiUrl = `https://apis.davidcyriltech.my.id/download/ytmp4?url=${encodeURIComponent(videoUrl)}`;
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (!data.success) return await reply("âŒ Failed to download video!");

        await conn.sendMessage(from, {
            video: { url: data.result.download_url },
            mimetype: 'video/mp4',
            caption: `*${title}*`
        }, { quoted: mek });

        await reply(`âœ… *${title}* downloaded successfully!`);

    } catch (error) {
        console.error(error);
        await reply(`âŒ Error: ${error.message}`);
    }
});

const config = require('../config')
const l = console.log
const { cmd, commands } = require('../command')
const dl = require('@bochilteam/scraper')  
const ytdl = require('yt-search');
const fs = require('fs-extra')
var videotime = 60000 // 1000 min
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
cmd({
    pattern: "yts",
    alias: ["ytsearch"],
    use: '.yts jawad',
    react: "ğŸ”",
    desc: "Search and get details from youtube.",
    category: "sir bravin search",
    filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, umarmd, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return reply('*Please give me words to search*')
try {
let yts = require("yt-search")
var arama = await yts(q);
} catch(e) {
    l(e)
return await conn.sendMessage(from , { text: '*Error !!*' }, { quoted: mek } )
}
var mesaj = '';
arama.all.map((video) => {
mesaj += ' *ğŸ–²ï¸' + video.title + '*\nğŸ”— ' + video.url + '\n\n'
});
await conn.sendMessage(from , { text:  mesaj }, { quoted: mek } )
} catch (e) {
    l(e)
  reply('*Error !!*')
}
});

const { cmd } = require('../command');
const axios = require('axios');

cmd({
  pattern: "ytstalk",
  alias: ["ytinfo"],
  desc: "Get details about a YouTube channel.",
  react: "ğŸ”",
  category: "search",
  filename: __filename
}, async (conn, m, store, { from, quoted, q, reply }) => {
  try {
    if (!q) {
      return reply("âŒ Please provide a valid YouTube channel username or ID.");
    }

    await conn.sendMessage(from, {
      react: { text: "â³", key: m.key }
    });

    const apiUrl = `https://delirius-apiofc.vercel.app/tools/ytstalk?channel=${encodeURIComponent(q)}`;
    const { data } = await axios.get(apiUrl);

    if (!data || !data.status || !data.data) {
      return reply("âš ï¸ Failed to fetch YouTube channel details. Ensure the username or ID is correct.");
    }

    const yt = data.data;
    const caption = `â•­â”â”â”ã€” *YOUTUBE STALKER* ã€•â”â”â”âŠ·\n`
      + `â”ƒğŸ‘¤ *Username:* ${yt.username}\n`
      + `â”ƒğŸ“Š *Subscribers:* ${yt.subscriber_count}\n`
      + `â”ƒğŸ¥ *Videos:* ${yt.video_count}\n`
      + `â”ƒğŸ”— *Channel Link:* (${yt.channel})\n`
      + `â•°â”â”â”âª¼\n\n`
      + `ğŸ”¹ *Powered by sir bravin*`;

    await conn.sendMessage(from, {
      image: { url: yt.avatar },
      caption: caption
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error);
    reply("âŒ An error occurred while processing your request. Please try again.");
  }
});

const { cmd } = require('../command');
const axios = require('axios');

cmd({
    pattern: "ai",
    alias: ["bot", "dj", "gpt", "gpt4", "bing"],
    desc: "Chat with an AI model",
    category: "ai",
    react: "ğŸ",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply, react }) => {
    try {
        if (!q) return reply("Please provide a message for the AI.\nExample: `.ai Hello`");

        const apiUrl = `https://lance-frank-asta.onrender.com/api/gpt?q=${encodeURIComponent(q)}`;
        const { data } = await axios.get(apiUrl);

        if (!data || !data.message) {
            await react("âŒ");
            return reply("AI failed to respond. Please try again later.");
        }

        await reply(`${data.message}`);
        await react("ğŸŸï¸");
    } catch (e) {
        console.error("Error in AI command:", e);
        await react("âŒ");
        reply("An error occurred while communicating with the AI.");
    }
});

cmd({
    pattern: "openai",
    alias: ["chatgpt", "gpt3", "open-gpt"],
    desc: "Chat with OpenAI",
    category: "ai",
    react: "ğŸ§ ",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply, react }) => {
    try {
        if (!q) return reply("Please provide a message for OpenAI.\nExample: `.openai Hello`");

        const apiUrl = `https://vapis.my.id/api/openai?q=${encodeURIComponent(q)}`;
        const { data } = await axios.get(apiUrl);

        if (!data || !data.result) {
            await react("âŒ");
            return reply("OpenAI failed to respond. Please try again later.");
        }

        await reply(`ğŸ§  *OpenAI Response:*\n\n${data.result}`);
        await react("âœ…");
    } catch (e) {
        console.error("Error in OpenAI command:", e);
        await react("âŒ");
        reply("An error occurred while communicating with OpenAI.");
    }
});

cmd({
    pattern: "deepseek",
    alias: ["deep", "seekai"],
    desc: "Chat with DeepSeek AI",
    category: "ai",
    react: "ğŸ§ ",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply, react }) => {
    try {
        if (!q) return reply("Please provide a message for DeepSeek AI.\nExample: `.deepseek Hello`");

        const apiUrl = `https://api.ryzendesu.vip/api/ai/deepseek?text=${encodeURIComponent(q)}`;
        const { data } = await axios.get(apiUrl);

        if (!data || !data.answer) {
            await react("âŒ"); 
            return reply("DeepSeek AI failed to respond. Please try again later.");
        }

        await reply(`ğŸ§  *DeepSeek AI Response:*\n\n${data.answer}`);
        await react("âœ…");
    } catch (e) {
        console.error("Error in DeepSeek AI command:", e);
        await react("âŒ");
        reply("An error occurred while communicating with DeepSeek AI.");
    }
});


